module linalg.random;

private import linalg.basic;

struct СлучДвиг48
{
	const static бцел мин = 0;
	const static бцел макс = бцел.max;

	/**
	Генерирует следующее псевдослучайное число.
	Возвращает:
		Псевдослучайное число в закрытом интервале [this.мин; this.макс]
	*/
	бцел вынь();

	/**
	Реинициализует движок. Устанавливает новое "семя", используя генерацию псевдослучайных чисел.

	If two different linear congruential engines are initialized with the same
	_seed they will generate equivalent pseudo-number sequences.
	Params:
		nx = New _seed used for pseudo-random numbers generation.
	*/
	void сей(бдол nx);
	
	private:
		static const бдол a = 25214903917;
		static const бдол b = 1L;
		static const бдол m = 1uL << 48;
		static const бдол маска = m - 1;
		бдол x = 0;
}

unittest
{
	СлучДвиг48 e1;
	e1.сей = 12345;
	for (цел i = 0; i < 100; ++i)
		e1.вынь();
	
	СлучДвиг48 e2 = e1;

	// must generate the same sequence
	for (цел i = 0; i < 100; ++i)
		assert(e1.вынь() == e2.вынь());

	e1.сей = 54321;
	e2.сей = 54321;

	// must generate the same sequence
	for (цел i = 0; i < 100; ++i)
		assert(e1.вынь() == e2.вынь());
}

/*********************************************************************/
struct ДвигМерсенаТвистера
{
	static const бцел мин = 0;
	static const бцел макс = бцел.max;

	static const бцел n = 624;
	static const бцел m = 397;

	бцел вынь();

	void сей(бцел x);

	private:
		бцел[n] s = void;
		бцел следщ = 0;		
}

unittest
{
	ДвигМерсенаТвистера e1;
	e1.сей = 12345;
	for (цел i = 0; i < 100; ++i)
		e1.вынь();
	
	ДвигМерсенаТвистера e2 = e1;

	// must generate the same sequence
	for (цел i = 0; i < 100; ++i)
		assert(e1.вынь() == e2.вынь());

	e1.сей = 54321;
	e2.сей = 54321;

	// must generate the same sequence
	for (цел i = 0; i < 100; ++i)
		assert(e1.вынь() == e2.вынь());
}

/********************************************************************/
struct ЮниформЮнитДвиг(ДвигОснова, бул слеваЗакрыт, бул справаЗакрыт)
{
	private ДвигОснова двигОснова;

	const static
	{
		реал мин = (слеваЗакрыт ? 0 : прирост) * (1/знаменатель);
		реал макс = (диапазон + (слеваЗакрыт ? 0 : прирост)) * (1/знаменатель);
	}

	private const static
	{
		реал диапазон = cast(реал)(двигОснова.макс - двигОснова.мин);
		реал прирост = (двигОснова.макс > бцел.макс) ? 2.L : 0.2L;
		реал знаменатель = диапазон + (слеваЗакрыт ? 0 : прирост) + (справаЗакрыт ? 0 : прирост);
	}

	реал вынь();

	void сей(бцел x);
}

unittest
{
	alias ЮниформЮнитДвиг!(СлучДвиг48, true, true) полностьюЗакрыт;
	alias ЮниформЮнитДвиг!(СлучДвиг48, true, false) слеваЗакрыт;
	alias ЮниформЮнитДвиг!(СлучДвиг48, false, true) справаЗакрыт;
	alias ЮниформЮнитДвиг!(СлучДвиг48, false, false) полностьюОткрыт;

	static assert(полностьюЗакрыт.мин == 0.L);
	static assert(полностьюЗакрыт.макс == 1.L);

	static assert(слеваЗакрыт.мин == 0.L);
	static assert(слеваЗакрыт.макс < 1.L);
	
	static assert(справаЗакрыт.мин > 0.L);
	static assert(справаЗакрыт.макс == 1.L);

	static assert(полностьюОткрыт.мин > 0.L);
	static assert(полностьюОткрыт.макс < 1.L);
}

/********************************************************************/
struct ЮниформЮнитДвигХайреса(ДвигОснова, бул слеваЗакрыт, бул справаЗакрыт)
{
	private ДвигОснова двигОснова;

	static const
	{
		реал мин = (слеваЗакрыт ? 0 : прирост) * (1 / знаменатель);
		реал макс = (приблМакс + (слеваЗакрыт ? 0 : прирост)) * (1 / знаменатель);
	}

	private const static
	{
		реал приблМакс = бцел.max * 0x1p32 + бцел.max;
		реал прирост = 2.L;
		реал знаменатель = приблМакс + (слеваЗакрыт ? 0 : прирост) + (справаЗакрыт ? 0 : прирост);
	}

	реал вынь();

	void сей(бцел x);
}

unittest
{
	alias ЮниформЮнитДвигХайреса!(СлучДвиг48, true, true) полностьюЗакрыт;
	alias ЮниформЮнитДвигХайреса!(СлучДвиг48, true, false) слеваЗакрыт;
	alias ЮниформЮнитДвигХайреса!(СлучДвиг48, false, true) справаЗакрыт;
	alias ЮниформЮнитДвигХайреса!(СлучДвиг48, false, false) полностьюОткрыт;

	static assert(полностьюЗакрыт.мин == 0.L);
	static assert(полностьюЗакрыт.макс == 1.L);

	static assert(слеваЗакрыт.мин == 0.L);
	static assert(слеваЗакрыт.макс < 1.L);
	
	static assert(справаЗакрыт.мин > 0.L);
	static assert(справаЗакрыт.макс == 1.L);

	static assert(полностьюОткрыт.мин > 0.L);
	static assert(полностьюОткрыт.макс < 1.L);
}
