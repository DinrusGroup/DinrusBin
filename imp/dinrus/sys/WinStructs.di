/**
Модуль структур WIN API для языка Динрус.
Разработчик Виталий Кулич.
*/
module sys.WinStructs;
import base, sys.WinConsts, sys.WinIfaces, sys.WinFuncs;
import tpl.com, sys.com, stdrus;


extern(D)
{

    struct ГУИД //Глобальный Универсальный Идентификатор
    {
        бцел a;
        бкрат b, c;
        ббайт d, e, f, g, h, i, j, k;

        /**
         * ГУИД, все значения которого являются нулями.
         */
        static ГУИД пустой = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };

        /**
         * Инициализует _новый экземпляр, используя заданные целые и байты.
         * Параметры:
         *   a = Первые 4 байта.
         *   b = Следующие 2 байта.
         *   c = Следующие 2 байта.
         *   d = Следующий байт.
         *   e = Следующий байт.
         *   f = Следующий байт.
         *   g = Следующий байт.
         *   h = Следующий байт.
         *   i = Следующий байт.
         *   j = Следующий байт.
         *   k = Следующий байт.
         * Возвращает: Результирующий ГУИД.
         */

        static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт d, ббайт e, ббайт f, ббайт g, ббайт h, ббайт i, ббайт j, ббайт k);
        static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт[] d);
        static ГУИД opCall(ткст s) ;

        /**
         * Инициализует новый экземпляр структуры ГУИД.
         */
        static ГУИД создай() ;

        /**
         * Возвращает значение, которое показывает, одинаковы ли значения у двух экземпляров.
         * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
         * Возвращает: да, если другой равен этому экземпляру; otherwise, false.
         */
        бул opEquals(ГУИД другой);

        /**
         * Сравнивает данный экземпляр с указанным ГУИДом и возвращает указание на их относительные значения.
         * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
         * Возвращает: Число, показывающее относительные значения этого и другого экземпляров.
         */
        цел opCmp(ГУИД другой) ;

        /**
        * Возвращает текстовое представление значения данного экземпляра в реестровом формате.
        * Возвращает: Текст, форматированный по образцу {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx},
        *где ГУИД представлен серией прописных шестнадцатиричных цифр, сгруппированных по
        * 8, 4, 4, 4 и 12, и разделенных дефисами.
         */

        ткст вТкст() ;

        /// ditto
        ткст вТкст(ткст формат);

        /**
         * Выводит хеш-код для данного экземпляра.
         */
        бцел вХэш();

    }
    alias ГУИД ИИД, КЛСИД, GUID, CLSID;

    struct БЕЗОПМАС
    {

        бкрат члоИзм;
        бкрат  фичи;
        бцел размЭлта;
        бцел счБлк;
        ук укНаДан;
        ГРАНБЕЗОПМАСА[1] рбмгран;

        static БЕЗОПМАС* opCall(T)(T[] массив)
        {
            auto предел = ГРАНБЕЗОПМАСА(массив.length);
            auto sa = СоздайБезопмас(ТипВариант!(T), 1, &предел);

            static if (is(T : ткст)) alias шим* Тип;
            else                       alias T Тип;

            Тип* данные;

            ДоступКДаннымБезопмаса(sa, возврзнач(данные));
            for (auto i = 0; i < массив.length; i++)
            {
                static if (is(T : ткст)) данные[i] = массив[i].вБткст();
                else                       данные[i] = массив[i];
            }
            ОтступОтДаныхБезопмаса(sa);

            return sa;
        }


        T[] вМассив(T)()
        {
            цел верхГран, нижГран;
            ДайВПределБезопмаса(this, 1, верхГран);
            ДайНПределБезопмаса(this, 1, нижГран);
            цел посчитай = верхГран - нижГран + 1;

            if (посчитай == 0) return пусто;

            T[] результат = new T[посчитай];

            static if (is(T : ткст)) alias шим* Тип;
            else                       alias T Тип;

            Тип* данные;
            ДоступКДаннымБезопмаса(this, возврзнач(данные));
            for (auto i = нижГран; i < верхГран + 1; i++)
            {
                static if (is(T : ткст)) результат[i] = бткстВТкст(данные[i]);
                else                       результат[i] = данные[i];
            }
            ОтступОтДаныхБезопмаса(this);

            return результат;
        }

        проц удали() ;
        проц блокируй();
        проц разблокируй() ;
        проц длина(цел значение);
        цел длина();

    }
    alias БЕЗОПМАС SAFEARRAY;

    /**
    * Представляет десятичное число в пределах от положительного 79,228,162,514,264,337,593,543,950,335 до отрицательного 79,228,162,514,264,337,593,543,950,335.
    */
    alias ДЕСЯТОК DECIMAL;
    struct ДЕСЯТОК
    {

        бкрат резерв;
        ббайт шкала;
        ббайт знак;
        бцел Старш32;
        бцел Младш32;
        бцел Средн32;

        /// Represents the smallest possible value.
        static ДЕСЯТОК мин = { 0, 0, ОТРИЦ_ДЕСЯТОК, бцел.max, бцел.max, бцел.max };
        /// Represents the largest possible value.
        static ДЕСЯТОК макс = { 0, 0, 0, бцел.max, бцел.max, бцел.max };
        /// Represents -1.
        static ДЕСЯТОК минусОдин = { 0, 0, ОТРИЦ_ДЕСЯТОК, 0, 1, 0 };
        /// Represents 0.
        static ДЕСЯТОК ноль = { 0, 0, 0, 0, 0, 0 };
        /// Represents 1.
        static ДЕСЯТОК один = { 0, 0, 0, 0, 1, 0 };

        /// Инициализует новый экземпляр.
        static ДЕСЯТОК opCall(T)(T значение)
        {
            ДЕСЯТОК сам;

            static if (is(T == бцел))
                ДесВарИзБцел(значение, сам);
            else static if (is(T == цел))
                ДесВарИзЦел(значение, сам);
            else static if (is(T == бдол))
                ДесВарИзБдол(значение, сам);
            else static if (is(T == дол))
                ДесВарИзДол(значение, сам);
            else static if (is(T == плав))
                ДесВарИзПлав(значение, сам);
            else static if (is(T == дво))
                ДесВарИзДво(значение, сам);
            else static assert(нет);

            return сам;
        }

        /// ditto
        static ДЕСЯТОК opCall(T = проц)(бцел lo, бцел mid, бцел hi, бул isNegative, ббайт шкала)
        {
            ДЕСЯТОК сам;
            сам.Старш32 = hi, сам.Средн32 = mid, сам.Младш32 = lo, сам.шкала = шкала, сам.знак = isNegative ? ОТРИЦ_ДЕСЯТОК : 0;
            return сам;
        }
        /// Преобразует строковое представление числа в его ДЕСЯТИЧный эквивалент.
        static ДЕСЯТОК разбор(ткст s);

        static ДЕСЯТОК абс(ДЕСЯТОК d) ;


        /// Округляет значение до ближайшего или специфичного числа.
        static ДЕСЯТОК округли(ДЕСЯТОК d, цел десятки = 0);

        /// Округляет значение до ближайшего к отрицательной бесконечности целого.
        static ДЕСЯТОК кОтрБеск(ДЕСЯТОК d) ;

        /// Возвращает интегральные числа значения.
        static ДЕСЯТОК сократи(ДЕСЯТОК d) ;

        /// Вычисляет остаток после деления двух значений.
        static ДЕСЯТОК остаток(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

        /// Складывает два значения.
        static ДЕСЯТОК сложи(ДЕСЯТОК d1, ДЕСЯТОК d2) ;
        /// Отнимает одно значение от другого.
        static ДЕСЯТОК отними(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

        /// Перемножает два значения.
        static ДЕСЯТОК умножь(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Делит два значения.
        static ДЕСЯТОК раздели(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Возвращает результат умножения значения на -1.
        static ДЕСЯТОК вОтриц(ДЕСЯТОК d) ;

        бцел вХэш() ;

        /// Преобразует численное значение данного экземпляра в эквивалентное текстовое представление.
        ткст вТкст() ;

        /// Сравнивает два значения.
        static цел сравни(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Сравнивает данный экземпляр с указанным экземпляром.
        цел сравни_с(ДЕСЯТОК значение);

        цел opCmp(ДЕСЯТОК d) ;

        /// Возвращает значение, определяющее являются ли два экземпляра одинаковыми по значению.
        static бул равны(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Returns a значение indicating whether this экземпляр and a specified экземпляр represent the same _value.
        бул равны(ДЕСЯТОК значение) ;

        бул opEquals(ДЕСЯТОК d) ;

        ДЕСЯТОК opAdd(ДЕСЯТОК d) ;
        проц opAddAssign(ДЕСЯТОК d) ;

        ДЕСЯТОК opSub(ДЕСЯТОК d) ;
        проц opSubAssign(ДЕСЯТОК d) ;


        ДЕСЯТОК opMul(ДЕСЯТОК d);
        проц opMulAssign(ДЕСЯТОК d);


        ДЕСЯТОК opDiv(ДЕСЯТОК d) ;
        проц opDivAssign(ДЕСЯТОК d) ;


        ДЕСЯТОК opMod(ДЕСЯТОК d) ;
        ДЕСЯТОК opNeg() ;
        ДЕСЯТОК opPos() ;
        ДЕСЯТОК opPostInc() ;
        ДЕСЯТОК opPostDec() ;

    }

    /**
     * Контейнер для множества различных типов.
     * Примеры:
     * ---
     * ВАРИАНТ var = 10;     // Экземпляр содержит ПТипВарианта.Ц4.
     * var = "Hello, World"; // Экземпляр теперь содержит ПТипВарианта.БинТекст.
     * var = 234.5;          // Экземпляр теперь содержит ПТипВарианта.Р8.
     * ---
     */

    alias ВАРИАНТ VARIANT;
    struct ВАРИАНТ
    {

        union
        {
            struct
            {
                /// Описывает тип данного экземпляра.
                бкрат вт;
                бкрат Резерв1;
                бкрат Резерв2;
                бкрат Резерв3;
                union
                {
                    дол долЗнач;
                    цел целЗнач;
                    ббайт ббайтЗнач;
                    крат кратЗнач;
                    плав плавЗнач;
                    дво двоЗнач;
                    БУЛ_ВАРИАНТ булЗнач;
                    цел скод;
                    дол долЗнач2;
                    дво дата;
                    шим* бстрЗнач;
                    Инкогнито инкЗнач;
                    ИДиспетчер депЗнач;
                    БЕЗОПМАС* массив;
                    ббайт* уббайтЗнач;
                    крат* укратЗнач;
                    цел* уцелЗнач;
                    дол* удолЗнач;
                    плав* уплавЗнач;
                    дво* удвоЗнач;
                    БУЛ_ВАРИАНТ* убулЗнач;
                    цел* ускод;
                    дол* удолЗнач2;
                    дво* удата;
                    шим** убстрЗнач;
                    Инкогнито* уинкЗнач;
                    ИДиспетчер* удепЗнач;
                    БЕЗОПМАС** умассив;
                    ВАРИАНТ* уварЗнач;
                    ук байреф;
                    байт байтЗнач;
                    бкрат бкратЗнач;
                    бцел бцелЗнач;
                    бдол бдолЗнач;
                    ДЕСЯТОК* удесЗнач;
                    байт* убайтЗнач;
                    крат* укратЗнач2;
                    бцел* убцелЗнач;
                    бдол* убдолЗнач;
                    struct
                    {
                        ук запись;
                        ИИнфОЗаписи инфОЗап;
                    }
                }
            }
            ДЕСЯТОК десЗнач;
        }

        /// Представляет значение _missing.
        static ВАРИАНТ Отсутствует = { вт: ПТипВарианта.Ошибка, скод: ПОшДисп.ПарамНеНайден };

        /// Представляет значение _nothing.
        static ВАРИАНТ Ничто = { вт: ПТипВарианта.Диспетчер, депЗнач: пусто };

        /// Представляет значение _null.
        static ВАРИАНТ Пусто = { вт: ПТипВарианта.Пусто };


        /**
         * Инициализует новый экземпляр с помощью указанных _значения и _типа.
         * Параметры:
         *   значение = Значение одного из приемлемых типов.
         *   тип = бкрат, идентифицирующий тип значения.
         * Возвращает: Итоговый ВАРИАНТ.
         */
        static ВАРИАНТ opCall(T)(T значение, бкрат тип = ТипВариант!(T))
        {
            ВАРИАНТ сам;
            инициализуй(сам, значение, тип);
            return сам;
        }


        private static проц инициализуй(T)(ref ВАРИАНТ ret, T значение, бкрат тип = ТипВариант!(T))
        {
            static if (is(T E == enum))
            {
                инициализуй(ret, cast(E) значение, тип);
            }
            else
            {
                ret = cast(ВАРИАНТ) значение;
                if (тип != ret.вт)
                    ИзмениТипВариантаДоп(ret, ret,  ДайЛокальНити(), ПВар.АльфаБул, тип);
            }
        }

        проц opAssign(дол значение);
        проц opAssign(цел значение);
        проц opAssign(ббайт значение);
        проц opAssign(крат значение);
        проц opAssign(плав значение);
        проц opAssign(дво значение);
        проц opAssign(бул значение);
        проц opAssign(БУЛ_ВАРИАНТ значение);
        проц opAssign(ткст значение);
        проц opAssign(Инкогнито значение);
        проц opAssign(БЕЗОПМАС* значение);
        проц opAssign(байт значение);
        проц opAssign(бкрат значение);
        проц opAssign(бцел значение);
        проц opAssign(бдол значение);
        проц opAssign(ДЕСЯТОК значение);
        проц opAssign(ббайт[] значение);

        /**
         * Стирает значение данного экземпляра и высвобождает связанную с ним память.
         * See_Also: $(LINK2 http://msdn2.microsoft.com/en-us/library/ms221165.aspx, VariantClear).
         */
        проц сотри() ;

        /**
         * Копирует данный экземпляр в целевое значение.
         * Параметры: dest = Вариант, в который копируется.
         */
        проц копируй_в(out ВАРИАНТ куда);

        /**
         * Преобразует вариант из одного типа в другой.
         * Параметры: новТип = Тип для изменения.
         */
        ВАРИАНТ измениТип(бкрат новТип);

        /**
         * Преобразует содержащееся в данном экземпле значение в текст.
         * Возвращает: Текстовое представление содержащегося в экземпле значения.
         */
        ткст вТкст() ;

        /**
         * Возвращает _value, заключённое в этом экземпляре.
         */
        V значение(V)()
        {
            static if (is(V == дол)) return долЗнач;
            else static if (is(V == цел)) return целЗнач;
            else static if (is(V == ббайт)) return ббайтЗнач;
            else static if (is(V == крат)) return кратЗнач;
            else static if (is(V == плав)) return плавЗнач;
            else static if (is(V == дво)) return двоЗнач;
            else static if (is(V == бул)) return (булЗнач == ДА_ВАРИАНТ) ? да : нет;
            else static if (is(V == БУЛ_ВАРИАНТ)) return булЗнач;
            else static if (is(V : ткст)) return бткстВТкст(бстрЗнач);
            else static if (is(V == шим*)) return бстрЗнач;
            else static if (is(V : ИДиспетчер)) return cast(V)депЗнач;
            else static if (is(V : Инкогнито)) return cast(V)инкЗнач;
            else static if (is(V == БЕЗОПМАС*)) return массив;
            else static if (массив_ли!(V)) return массив.вМассив!(typeof(*V))();
            else static if (is(V == ВАРИАНТ*)) return уварЗнач;
            else static if (is(V : Объект)) return cast(V)байреф;
            else static if (указатель_ли!(V)) return cast(V)байреф;
            else static if (is(V == байт)) return байтЗнач;
            else static if (is(V == бкрат)) return бкратЗнач;
            else static if (is(V == бцел)) return бцелЗнач;
            else static if (is(V == бдол)) return бдолЗнач;
            else static if (is(V == ДЕСЯТОК)) return десЗнач;
            else static assert(нет, stdrus.вЮ8(cast(ткст)"'" ~ V.stringof ~ "' не относится к допустимым типам."));
        }

        /**
         * Определяет, пуст ли данный экземпляр.
         */
        бул пуст_ли();
        /**
         * Определяет, является ли экземпляр _null.
         */
        бул нулл_ли();

        /**
         * Определяет, является ли экземпляр Nothing.
         */
        бул ничто_ли() ;

        цел opCmp(ВАРИАНТ тот);

        бул opEquals(ВАРИАНТ тот);

        ВАРИАНТ opCat(ВАРИАНТ тот);
        проц opCatAssign(ВАРИАНТ тот);

        ВАРИАНТ opSub(ВАРИАНТ тот) ;
        проц opSubAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opDiv(ВАРИАНТ тот) ;
        проц opDivAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opMul(ВАРИАНТ тот);
        проц opMulAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opMod(ВАРИАНТ тот);
        проц opModAssign(ВАРИАНТ тот);

        ВАРИАНТ opAnd(ВАРИАНТ тот);
        проц opAndAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opOr(ВАРИАНТ тот);
        проц opOrAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opXor(ВАРИАНТ тот) ;
        проц opXorAssign(ВАРИАНТ тот);

    }

}

extern (Windows):

    struct ОтладИнфОбАдр
{
    align(1)
    {
        т_мера  адр;
        ткст0   файл;
        ткст0   функц;
        бкрат  строка;
    }
}

struct КонтекстСледа
{
    КОНТЕКСТ контекст;
    ук процесс;
    ук нить;
}
////////////////////////////////////////////////////////////////

struct АСИНХРОН // OVERLAPPED
{
    бцел внутрен;
    бцел внутренСтарш;
    бцел смещение;
    бцел смещениеСтарш;
    ук событие;
}
////////////////////////////////////////////////////////////////////
struct ЖАНРОВЫЙ_МАППИНГ //GENERIC_MAPPING
{
    МАСКА_ДОСТУПА ЖанрЗап;
    МАСКА_ДОСТУПА ЖанрЧтен;
    МАСКА_ДОСТУПА ЖанрВып;
    МАСКА_ДОСТУПА ЖанрВсё;
}
alias ЖАНРОВЫЙ_МАППИНГ ЖАНРМАП;

///////////////////////////////////////////////////////////////////

struct АТРИБУТЫ_БЕЗОПАСНОСТИ //SECURITY_ATTRIBUTES
{
    бцел длина;
    ук дескрБезоп;
    Бул наследДескр;//BOOL: 1 или 0.
}
alias АТРИБУТЫ_БЕЗОПАСНОСТИ БЕЗАТРЫ;
///////////////////////////////////////////////////////////////

struct СКД //ACL (Список Контроля Доступа (СКД))
{
    ббайт ревизияСКД;
    ббайт Sbsz1;
    бкрат размерСКД;
    бкрат счётЗкд; //ACE - Запись Контроля Доступа (ЗКД)
    бкрат Sbsz2;
}

struct ИНФО_РЕВИЗИИ_СКД//ACL_REVISION_INFORMATION
{
    бцел ревСкд;
}

struct ИНФО_РАЗМЕРА_СКД//ACL_SIZE_INFORMATION
{
    бцел счётЗкд;
    бцел испБайтовСкд;
    бцел свобБайтовСкд;
}

struct ЗКДЗАГ//ACE_HEADER
{
    ббайт типЗкд;
    ббайт флагиЗкд;
    бкрат размЗкд;
}

struct ЗКД_ДОСТУП_ОТКРЫТ//ACCESS_ALLOWED_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}

struct ЗКД_ДОСТУП_ЗАКРЫТ//ACCESS_DENIED_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}

struct ЗКД_СИСТ_АУДИТ//SYSTEM_AUDIT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}

struct ЗКД_СИСТ_ТРЕВОГА //SYSTEM_ALARM_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}

struct ЗКД_ОБЪЕКТ_ОТКРЫТ//ACCESS_ALLOWED_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}

struct ЗКД_ОБЪЕКТ_ЗАКРЫТ//ACCESS_DENIED_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}

struct ЗКД_ОБЪЕКТ_СИСТ_АУДИТА//SYSTEM_AUDIT_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}

struct ЗКД_ОБЪЕКТ_СИСТ_ТРЕВОГИ//SYSTEM_ALARM_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}

struct ДЕСКРИПТОР_БЕЗОПАСНОСТИ //SECURITY_DESCRIPTOR
{
    ббайт ревизия;
    ббайт Sbz1;
    УПР_ДЕСКРИПТОРА_БЕЗОПАСНОСТИ упр;
    УкБИД владелец;
    УкБИД группа;
    СКД* сскд;//SACL
    СКД* дскд;//DACL
}
alias ДЕСКРИПТОР_БЕЗОПАСНОСТИ ДЕСКРБЕЗОП;
/////////////////////////////////////////////////

struct ФВРЕМЯ //FILETIME
{
    бцел датаВремяМладш;
    бцел датаВремяСтарш;
}

/////////////////////////////////////////////

struct ПОИСК_ДАННЫХ_А //WIN32_FIND_DATA
{
    бцел атрибутыФайла;
    ФВРЕМЯ времяСоздания;
    ФВРЕМЯ времяПоследнегоДоступа;
    ФВРЕМЯ времяПоследнейЗаписи;
    бцел размерФайлаВ;
    бцел размерФайлаН;
    бцел резерв0;
    бцел резерв1;
    сим имяФайла[sys.WinConsts.МАКС_ПУТЬ];
    сим альтИмяФайла[14];
}
alias ПОИСК_ДАННЫХ_А ПДАН_А;

/////////////////////////////////

struct ПОИСК_ДАННЫХ //WIN32_FIND_DATAW
{
    бцел атрибутыФайла;
    ФВРЕМЯ времяСоздания;
    ФВРЕМЯ времяПоследнегоДоступа;
    ФВРЕМЯ времяПоследнейЗаписи;
    бцел размерФайлаВ;
    бцел размерФайлаН;
    бцел резерв0;
    бцел резерв1;
    шим имяФайла[МАКС_ПУТЬ];
    шим альтИмяФайла[14];
}
alias ПОИСК_ДАННЫХ ПДАН;
/////////////////////////////////////////////

struct СТАТУС_ПАМЯТИ //MEMORYSTATUS
{
    бцел длина;
    бцел загрузкаПамяти;
    бцел всегоФиз;
    бцел всегоДоступнФиз;
    бцел всегоФайлСтр;
    бцел всегоДоступнФайлСтр;
    бцел всегоВиртуал;
    бцел всегоДоступнВиртуал;

}
alias СТАТУС_ПАМЯТИ СТАТПАМ;
/////////////////////////////////////////////////////////

struct БАЗОВАЯ_ИНФ_О_ПАМЯТИ // MEMORY_BASIC_INFORMATION
{
    ук АдресБазы;
    ук БазаАллокации;
    бцел ПротектАллокации;
    бцел РазмерОбласти;
    бцел Состояние;
    бцел Протект;
    бцел Тип;

}
alias БАЗОВАЯ_ИНФ_О_ПАМЯТИ БАЗИОП;
//////////////////////////////////////////////////

struct ЗАПИСЬ_СПИСКА //LIST_ENTRY
{
    ЗАПИСЬ_СПИСКА *СЗук;//Flink - указание на следующщую запись
    ЗАПИСЬ_СПИСКА *ПЗук;//Blink - указание на предыдущую запись
}
alias ЗАПИСЬ_СПИСКА СПИСЗАП;
/////////////////////////////////////////////////////////////

struct КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА //RTL_CRITICAL_SECTION_DEBUG
{

    бкрат Тип;
    бкрат ИндексОбратнойТрассировкиСоздателя;
    КРИТИЧЕСКАЯ_СЕКЦИЯ *КритическаяСекция;
    ЗАПИСЬ_СПИСКА СписокБлокировокПроцесса;
    бцел СчётЗаписей;
    бцел СчётРасхождений;
    бцел Свободно[2]; //Spare

}
alias КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА КРИТСЕКЦОТЛ;
//////////////////////////////////////////////////////////////////////////////////

struct КРИТИЧЕСКАЯ_СЕКЦИЯ //_RTL_CRITICAL_SECTION,
{

    КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА *ОтладИнфо;
    цел СчётБлокировок;
    цел СчётРекурсий;
    ук ВладеющаяНить;
    ук СемафорБлокировок;
    бцел СпинСчёт;

}
alias КРИТИЧЕСКАЯ_СЕКЦИЯ КРИТСЕКЦ;
///////////////////////////////////////////////////////////////////////
struct СИСТВРЕМЯ // SYSTEMTIME
{

    бкрат год;
    бкрат месяц;
    бкрат день_недели;
    бкрат день;
    бкрат час;
    бкрат минута;
    бкрат секунда;
    бкрат миллисекунды;

}
////////////////////////////////////

struct ИНФ_О_ЧАСОВОМ_ПОЯСЕ
{
    цел Разница;
    шим СтандартноеНазвание[32];
    СИСТВРЕМЯ СтандартнаяДата;
    цел СтандартнаяРазница;
    шим ИмяДейлайт [32];
    СИСТВРЕМЯ ДатаДейлайт;
    цел РазницаДейлайт;

}
alias ИНФ_О_ЧАСОВОМ_ПОЯСЕ ИНФОЧП;
///////////////////////////////////////////////////

struct ЗОНА_СОХР_ПЛАВ //FLOATING_SAVE_AREA
{
    бцел СловоУправления;
    бцел СловоСостояния;
    бцел СловоТег;
    бцел СмещениеОшибки;
    бцел СелекторОшибки;
    бцел СмещениеДанных;
    бцел СелекторДанных;
    ббайт ЗонаРегистра[80];
    бцел  СостояниеCr0Npx;
}
///////////////////////////////////////////////////////

struct КОНТЕКСТ //CONTEXT
{
    бцел ФлагиКонтекста;
    бцел Рд0;
    бцел Рд1;
    бцел Рд2;
    бцел Рд3;
    бцел Рд6;
    бцел Рд7;
    ЗОНА_СОХР_ПЛАВ ПлавСохр;
    бцел СегГс;
    бцел СегФс;
    бцел СегЕс;
    бцел СегДс;
    бцел   Edi;
    бцел   Esi;
    бцел   Ebx;
    бцел   Edx;
    бцел   Ecx;
    бцел   Eax;

    бцел   Ebp;
    бцел   Eip;
    бцел   SegCs;
    бцел   EFlags;
    бцел   Esp;
    бцел   SegSs;
    ббайт[512/*ПКонтекст.МаксПоддержРасш*/] РасширенныеРегистры;
}
//////////////////////////////////////////
struct АДРЕС //ADDRESS
{
    бцел Смещение;
    бкрат Сегмент;
    ПРежим_Адресации  Режим;
}
///////////////////////////////////////
struct АДРЕС64 //ADDRESS64
{
    бдол Смещение;
    бкрат Сегмент;
    ПРежим_Адресации  Режим;
}
/////////////////////////////////////////////
struct ПОМОЩЬОЯ //KDHELP
// вспомогательная структура для отладчика уровня ядра
{
    бцел       Нить;
    //Адрес объекта нити ядра, предоставленный в пакете WAIT_STATE_CHANGE.
    бцел       СтэкОбрВызова;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бцел       АдрФцииЯдраВызПользРеж;
    бцел      АдрФцииДиспетчераПользРеж;
    бцел       МладшАдрУрЯдра;
    бцел       СмещКУкВозврХр;
    бцел       АдрФцииДиспетчераИсклПользРеж;
    бцел       ОваСтэка;
    бцел       ЛимитСтэка;
    бцел[5]    Резерв;
}
//////////////////////////////////////////////////
struct ПОМОЩЬОЯ64 //KDHELP64
{
    бдол     Нить;
    бцел       СтэкОбрВызова;
    бцел       СмещКУкВозврХр;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бдол     АдрФцииЯдраВызПользРеж;
    бдол    АдрФцииДиспетчераПользРеж;
    бдол     МладшАдрУрЯдра;
    бдол     АдрФцииДиспетчераИсклПользРеж;
    бдол     ОваСтэка;
    бдол     ЛимитСтэка;
    бдол[5]  Резерв;
}
///////////////////////////////////
struct КАДР_СТЕКА //STACKFRAME
{
    АДРЕС     АдрСчётчикаПрограммы; //x86:EIP, x64:RIP
    АДРЕС     АдрВозврата;
    АДРЕС     АдрКадра;//x86:EBP, x64:RBP
    АДРЕС     АдрСтэка;//x86:ESP, x64:RSP
    ук       ЗаписьТабФций;//_FPO_DATA struct
    бцел[4]    АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бцел[3]    Резерв;//для ф-ции StackWalk64

    ПОМОЩЬОЯ      помОЯ;
    АДРЕС     АдрВозврХр;
}
///////////////////////////

struct КАДР_СТЕКА64 //STACKFRAME64
{
    АДРЕС64   АдрСчётчикаПрограммы;
    АДРЕС64   АдрВозврата;
    АДРЕС64   АдрКадра;
    АДРЕС64   АдрСтэка;
    АДРЕС64   АдрВозврХр;
    ук       ЗаписьТабФций;
    бдол[4]  АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бдол[3]  Резерв;
    ПОМОЩЬОЯ64    помОЯ;
}
////////////////////////////////

struct ТОЧКА //POINT
{
    цел x;//ш - координата ширины
    цел y;//в - коордиата высоты
    alias x ш, ширина;
    alias y в, высота;
}
/////////////////////////////////////////////////////////

struct РАЗМЕР //SIZE
{
    цел cx;//дш - дельта координат ширины
    цел cy;//дв - дельта координат высоты
    alias cx дш, ширина;
    alias cy дв, высота;
}
//////////////////////////////

struct ПРЯМ  //RECT
{
    цел    лево;
    цел    верх;
    цел    право;
    цел    низ;
}
/////////////////////////////////////////////////

struct РИССТРУКТ //PAINTSTRUCT
{
    ук ку;
    бул cтереть;
    ПРЯМ        пкРис;
    бул восстановить;
    бул инкОбнов;
    ббайт        кзсРезерв[32];
}
////////////////////////////////////////////////
struct ЗАПОБИСКЛ //EXCEPTION_RECORD
{
    бцел кодИскл;
    бцел флагиИскл;
    ЗАПОБИСКЛ* запОбИскл;
    ук адрИскл;
    бцел парамыНомера;
    бцел[МАКС_ИСКЛ_ПАРАМЫ] исклИнфо;
}
alias ЗАПОБИСКЛ ЗАПИСЬ_ОБ_ИСКЛЮЧЕНИИ;

/////////////////////////////////////

struct ИСКЛУКАЗАТЕЛИ//EXCEPTION_POINTERS
{
    ЗАПОБИСКЛ* исклЗап;
    КОНТЕКСТ* контЗап;
}
alias ИСКЛУКАЗАТЕЛИ ИСКЛУКАЗЫ, УКАЗАТЕЛИ_НА_ИСКЛ;
//////////////////////////////////////////

struct протзап //protoent
{
    ткст0 имя;
    ткст0* алиасы;
    крат прот;
}
/////////////////////////

struct служзап //servent
{
    ткст0 имя;
    ткст0* алиасы;
    крат порт;
    ткст0 прот;
}
//////////////////////////
struct хостзап //hostent
{
    ткст0 имя;
    ткст0* алиасы;
    version(Win32)
    {
        крат типадр;
        крат длина;
    }
    else version(BsdSockets)
    {
        цел типадр;
        цел длина;
    }
    ткст0* списадр;

    ткст0 адр()
    {
        return списадр[0];
    }
}
////////////////////////

struct адрессок //sockaddr
{
    крат семейство;
    ббайт[14] данные;
}
///////////////////////
struct адрессок_ин //sockaddr_in
{
    крат семейство =cast(крат) ПСемействоАдресов.ИНЕТ;
    крат порт;
    адрес_ин адр;
    ббайт[8] иас_ноль;
}
////////////////////////////

struct адрессок_ин6 //sockaddr_in6
{
    крат семейство = cast(крат) ПСемействоАдресов.ИНЕТ6;
    крат порт;
    бцел инфПоток;
    адрес_ин6 адр;
    бцел скопид;
}
////////////////////////////
union адрес_ин //in_addr
{
    private union _С_ун_т
    {
        private struct _С_ун_б_т
        {
            ббайт с_б1, с_б2, с_б3, с_б4;
        }
        _С_ун_в_т С_ун_б;

        private struct _С_ун_в_т
        {
            бкрат с_в1, с_в2;
        }
        _С_ун_в_т С_ун_в;

        бцел С_адр;
    }
    _С_ун_т S_ун;

    бцел с_адр;

    struct
    {
        ббайт с_сеть, с_хост;

        union
        {
            бкрат с_имп;

            struct
            {
                ббайт с_лх, с_импнет;
            }
        }
    }
}
/////////////////////////////

union адрес_ин6 //in6_addr
{
    private union _ин6_у_т
    {
        ббайт[16] у6_адр8;
        бкрат[8] у6_адр16;
        бцел[4] у6_адр32;
    }
    _ин6_у_т ин6_у;
    ббайт[16] с6_адр8;

    бкрат[8] с6_адр16;
    бцел[4] с6_адр32;

    alias с6_адр8 с6_адр;
}
//////////////////////////

struct значврем //timeval
{
    цел сек;//-унды;
    цел микросек;//-унды;
    alias сек секунды;
    alias микросек микросекунды;
}
////////////////////////////

struct набор_уд //fd_set
{
    бцел счёт_уд;
    СОКЕТ[РАЗМНАБ_УД] массив_уд;
}
alias набор_уд уднаб;
//////////////////////////////

union заминка //linger
{
    struct
    {
        бкрат вкл;
        бкрат время;
    }
    бкрат[2] массив;
}
/////////////////////////////
struct адринфо //addrinfo
{
    цел флаги;
    цел семейство;
    цел типсок;
    цел протокол;
    т_мера длинадр;
    ткст0 канонимя;
    адрессок* адр;
    адринфо* следщ;
}
/////////////////////////////////////

struct КВАДКЗС //RGBQUAD
{
    ббайт    кзсСиний;
    ббайт    кзсЗелёный;
    ббайт    кзсКрасный;
    ббайт    кзсРезерв;
}
//////////////////////////////////////////////////
struct ИНФОБИТМАПЗАГ //BITMAPINFOHEADER
{
    бцел      размер;
    цел       ширина;
    цел       высота;
    бкрат       плоскости;
    бкрат       счётБит;
    бцел      сжатие;
    бцел      размОбр;
    цел       горизПиксНаМетр;
    цел       вертПиксНаМетр;
    бцел      использУпр;
    бцел      важнЦвета;//biClrImportant;
}
////////////////////////////////////////////

struct ИНФОБИТМАП //BITMAPINFO
{
    ИНФОБИТМАПЗАГ    заголовок;//bmiHeader;
    КВАДКЗС             цвета[1];
}
//////////////////////////////////////////////////////////
struct ЗАПИСЬ_ПАЛИТРЫ //PALETTEENTRY
{
    ббайт        крас;
    ббайт        зел;
    ббайт        син;
    ббайт        флаги;
}
alias ЗАПИСЬ_ПАЛИТРЫ ПАЛИТЗАП;
////////////////////////////////////////////////////
struct ЛОГ_ПАЛИТРЫ //LOGPALETTE
{
    бкрат        версия;
    бкрат        члоЗап;
    ПАЛИТЗАП        палЗап[1];
}
alias ЛОГ_ПАЛИТРЫ ПАЛИТЛОГ;
/////////////////////////////////////////////
/* Pixel format descriptor */

struct ДЕСКРФОРМАТАПИКСЕЛЯ //PIXELFORMATDESCRIPTOR
{
    бкрат  размер;
    бкрат  версия;
    бцел   флаги;
    ббайт  типПикселя;
    ббайт  битыЦвета;
    ббайт  кБиты;//к - красный
    ббайт  кСдвиг;
    ббайт  зБиты;//з -зелёный
    ббайт  зСдвиг;
    ббайт  сБиты;//с - синий
    ббайт  сСдвиг;
    ббайт  аБиты;//а - альфа (прозрачность)
    ббайт  аСдвиг;
    ббайт  аккумБиты;
    ббайт  аккумКБиты;
    ббайт  аккумЗБиты;
    ббайт  аккумСБиты;
    ббайт  аккумАБиты;
    ббайт  битыДали; //даль = depth = "глубина" пикселей на экране
    ббайт  битыШаблона;//шаблон = stencil
    ббайт  допБуферы;
    ббайт  типСлоя;
    ббайт  резерв;
    бцел   маскаСлоя;
    бцел   маскаВидимого;
    бцел   маскаПовреждения;
}
///////////////////////////////////////////////

struct КЛАССОКДОП_А //WNDCLASSEXA
{
    бцел     размер;
    /* Win 3.x */
    бцел    стиль;
    ОКОНПРОЦ  оконПроц;
    цел     упрэлтыЭкстра;
    цел     окнаЭкстра;
    экз  	экземпляр;
    ук      пиктограмма;
    ук    	курсор;
    ук      фон;
    ткст0   имяМеню;
    ткст0   имяКласса;
    /* Win 4.0 */
    ук      пиктограммаМал;
}
alias КЛАССОКДОП_А КЛАССОКДОП;
//////////////////////////////////////////
struct КЛАССОК_А //WNDCLASSA
{
    бцел        стиль;
    ОКОНПРОЦ    оконПроц;
    цел         упрэлтыЭкстра;
    цел         окЭкстра;
    экз  		экземпляр;
    ук      	пиктограмма;
    ук    		курсор;
    ук      	фон;
    ткст0       имяМеню;
    ткст0       имяКласса;
}
alias КЛАССОК_А КЛАССОК;
////////////////////////////////////////////
struct СООБ //MSG
{
    ук      окноПолучатель;
    бцел    сообщение;
    бцел    вПарам;
    цел     лПарам;
    бцел    время;
    ТОЧКА   тчк;
}
/////////////////////////////////////////////////
struct МЕТРИКА_ТЕКСТА //TEXTMETRICA
{
    цел        высота;
    цел        подъём;
    цел        спуск;
    цел        внутрВступ;
    цел        внешнийВступ;
    цел        среднШирСим;
    цел        максШирСим;
    цел        вес;
    цел        перевес;
    цел        оцифрАспектШ;
    цел        оцифрАспектВ;
    ббайт        первСим;
    ббайт        последнСим;
    ббайт        дефолтнСим;
    ббайт        брейкСим;
    ббайт        курсив;
    ббайт        подчерк;
    ббайт        струкАут;
    ббайт        питчИСемейство;
    ббайт        гарнитура;
}
alias МЕТРИКА_ТЕКСТА ТЕКСТМЕТР;
////////////////////////////////////////////////////////
struct ОТКРФАЙЛ_А
{
    бцел        размерСтрукт;
    ук         окХозяин;
    экз    		экземпляр;
    ткст0       фильтр;
    ткст0        фильтрАдапт;
    бцел        максЧлоАдаптФильтров;
    бцел        индексФильтра;
    ткст0        файл;
    бцел        максЧлоФайлов;
    ткст0        титулФ;
    бцел        максЧлоФТитулов;
    ткст0       исхПапка;
    ткст0       титул;
    бцел        Флаги;
    бкрат         фСмещен;
    бкрат         члоФРасш;
    ткст0       дефРасш;
    цел       допДанные;
    ОТКРФЛХУКПРОЦ офХук;
    ткст0       имяШаблона;
}
//////////////////////////////////////////////////
struct ОТКРФАЙЛ //FILEOPEN
{
    бцел        размерСтрукт;
    ук         окХозяин;
    экз    экземпляр;
    шим*      фильтр;
    шим*       фильтрАдапт;
    бцел        максЧлоАдаптФильтров;
    бцел        индексФильтра;
    шим*       файл;
    бцел        максЧлоФайлов;
    шим*       титулФ;
    бцел        максЧлоФТитулов;
    шим*      исхПапка;
    шим*      титул;
    бцел        Флаги;
    бкрат         фСмещен;
    бкрат         члоФРасш;
    шим*      дефРасш;
    цел       допДанные;
    ОТКРФЛХУКПРОЦ офХук;
    шим*      имяШаблона;
}
////////////////////////////////////////
/* Bitmap Header Definition */

struct БИТМАП //BITMAP
{
    цел        тип;
    цел        ширина;
    цел        высота;
    цел        байтыШирины;
    бкрат      плоскости;
    бкрат      пиксельБит;
    ук         биты;
}
///////////////////////////////////////////////////////
struct ЛОГ_ШРИФТА //LOGFONTA
{
    цел      высота;
    цел      ширина;
    цел      lfEscapement;
    цел      ориентация;
    цел      вес;
    ббайт      курсив;
    ббайт      подчерк;
    ббайт      перечерк;
    ббайт      гарнитура;
    ббайт      выхТочность;
    ббайт      обрезТочность;
    ббайт      качество;
    ббайт      питчИСемейство;
    сим      имяКегля[32 ];
}
alias ЛОГ_ШРИФТА ШРИФТЛОГ;
////////////////////////////////////////////////////////

align (2) struct ШАБЛОНДЛГ//DLGTEMPLATE
{
    бцел стиль;
    бцел расширеннСтиль;
    бкрат cdit;
    крат x;
    alias x ш;
    крат y;
    alias y в;
    крат cx;
    alias cx дш;
    крат cy;
    alias cy дв;
}
////////////////////////////////////////////////////////

struct ЛОГ_ПЕРА //LOGPEN
{
    бцел        Стиль;
    ТОЧКА       Ширина;
    ЦВЕТ       Цвет;
}
alias ЛОГ_ПЕРА ПЕРЛОГ;
//////////////////////////////////////////////////

struct КООРД //COORD
{
    крат X;
    alias X Ш;//Ширина
    крат Y;
    alias Y В;//Высота
}
/////////////////////////////////////////////////////

struct МПРЯМ //SMALL_RECT
{
    крат лево;
    крат верх;
    крат право;
    крат низ;
}
/////////////////////////////////////////////

struct ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ
{
    Бул 	клВнизу;
    бкрат 	счётПовторов;
    бкрат 	кодВиртКл;
    бкрат 	кодВиртСкан;
    union
    {
        шим симЮникода;
        сим   симАски;
    }
    бцел состКлУпр;
}
alias ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ ЗАПСОБКЛ;
///////////////////////////////////////////////

struct ЗАПИСЬ_СОБЫТИЯ_МЫШИ
{
    КООРД позМыши;
    ПСостКнопкиМыши состКнопки;
    ПСостКлУпр состКлУпр;
    ПТипСобМыши флагиСобытия;
}
alias ЗАПИСЬ_СОБЫТИЯ_МЫШИ ЗАПСОБМЫШ;
//////////////////////////////////////////////////////////
struct ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА
{
    КООРД размер;
}
alias ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА ЗАПРАЗМБУФОК;
////////////////////////////////////////////////
struct ЗАПИСЬ_СОБЫТИЯ_МЕНЮ
{
    бцел идКоманды;
}
alias ЗАПИСЬ_СОБЫТИЯ_МЕНЮ ЗАПСОБМЕНЮ;
/////////////////////////////////////////////////
struct ЗАПИСЬ_СОБЫТИЯ_ФОКУСА
{
    Бул установитьФокус;
}
alias ЗАПИСЬ_СОБЫТИЯ_ФОКУСА ЗАПСОБФОК;
//////////////////////////////////////////////////
struct ЗАПИСЬ_ВВОДА
{
    бкрат типСобытия;
    union
    {
        ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ собКлав;
        ЗАПИСЬ_СОБЫТИЯ_МЫШИ 	собМыши;
        ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА собРазмБуфОк;
        ЗАПИСЬ_СОБЫТИЯ_МЕНЮ собМеню;
        ЗАПИСЬ_СОБЫТИЯ_ФОКУСА собФок;
    }
}
alias ЗАПИСЬ_ВВОДА ЗАПВВОДА;
///////////////////////////////////

struct ИНФОСИМ//CHAR_INFO
{
    union
    {
        шим симЮникода;
        сим   симАски;
    }
    ПАтрыИнфосим атрибуты;
}
/////////////////////////////
struct ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ //CONSOLE_SCREEN_BUFFER_INFO
{
    КООРД размер;
    КООРД позКурсора;
    бкрат  атрибуты;
    МПРЯМ окно;
    КООРД максРазмОкна;
}
alias ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ ИНФОКОНСЭКРБУФ;
////////////////////////////////////////////////////////////////

struct ИНФ_О_КУРСОРЕ_КОНСОЛИ //CONSOLE_CURSOR_INFO
{
    бцел  размер;
    Бул   видимый;
}
alias ИНФ_О_КУРСОРЕ_КОНСОЛИ ИНФОКОНСКУРСОР;
////////////////////////////////////////////////////

struct ВИНСОКДАН //WSADATA
{
    бкрат версия;
    бкрат хВерсия;
    сим описание[cast(цел) ДЛИНА_ВСАОПИСАНИЯ + 1];
    сим сисСтатус[cast(цел) ДЛИНА_ВСАСИС_СТАТУСА + 1];
    бкрат максЧлоСок;
    бкрат максДгПпд;//iMaxUdpDg;
    ткст0 инфОПроизв;//lpVendorInfo;
}
////////////////////////////////////////////////////
struct ВИНСОКБУФ //WSABUF
{
    бцел    длина;
    ук   буф;
}

/////////////////////////////////////////////////////
struct ВавЗаг
{
    сим рифф[4] = "RIFF";
    бцел размер;
    сим фмт[4] = "WAVE";

    сим идЦилиндраФмт[4]= "fmt ";
    бцел размерЦилиндраФмт;
    бкрат аудиоФормат;
    бкрат члоКаналов;
    бцел семплРейт;
    бцел байтРейт;
    бкрат раскладкаБлока;
    бкрат битНаСемпл;

    сим идЦилиндраДанных[4]= "data";
    бцел размерЦилиндраДанных;
    // data follows
}
////////////////////////////////////////////////
struct ИНФОСТАРТА //STARTUPINFO
{
    бцел размер;//этой стр-ры
    шим *резерв;//пусто
    шим *рабСтол;//название процесса на раб.ст.
    шим *титул;//если пусто, то отображается просто имя программы
    бцел ш;//смещение по ширине от левого верхнего угла
    бцел в;//то же по высоте
    бцел шразм;//ширина окна
    бцел вразм;//высота окна
    бцел школвосим;//ширина экранного буфера
    бцел вколвосим;//высота экранного буфера
    бцел запатр;//начальные цвета текста и фона
    бцел флаги; //Перечень флагов
    бкрат показОкна;
    бкрат резерв2;
    ббайт *резерв2Ук;
    ук стдвво;
    ук стдвыв;
    ук стдош;
}
///////////////////////////////////////////////////////

struct ИНФОПРОЦ //PROCESS_INFO
{
    ук процесс;
    ук нить;
    бцел идПроцесса;
    бцел идНити;
}
/////////////////////////////////////////////////////////

struct ГРАНБЕЗОПМАСА
{
    бцел члоЭлтов;
    цел нижГран;
}

struct КОСЕРВЕРИНФО //COSERVERINFO
{
    бцел резерв1;
    шим* имяОбъ;
    КОАУТИНФО* аутИнф;
    бцел резерв2;
}

struct КОАУТИДЕНТИЧНОСТЬ //COAUTHIDENTITY
{
    шим* Пользователь;
    бцел ПользовательДлина;
    шим* Домен;
    бцел ДоменДлина;
    шим* Пароль;
    бцел ПарольДлина;
    бцел Флаги;
}

struct КОАУТИНФО //COAUTHINFO
{
    бцел службаАутн;
    бцел службаАутз;
    шим* имяПринкСервера;
    бцел уровеньАутн;
    бцел уровеньИмперсонации;
    КОАУТИДЕНТИЧНОСТЬ* данныеАутИдент;
    бцел способности;
}

struct ОТКРПМБ //STATSTG
{
    шим* укНаШ0Имя;
    бцел тип;
    бдол бРазм;
    ФВРЕМЯ ивремя;
    ФВРЕМЯ свремя;
    ФВРЕМЯ двремя;
    бцел послРежДост;
    бцел поддержТипыБлокРгна;
    ГУИД клсид;
    бцел битыТекСостХр;
    бцел резерв;
}

struct ОПЦИИХР //STGOPTIONS
{
    бкрат испВерсия;
    бкрат резерв;
    бцел бдРазмСектора;
    шим* укНаШ0ФайлШаблона;
}

struct СВЯЗОПЦИИ //
{
    бцел бСтрукт = СВЯЗОПЦИИ.sizeof;
    бцел мсоФлаги;
    бцел послРежДост;
    бцел бцПредельнСрокТик;
}

struct СВЯЗОПЦИИ2
{
    бцел бСтрукт = СВЯЗОПЦИИ2.sizeof;
    бцел мсоФлаги;
    бцел послРежДост;
    бцел бцПредельнСрокТик;
    бцел бцТрэкФлаги;
    бцел бцКонтекстКласса;
    бцел локаль;
    КОСЕРВЕРИНФО* укНаСерверИнфо;
}

struct МУЛЬТИ_ОИ //MULTI_QI
{
    ГУИД* укНаИИд;
    Инкогнито укНаИз;
    цел хрез;
}

struct ЦУСТРОЙСТВО //DVTARGETDEVICE
{
    бцел цуРазм;
    бкрат цуСмещКИмениДрайвера;
    бкрат цуСмещКИмениУстрва;
    бкрат цуСмещКИмениПорта;
    бкрат цуСмещКДопУстрреж;
    ббайт* цуДанные;
}

struct ФОРМАТИТД //FORMATETC
{
    бкрат формат;
    ЦУСТРОЙСТВО* укнад;
    бцел аспект;
    цел индекс;
    бцел тимед;
}

struct НОСИТЕЛЬПАМ //STGMEDIUM
{
    бцел тимед;
    union
    {
        ук битмап;
        ук метаФайлПикт;
        ук усМетаФайл;
        ук глоб;
        шим* имяф;
        ИПоток птк;
        ИХранилище хран;
    }
    Инкогнито инкДляВысвобожд;
}

struct ОЛЕВЕРБ //OLEVERB
{
    цел верб;
    шим* имяВерба;
    бцел флаги;
    бцел грфАтры;
}

struct СТАТДАННЫЕ //STATDATA
{
    ФОРМАТИТД форматетц;
    бцел адвф;
    IAdviseSink адвСинк;
    бцел соединение;
}

struct ДИСППАРАМЫ //DISPPARAMS
{
    ВАРИАНТ* ргварг;
    цел* ргдиспидИменованыеАрги;
    бцел арги;
    бцел именованыеАрги;
}

struct ИСКЛИНФО //EXCEPINFO
{
    бкрат код;
    бкрат резерв1;
    шим* исток;
    шим* описание;
    шим* файлСправки;
    бцел контекстСправки;
    ук   резерв2;
    цел function(ИСКЛИНФО*) измененЗаполнение;
    цел скод;
}

struct ТИПДЕСКР //TYPEDESC
{
    union
    {
        ТИПДЕСКР* деск;
        МАССДЕСКР* адеск;
        бцел ссылтип;
    }
    бкрат вт;
}

struct МАССДЕСКР//ARRAYDESC
{
    ТИПДЕСКР элемДеск;
    бкрат меры;
    ГРАНБЕЗОПМАСА[1] ргграни;
}

struct ПАРАМДЕСКРДОП //PARAMDESCEX
{
    бцел байты;
    ВАРИАНТ дефЗнач;
}

struct ПАРАМДЕСКР //PARAMDESC
{
    ПАРАМДЕСКРДОП* ппарамдесцекс;
    бкрат флагиПарам;
}

struct ИДЛДЕСКР //IDLDESC
{
    бцел резерв;
    бкрат флпгиИДЛ;
}

struct ЭЛЕМДЕСКР //ELEMDESC
{
    ТИПДЕСКР дескт;
    union
    {
        ИДЛДЕСКР дескИДЛ;
        ПАРАМДЕСКР дескпарам;
    }
}

struct ТИПАТР//TYPEATTR
{
    ГУИД гуид;
    бцел лкид;
    бцел резерв;
    цел конструкторПамИД;
    цел деструкторПамИД;
    шим* схема;
    бцел размерЭкземпляра;
    ПВидТипа типвид;
    бкрат функи;
    бкрат пермы;
    бкрат имплТипы;
    бкрат размерВфт;
    бкрат раскладка;
    бкрат флагиТипов;
    бкрат номСтаршВерс;
    бкрат номМладшВерс;
    ТИПДЕСКР алиасДеск;
    ИДЛДЕСКР типДескИДЛ;
}

struct ФУНКЦДЕСКР//FUNCDESC
{
    цел идпам;
    цел* ргскод;
    ЭЛЕМДЕСКР* парамРгэлемдеск;
    ПВидФунк видфунк;
    ПВидВызова типвыз;
    ПКонвВызова конввыз;
    крат парамы;
    крат опцПарамов;
    крат ВфтО;
    крат скоды;
    ЭЛЕМДЕСКР функЭлемдеск;
    бкрат флагиФунк;
}

struct ПЕРЕМДЕСКР //VARDESC
{
    цел идпам;
    шим* схема;
    union
    {
        бцел экзО;
        ВАРИАНТ* значПерем;
    }
    ЭЛЕМДЕСКР перемДескЭлем;
    бкрат флагиПерем;
    ПВидПерем типперем;
}

struct УКПРИВЯЗ//BINDPTR
{
    ФУНКЦДЕСКР* функдескр;
    ПЕРЕМДЕСКР* вардескр;
    ITypeComp ткомп;
}

struct ОСОБЭЛДАН//CUSTDATAITEM
{
    ГУИД гуид;
    ВАРИАНТ значВар;
}

struct ОСОБДАН //CUSTDATA
{
    бцел особДанные;
    ОСОБЭЛДАН* осДан;
}

struct ИНФ_О_КАТЕГОРИИ//CATEGORYINFO
{
    ГУИД идКат;
    бцел лкид;
    шим[128] описание;
}
alias ИНФ_О_КАТЕГОРИИ ИНФОКАТ;

struct АТРТБИБ //TLIBATTR
{
    ГУИД гуид;
    бцел лкид;
    ПВидСистемы видсис;
    бкрат старшНомВер;
    бкрат младНомВер;
    бкрат флагиБиб;
}

struct РИСДЕСКР//PICTDESC
{
    бцел размер = РИСДЕСКР.sizeof;
    бцел типРис;
    ук укз;
}

struct СОЕДДАН //CONNECTDATA
{
    Инкогнито инк;
    бцел куки;
}

struct ИНФОЛИЦ //LICINFO
{
    цел инфолиц = ИНФОЛИЦ.sizeof;
    цел доступнРантаймКлюч;
    цел лицВерифицирована;
}

struct МЕТРИКА_ОЛЕ_ТЕКСТА //TEXTMETRICOLE
{
    цел высота;
    цел подъём;
    цел спуск;
    цел внутреннийВвод;
    цел внешнийВвод;
    цел средШирСим;
    цел максШирСим;
    цел вес;
    цел свис;
    цел оцифрАспектШ;
    цел оцифрАспектВ;
    шим первСим;
    шим последнСим;
    шим дефСим;
    шим брейкСим;
    ббайт курсив;
    ббайт подчерк;
    ббайт tmStruckOut;
    ббайт tmPitchAndFamily;
    ббайт гарнитура;
}
alias МЕТРИКА_ОЛЕ_ТЕКСТА ОЛЕТЕКСТМЕТР;

struct ЗАПИСЬ_КУЧИ_ПРОЦЕССА //PROCESS_HEAPENTRY
{
    ук данук;
    бцел данные;
    ббайт излишек;
    ббайт индексРегиона;
    бкрат флаги;
    union
    {
        struct Блок
        {
            ук пам;
            бцел резерв[3];
        }

        struct Регион
        {
            бцел переданныйРазм;
            бцел непереданныйРазм;
            ук первБлок;
            ук последнБлок;
        }
    }
}
alias ЗАПИСЬ_КУЧИ_ПРОЦЕССА ЗАППРОЦКУЧ;


union БОЛЬШЕЦЕЛ //БОЛЬШЕЦЕЛ
{
    struct
    {
        бцел младшЧасть;
        цел старшЧасть;
    }
    дол квадрЧасть;
}
alias БОЛЬШЕЦЕЛ ЛУИД;

union ББОЛЬШЕЦЕЛ //UБОЛЬШЕЦЕЛ
{
    struct
    {
        бцел младшЧасть;
        бцел старшЧасть;
    }
    бдол квадрЧасть;
}

align(4) struct ЛУИД_И_АТРЫ//LUID_AND_ATTRIBUTES
{
    ЛУИД луид;
    бцел атры;
}

struct УСТПРИВ//PRIVILEGE_SET
{
    бцел члоПрив;
    бцел упр;
    ЛУИД_И_АТРЫ _Привилегия;

    ЛУИД_И_АТРЫ* Привилегия()
    {
        return &_Привилегия;
    }
}

struct КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ//SECURITY_QUALITY_OF_SERVICE
{
    бцел длина;
    ПУровеньИмперсонацииБезопасности   уровеньИмп;
    РЕЖИМ_ОТСЛЕЖИВАНИЯ_КОНТЕКСТА_БЕЗОПАСНОСТИ режимОтслежКонтекста;
    бул толькоДейств;
}
alias КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ КАЧБЕЗОПСЛУЖБ;

struct БЕЗОПИМПЕРССОСТ//SE_IMPERSONATION_STATE
{
    УкТОКЕН_ДОСТУПА 				 токен;
    бул 							 копироватьПриОткр;
    бул								 толькоДейств;
    ПУровеньИмперсонацииБезопасности уровень;
}

struct БИДИДЕНТАВТОРИТ//SID_IDENTIFIER_AUTHORITY
{
    ббайт[6] знач;
}

struct БИД//SID
{
    ббайт			ревизия;
    ббайт 			члоСубАвторитов;
    БИДИДЕНТАВТОРИТ идентАвторит;
    бцел 			_ПодАвторит;

    бцел* ПодАвторит()
    {
        return &_ПодАвторит;
    }
}

struct БИД_И_АТРЫ//SID_AND_ATTRIBUTES
{
    УкБИД бид;
    бцел атры;
}

struct ИСТОК_ТОКЕНА
{
    сим[ДЛИНА_ИСТОКА_ТОКЕНА] имяИстока;
    ЛУИД идИстока;
}
alias ИСТОК_ТОКЕНА ТОКИСТ;

struct ТОКЕНУПР//TOKEN_CONTROL
{
    ЛУИД         идТокена;
    ЛУИД         идАутентик;
    ЛУИД         идИзмененный;
    ТОКИСТ		 токИст;
}

struct ДЕФОЛТ_ДСКД_ТОКЕН//TOKEN_DEFAULT_DACL
{
    СКД* дефолтДскд;
}
alias ДЕФОЛТ_ДСКД_ТОКЕН ДЕФДСКДТОК;

struct ГРУППЫ_ТОКЕНОВ//TOKEN_GROUPS
{
    бцел 		члоГрупп;
    БИД_И_АТРЫ	 _Группы;

    БИД_И_АТРЫ* Группы()
    {
        return &_Группы;
    }
}
alias ГРУППЫ_ТОКЕНОВ ТОКЕНГРУП;

struct ВЛАДЕЛЕЦ_ТОКЕНА //TOKEN_OWNER
{
    УкБИД владелец;
}

struct ПЕРВИЧН_ГРУППА_ТОКЕНОВ//TOKEN_PRIMARY_GROUP
{
    УкБИД первичнГруппа;
}

struct ПРИВИЛЕГИИ_ТОКЕНОВ//TOKEN_PRIVILEGES
{
    бцел 		члоПривилегий;
    ЛУИД_И_АТРЫ _Привилегии;

    ЛУИД_И_АТРЫ* Привилегии()
    {
        return &_Привилегии;
    }
}

struct ТОКЕНСТАТ //TOKEN_STATISTICS
{
    ЛУИД         					 идТокена;
    ЛУИД         					 идАутентификации;
    БОЛЬШЕЦЕЛ 						 времяУстаревания;
    ПТипТокена  					 типТокена;
    ПУровеньИмперсонацииБезопасности уровеньИмп;
    бцел        					 динамичПрисв;
    бцел       						 динамичДоступ;
    бцел      						 члоГрупп;
    бцел     						 члоПривилегий;
    ЛУИД      						 идИзменённый;
}

struct ПОЛЬЗОВАТЕЛЬ_ТОКЕНА//TOKEN_USER
{
    БИД_И_АТРЫ пользователь;
}

struct ПРЕДЕЛЫ_КВОТ//QUOTA_LIMITS
{
    т_мера пределПулаСтр;
    т_мера пределПулаБезСтр;
    т_мера минРазмРабНабора;
    т_мера максРазмРабНабора;
    т_мера пределПейджфайла;
    БОЛЬШЕЦЕЛ пределВремени;
}

///////////////////////////////////
align(4):
    struct ФАЙЛЗАГ_ОБРАЗА//IMAGE_FILE_HEADER
{
    бкрат    Машина;
    бкрат    ЧлоСекций;
    бцел      ШтампВремени;
    бцел      УкНаСимТаб;
    бцел      ЧлоСим;
    бкрат    РазмОпцЗаг;
    бкрат    Характеристики;
}
alias ФАЙЛЗАГ_ОБРАЗА ФЗАГОБР;
////////////////////////////////////

struct ПАПКА_ДАННЫХ_ОБРАЗА //IMAGE_DATA_DIRECTORY
{
    бцел ВиртАдрес;
    бцел Размер;
}
alias ПАПКА_ДАННЫХ_ОБРАЗА ПАПДАНОБР;
/////////////////////////////////////////////////////

struct ОПЦЗАГ_ОБРАЗА //IMAGE_OPTIONAL_HEADER32
{
    //
    // Стандартные поля.
    //
    бкрат  Маг;
    ббайт  СтаршВерсКомпоновщика;
    ббайт   МладшВерсКомпоновщика;
    бцел   РазмерКода;
    бцел   РазмерИнициализДанных;
    бцел   РазмерНеинициализДанных;
    бцел   АдресТочкиВхода;
    бцел   ОваКода;
    бцел   ОваДанных;
    //
    // дополнительные поля НТ.
    //
    бцел   ОваОбраза;
    бцел   РаскладСекц;
    бцел   РаскладФайла;
    бкрат  СтаршВерсОС;
    бкрат  МладшВерсОС;
    бкрат  СтаршВерсОбр;
    бкрат  МладшВерсОбр;
    бкрат  СтаршВерсПодсист;
    бкрат  МладшВерсПодсист;
    бцел   ЗначВерсВин32;
    бцел   РазмерОбраза;
    бцел   РазмерЗагов;
    бцел   КСумма;
    бкрат  Подсистема;
    бкрат  ХарактеристикиДЛЛ;
    бцел   РазмерСтэкРезерва;
    бцел   РазмерСтэкКоммит;
    бцел   РазмерРезерваКучи;
    бцел   РазмерКоммитКучи;
    бцел   ФлагиЗагрузчика;
    бцел   ЧлоОВАиРазмеры;

    ПАПДАНОБР ПапкаДанных[16];
}
alias ОПЦЗАГ_ОБРАЗА ОПЦЗАГОБР;
////////////////////////////////////////////////

struct ОПЦЗАГ_ОБРАЗА_РОМ //IMAGE_ROM_OPTIONAL_HEADER
{
    бкрат     Маг;
    ббайт     СтаршВерсКомпоновщика;
    ббайт     МладшВерсКомпоновщика;
    бцел    РазмерКода;
    бцел    РазмерИнициализДанных;
    бцел    РазмерНеинициализДанных;
    бцел    АдресТочкиВхода;
    бцел    ОваКода;
    бцел    ОваДанных;
    бцел    ОваБсс;
    бцел    МаскаГпр;
    бцел[4] МаскаЦпр;
    бцел    ЗначениеГп;
}
alias ОПЦЗАГ_ОБРАЗА_РОМ ОПЦЗАГОБРРОМ;
///////////////////////////////////////////////////////////////////
align(2):
    struct ЗАГОЛОВОК_ОБРАЗА_ДОС //IMAGE_DOS_HEADER
{
    бкрат     маг;
    бкрат     члобайтпослстр;//число байтов последней страницы
    бкрат     члопар; //число страниц в файле
    бкрат     релок;//релокации
    бкрат     члопарвзаг;//число параграфов в заголовке
    бкрат     минтребдоппараг;//минимальное необходимое число дополнительных параграфов
    бкрат     макстребдоппараг;//максимальное число необходимых доп. параграфов
    бкрат     сс;//Начальное (относительное) значение SS
    бкрат     сп;//Начальное значение SP
    бкрат     кс;//контрольная сумма
    бкрат     ип;//Начальное значение IP
    бкрат     цс;//Начальное значение CS
    бкрат     фадртабрелок;//Файловый адрес таблицы релокаций
    бкрат     номовер;//Номер оверлея
    бкрат[4]  резерв;//Резервированные слова
    бкрат     оемид;//Идентификатор OEM
    бкрат     оеминфо;//Информация OEM
    бкрат[10]  резерв2;//Резервированные слова
    LONG      фадрновэкезаг;//Файловый адрес нового заголовка экзэ
}

alias ЗАГОЛОВОК_ОБРАЗА_ДОС ЗАГОБРДОС;
////////////////////////////////////////

struct ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА //IMAGE_SECTION_HEADER
{
    ббайт[8] Имя;//ПРазмОбраза.РазмКратИмени
    union _Разное
    {
        бцел ФизичАдрес;
        бцел ВиртРазмер;
    }
    _Разное Разное;
    бцел ВиртАдрес;
    бцел РазмерНеобрДанных;
    бцел УкНаНеобрДанные;
    бцел УкНаРелокации;
    бцел УкНаНомераСтрок;
    бкрат  ЧлоРелокаций;
    бкрат  ЧлоНОмеровСтрок;
    бцел Характеристики;
}
alias ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА ЗАГСЕКЦОБР;

////////////////////////////////////////////

struct ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА //IMAGE_SEPARATE_DEBUG_HEADER
{
    бкрат        Сигнатура;
    бкрат        Флаги;
    бкрат        Машина;
    бкрат        Characteristics;
    бцел       ШтампВремени;
    бцел       КСумма;
    бцел       ОваОбраза;
    бцел       РазмерОбраза;
    бцел       ЧлоСекций;
    бцел       РазмЭкпортИмён;
    бцел       РазмПапкиОтлад;
    бцел       РаскладСекц;
    бцел       Резерв[2];
}
alias ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА ОТДЕЛЬНОТЛАДЗАГОБР;
///////////////////////////////////////

struct ЗАГОЛОВКИ_ОБРАЗА_НТ //IMAGE_NT_HEADERS
{
    бцел Сигнатура;
    ФЗАГОБР ФайлЗаг;
    ОПЦЗАГОБР ОпцЗаг;
}
alias ЗАГОЛОВКИ_ОБРАЗА_НТ НТОБРЗАГИ;
////////////////////////////////////////

struct ИНФ_О_СИМВОЛЕ
{
    бцел РазмерСтруктуры;
    бцел ИндексТипа;
    бдол Резерв[2];
    бцел Индекс;
    бцел Размер;
    бдол ОваМод;
    бцел Флаги;
    бдол Значение;
    бдол Адрес;
    бцел Регистр;
    бцел Масштаб;
    бцел Тэг;
    бцел ДлинаИм;
    бцел МаксДлинаИм;
    сим Имя[1];
}

//////////////////////////
struct СКУ //DCB
{
    бцел СКУразм = СКУ.sizeof;
    бцел бодрейт;
    /+
    бцел fBinary:1;              // Binary Mode (skip EOF check)
    бцел fParity:1;              // Enable parity checking
    бцел fOutxCtsFlow:1;         // CTS handshaking on output
    бцел fOutxDsrFlow:1;         // DSR handshaking on output
    бцел fDtrControl:2;          // DTR Flow control
    бцел fDsrSensitivity:1;      // DSR Sensitivity
    бцел fTXContinueOnXoff:1;    // Continue TX when Xoff sent
    бцел fOutX:1;                // Enable output X-ON/X-OFF
    бцел fInX:1;                 // Enable input X-ON/X-OFF
    бцел fErrorChar:1;           // Enable Err Replacement
    бцел fNull:1;                // Enable Null stripping
    бцел fRtsControl:2;          // Rts Flow control
    бцел fAbortOnError:1;        // Abort all reads and writes on Error
    бцел fDummy2:17;             // Reserved

    typedef struct _DCB
    {
        DWORD DCBlength;
        DWORD BaudRate;
        DWORD fBinary  :1;
        DWORD fParity  :1;
        DWORD fOutxCtsFlow  :1;
        DWORD fOutxDsrFlow  :1;
        DWORD fDtrControl  :2;
        DWORD fDsrSensitivity  :1;
        DWORD fTXContinueOnXoff  :1;
        DWORD fOutX  :1;
        DWORD fInX  :1;
        DWORD fErrorChar  :1;
        DWORD fNull  :1;
        DWORD fRtsControl  :2;
        DWORD fAbortOnError  :1;
        DWORD fDummy2  :17;
        WORD wReserved;
        WORD XonLim;
        WORD XoffLim;
        BYTE ByteSize;
        BYTE Parity;
        BYTE StopBits;
        char XonChar;
        char XoffChar;
        char ErrorChar;
        char EofChar;
        char EvtChar;
        WORD wReserved1;
    } DCB;

    +/
    бцел _бф;
    бул фБинар(бул ф)
    {
        _бф = (_бф & ~0x0001) | ф;
        return ф;
    }
    бул фПаритет(бул ф)
    {
        _бф = (_бф & ~0x0002) | (ф<<1);
        return ф;
    }
    бул фСиТиЭс(бул ф)
    {
        _бф = (_бф & ~0x0004) | (ф<<2);
        return ф;
    }
    бул фДиЭсАр(бул ф)
    {
        _бф = (_бф & ~0x0008) | (ф<<3);
        return ф;
    }
    байт фДиТиАр(байт x)
    {
        _бф = (_бф & ~0x0030) | (x<<4);
        return cast(байт)(x & 3);
    }
    бул фЧувствительностьДиЭсАр(бул ф)
    {
        _бф = (_бф & ~0x0040) | (ф<<6);
        return ф;
    }
    бул фПродолжитьТиЭксПриЭксвыкл(бул ф)
    {
        _бф = (_бф & ~0x0080) | (ф<<7);
        return ф;
    }
    бул фВыхЭкс(бул ф)
    {
        _бф = (_бф & ~0x0100) | (ф<<8);
        return ф;
    }
    бул фВхЭкс(бул ф)
    {
        _бф = (_бф & ~0x0200) | (ф<<9);
        return ф;
    }
    бул фОшСим(бул ф)
    {
        _бф = (_бф & ~0x0400) | (ф<<10);
        return ф;
    }
    бул фНулл(бул ф)
    {
        _бф = (_бф & ~0x0800) | (ф<<11);
        return ф;
    }
    байт фАрТиЭс(байт x)
    {
        _бф = (_бф & ~0x3000) | (x<<12);
        return cast(байт)(x & 3);
    }
    бул фАбортПриОш(бул ф)
    {
        _бф = (_бф & ~0x4000) | (ф<<14);
        return ф;
    }

    бул фБинар()
    {
        return cast(бул) (_бф & 1);
    }
    бул фПаритет()
    {
        return cast(бул) (_бф & 2);
    }
    бул фСиТиЭс()
    {
        return cast(бул) (_бф & 4);
    }
    бул фДиЭсАр()
    {
        return cast(бул) (_бф & 8);
    }
    байт фДиТиАр()
    {
        return cast(байт) ((_бф & (32+16))>>4);
    }
    бул фЧувствительностьДиЭсАр()
    {
        return cast(бул) (_бф & 64);
    }
    бул фПродолжитьТиЭксПриЭквыкл()
    {
        return cast(бул) (_бф & 128);
    }
    бул фВыхЭкс()
    {
        return cast(бул) (_бф & 256);
    }
    бул фВхЭкс()
    {
        return cast(бул) (_бф & 512);
    }
    бул фОшСим()
    {
        return cast(бул) (_бф & 1024);
    }
    бул фНулл()
    {
        return cast(бул) (_бф & 2048);
    }
    байт фАрТиЭс()
    {
        return cast(байт) ((_бф & (4096+8192))>>12);
    }
    бул фАбортПриОш()
    {
        return cast(бул) (_бф & 16384);
    }

    бкрат резерв;
    бкрат эксвклЛим;
    бкрат эксвыклЛим;
    ббайт байтРазм;
    ббайт паритет;
    ббайт стопБиты;
    сим эксвклСим;
    сим эксвыклСим;
    сим ошСим;
    сим кфСим;
    сим собСим;
    бкрат резерв1;
}
alias СКУ СЕРИЙНЫЕ_КОММУНИКАЦИОННЫЕ_УСТРОЙСТВА;

struct КОММТАЙМАУТЫ //COMTIMEOUTS
{
    бцел ТаймаутИнтервалаЧтения;
    бцел МультипликаторТаймаутаОбщегоЧтения;
    бцел КонстантаТаймаутаОбщегоЧтения;
    бцел МультипликаторТаймаутаОбщейЗаписи;
    бцел КонстантаТаймаутаОбщейЗаписи;
}

struct КОММСТАТ //COMSTAT
{
    /+
    DWORD fCtsHold:1;
    DWORD fDsrHold:1;
    DWORD fRlsdHold:1;
    DWORD fXoffHold:1;
    DWORD fXoffSent:1;
    DWORD fEof:1;
    DWORD fTxim:1;
    DWORD fReserved:25;
    +/
    бцел _бф;
    бул фОжиданиеСиТиЭс(бул ф)
    {
        _бф = (_бф & ~1) | ф;
        return ф;
    }
    бул фОжиданиеДиЭсАр(бул ф)
    {
        _бф = (_бф & ~2) | (ф<<1);
        return ф;
    }
    бул фОжиданиеАрЭлЭсДи(бул ф)
    {
        _бф = (_бф & ~4) | (ф<<2);
        return ф;
    }
    бул фОжиданиеЭксвыкл(бул ф)
    {
        _бф = (_бф & ~8) | (ф<<3);
        return ф;
    }
    бул фОтправленЭксвыкл(бул ф)
    {
        _бф = (_бф & ~16) | (ф<<4);
        return ф;
    }
    бул фКф(бул ф)
    {
        _бф = (_бф & ~32) | (ф<<5);
        return ф;
    }
    бул фТиэксим(бул ф)
    {
        _бф = (_бф & ~64) | (ф<<6);
        return ф;
    }

    бул фОжиданиеСиТиЭс()
    {
        return cast(бул) (_бф & 1);
    }
    бул фОжиданиеДиЭсАр()
    {
        return cast(бул) (_бф & 2);
    }
    бул фОжиданиеАрЭлЭсДи()
    {
        return cast(бул) (_бф & 4);
    }
    бул фОжиданиеЭксвыкл()
    {
        return cast(бул) (_бф & 8);
    }
    бул фОтправленЭксвыкл()
    {
        return cast(бул) (_бф & 16);
    }
    бул фКф()
    {
        return cast(бул) (_бф & 32);
    }
    бул фТиэксим()
    {
        return cast(бул) (_бф & 64);
    }

    бцел вхОч;
    бцел выхОч;
}
alias КОММСТАТ СТАТИСТИКА_КОММУНИКАЦИИ;
/////////////////////////////////////////
struct КОММКОНФИГ
{
    бцел размер = КОММКОНФИГ.sizeof;
    бкрат  версия;
    бкрат  резерв;
    СКУ   ску;
    бцел подтипПровайдера;
    бцел СмещениеПровайдера;
    бцел размерПровайдера;
    шим _данныеОПровайдере;

    шим* данныеОПровайдере()
    {
        return &_данныеОПровайдере;
    }
}
alias КОММКОНФИГ КОНФИГУРАЦИЯ_КОММУНИКАЦИИ;
//////////////////////////////////////////////

struct АКТКТКСА //ACTCTXA
{
    бцел размер = this.sizeof;
    бцел флаги;
    ткст0 исток;
    бкрат архПроцессора;
    ИДЯз идЯзыка;
    ткст0 папкаСборки;
    ткст0 имяРесурса;
    ткст0 имяПриложения;
    ук модуль;
}
alias АКТКТКСА КОНТЕКСТ_АКТИВАЦИИ_А;
//////////////////////////////////////////////

struct АКТКТКС //ACTCTXW
{
    бцел размер = this.sizeof;
    бцел флаги;
    ткст0 исток;
    бкрат архПроцессора;
    ИДЯз идЯзыка;
    шткст *папкаСборки;
    шткст *имяРесурса;
    шткст *имяПриложения;
    ук модуль;
}
alias АКТКТКС КОНТЕКСТ_АКТИВАЦИИ;
