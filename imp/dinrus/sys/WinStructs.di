/**
Модуль структур WIN API для языка Динрус.
Разработчик Виталий Кулич.
*/
module sys.WinStructs;
import base, sys.WinConsts, sys.WinIfaces, sys.WinFuncs;
import tpl.com, sys.com, stdrus;


extern(D)
{

 struct ГУИД //Глобальный Универсальный Идентификатор
	{
	  бцел a;
	  бкрат b, c;
	  ббайт d, e, f, g, h, i, j, k;

	  /**
	   * ГУИД, все значения которого являются нулями.
	   */
	  static ГУИД пустой = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };

	  /**
	   * Инициализует _новый экземпляр, используя заданные целые и байты.
	   * Параметры:
	   *   a = Первые 4 байта.
	   *   b = Следующие 2 байта.
	   *   c = Следующие 2 байта.
	   *   d = Следующий байт.
	   *   e = Следующий байт.
	   *   f = Следующий байт.
	   *   g = Следующий байт.
	   *   h = Следующий байт.
	   *   i = Следующий байт.
	   *   j = Следующий байт.
	   *   k = Следующий байт.
	   * Возвращает: Результирующий ГУИД.
	   */

	 static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт d, ббайт e, ббайт f, ббайт g, ббайт h, ббайт i, ббайт j, ббайт k);	  
	  static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт[] d);	  
	  static ГУИД opCall(ткст s) ;
 
	  /**
	   * Инициализует новый экземпляр структуры ГУИД.
	   */
	  static ГУИД создай() ;

	  /**
	   * Возвращает значение, которое показывает, одинаковы ли значения у двух экземпляров.
	   * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
	   * Возвращает: да, если другой равен этому экземпляру; otherwise, false.
	   */
	  бул opEquals(ГУИД другой);

	  /**
	   * Сравнивает данный экземпляр с указанным ГУИДом и возвращает указание на их относительные значения.
	   * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
	   * Возвращает: Число, показывающее относительные значения этого и другого экземпляров.
	   */
	  цел opCmp(ГУИД другой) ;

	  /**
		* Возвращает текстовое представление значения данного экземпляра в реестровом формате.
		* Возвращает: Текст, форматированный по образцу {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx},
		*где ГУИД представлен серией прописных шестнадцатиричных цифр, сгруппированных по
		* 8, 4, 4, 4 и 12, и разделенных дефисами.
	   */
		  
	  ткст вТкст() ;

	  /// ditto
	  ткст вТкст(ткст формат);

	  /**
	   * Выводит хеш-код для данного экземпляра.
	   */
	  бцел вХэш();

	}
	alias ГУИД ИИД, КЛСИД;

struct БЕЗОПМАС
	 {

	  бкрат члоИзм;
	  бкрат  фичи;
	  бцел размЭлта;
	  бцел счБлк;
	  ук укНаДан;
	  ГРАНБЕЗОПМАСА[1] рбмгран;
	  
	  static БЕЗОПМАС* opCall(T)(T[] массив) {
		auto предел = ГРАНБЕЗОПМАСА(массив.length);
		auto sa = СоздайБезопмас(ТипВариант!(T), 1, &предел);

		static if (is(T : ткст)) alias шим* Тип;
		else                       alias T Тип;

		Тип* данные;
		
		ДоступКДаннымБезопмаса(sa, возврзнач(данные));
		for (auto i = 0; i < массив.length; i++) {
		  static if (is(T : ткст)) данные[i] = массив[i].вБткст();
		  else                       данные[i] = массив[i];
		}
		ОтступОтДаныхБезопмаса(sa);

		return sa;
	  }

	  
	  T[] вМассив(T)() {
		цел верхГран, нижГран;
		ДайВПределБезопмаса(this, 1, верхГран);
		ДайНПределБезопмаса(this, 1, нижГран);
		цел посчитай = верхГран - нижГран + 1;

		if (посчитай == 0) return пусто;

		T[] результат = new T[посчитай];

		static if (is(T : ткст)) alias шим* Тип;
		else                       alias T Тип;

		Тип* данные;
		ДоступКДаннымБезопмаса(this, возврзнач(данные));
		for (auto i = нижГран; i < верхГран + 1; i++) {
		  static if (is(T : ткст)) результат[i] = бткстВТкст(данные[i]);
		  else                       результат[i] = данные[i];
		}
		ОтступОтДаныхБезопмаса(this);

		return результат;
	  }

	  проц удали() ; 
	  проц блокируй();
	  проц разблокируй() ;
	  проц длина(цел значение);
	  цел длина();
	  
	}

	 /**
	 * Представляет десятичное число в пределах от положительного 79,228,162,514,264,337,593,543,950,335 до отрицательного 79,228,162,514,264,337,593,543,950,335.
	 */
	struct ДЕСЯТОК {

	  бкрат резерв;
	  ббайт шкала;
	  ббайт знак;
	  бцел Старш32;
	  бцел Младш32;
	  бцел Средн32;

	  /// Represents the smallest possible value.
	  static ДЕСЯТОК мин = { 0, 0, ОТРИЦ_ДЕСЯТОК, бцел.max, бцел.max, бцел.max };
	  /// Represents the largest possible value.
	  static ДЕСЯТОК макс = { 0, 0, 0, бцел.max, бцел.max, бцел.max };
	  /// Represents -1.
	  static ДЕСЯТОК минусОдин = { 0, 0, ОТРИЦ_ДЕСЯТОК, 0, 1, 0 };
	  /// Represents 0.
	  static ДЕСЯТОК ноль = { 0, 0, 0, 0, 0, 0 };
	  /// Represents 1.
	  static ДЕСЯТОК один = { 0, 0, 0, 0, 1, 0 };

	  /// Инициализует новый экземпляр.
	  static ДЕСЯТОК opCall(T)(T значение) {
		ДЕСЯТОК сам;

		static if (is(T == бцел))
		  ДесВарИзБцел(значение, сам);
		else static if (is(T == цел))
		  ДесВарИзЦел(значение, сам);
		else static if (is(T == бдол))
		  ДесВарИзБдол(значение, сам);
		else static if (is(T == дол))
		  ДесВарИзДол(значение, сам);
		else static if (is(T == плав))
		  ДесВарИзПлав(значение, сам);
		else static if (is(T == дво))
		  ДесВарИзДво(значение, сам);
		else static assert(нет);

		return сам;
	  }

	  /// ditto
	  static ДЕСЯТОК opCall(T = проц)(бцел lo, бцел mid, бцел hi, бул isNegative, ббайт шкала) {
		ДЕСЯТОК сам;
		сам.Старш32 = hi, сам.Средн32 = mid, сам.Младш32 = lo, сам.шкала = шкала, сам.знак = isNegative ? ОТРИЦ_ДЕСЯТОК : 0;
		return сам;
	  }
	  /// Преобразует строковое представление числа в его ДЕСЯТИЧный эквивалент.
	  static ДЕСЯТОК разбор(ткст s);

	  static ДЕСЯТОК абс(ДЕСЯТОК d) ;
	  

	  /// Округляет значение до ближайшего или специфичного числа.
	  static ДЕСЯТОК округли(ДЕСЯТОК d, цел десятки = 0);

	  /// Округляет значение до ближайшего к отрицательной бесконечности целого.
	  static ДЕСЯТОК кОтрБеск(ДЕСЯТОК d) ;

	  /// Возвращает интегральные числа значения.
	  static ДЕСЯТОК сократи(ДЕСЯТОК d) ;

	  /// Вычисляет остаток после деления двух значений.
	  static ДЕСЯТОК остаток(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

	  /// Складывает два значения.
	  static ДЕСЯТОК сложи(ДЕСЯТОК d1, ДЕСЯТОК d2) ;
	  /// Отнимает одно значение от другого.
	  static ДЕСЯТОК отними(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

	  /// Перемножает два значения.
	  static ДЕСЯТОК умножь(ДЕСЯТОК d1, ДЕСЯТОК d2);

	  /// Делит два значения.
	  static ДЕСЯТОК раздели(ДЕСЯТОК d1, ДЕСЯТОК d2);

	  /// Возвращает результат умножения значения на -1.
	  static ДЕСЯТОК вОтриц(ДЕСЯТОК d) ;
	  
	  бцел вХэш() ;

	  /// Преобразует численное значение данного экземпляра в эквивалентное текстовое представление.
	  ткст вТкст() ;

	  /// Сравнивает два значения.
	  static цел сравни(ДЕСЯТОК d1, ДЕСЯТОК d2);

	  /// Сравнивает данный экземпляр с указанным экземпляром.
	  цел сравни_с(ДЕСЯТОК значение);
	  
	  цел opCmp(ДЕСЯТОК d) ;

	  /// Возвращает значение, определяющее являются ли два экземпляра одинаковыми по значению.
	  static бул равны(ДЕСЯТОК d1, ДЕСЯТОК d2);

	  /// Returns a значение indicating whether this экземпляр and a specified экземпляр represent the same _value.
	  бул равны(ДЕСЯТОК значение) ;

	  бул opEquals(ДЕСЯТОК d) ;

	  ДЕСЯТОК opAdd(ДЕСЯТОК d) ;	  
		 проц opAddAssign(ДЕСЯТОК d) ;	  

	 ДЕСЯТОК opSub(ДЕСЯТОК d) ;
	 проц opSubAssign(ДЕСЯТОК d) ;
	  
	  
	   ДЕСЯТОК opMul(ДЕСЯТОК d);
		 проц opMulAssign(ДЕСЯТОК d);
	  
	  
	   ДЕСЯТОК opDiv(ДЕСЯТОК d) ;
		 проц opDivAssign(ДЕСЯТОК d) ;
	  
	 
	  ДЕСЯТОК opMod(ДЕСЯТОК d) ;
	  ДЕСЯТОК opNeg() ;
	  ДЕСЯТОК opPos() ;
	  ДЕСЯТОК opPostInc() ;
	  ДЕСЯТОК opPostDec() ;

	}  

	/**
	 * Контейнер для множества различных типов.
	 * Примеры:
	 * ---
	 * ВАРИАНТ var = 10;     // Экземпляр содержит ПТипВарианта.Ц4.
	 * var = "Hello, World"; // Экземпляр теперь содержит ПТипВарианта.БинТекст.
	 * var = 234.5;          // Экземпляр теперь содержит ПТипВарианта.Р8.
	 * ---
	 */


struct ВАРИАНТ
	 {
	
	  union {
		struct {
		  /// Описывает тип данного экземпляра.
		  бкрат вт;
		  бкрат Резерв1;
		  бкрат Резерв2;
		  бкрат Резерв3;
		  union {
			дол долЗнач;
			цел целЗнач;
			ббайт ббайтЗнач;
			крат кратЗнач;
			плав плавЗнач;
			дво двоЗнач;
			БУЛ_ВАРИАНТ булЗнач;
			цел скод;
			дол долЗнач2;
			дво дата;
			шим* бстрЗнач;
			Инкогнито инкЗнач;
			ИДиспетчер депЗнач;
			БЕЗОПМАС* массив;
			ббайт* уббайтЗнач;
			крат* укратЗнач;
			цел* уцелЗнач;
			дол* удолЗнач;
			плав* уплавЗнач;
			дво* удвоЗнач;
			БУЛ_ВАРИАНТ* убулЗнач;
			цел* ускод;
			дол* удолЗнач2;
			дво* удата;
			шим** убстрЗнач;
			Инкогнито* уинкЗнач;
			ИДиспетчер* удепЗнач;
			БЕЗОПМАС** умассив;
			ВАРИАНТ* уварЗнач;
			ук байреф;
			байт байтЗнач;
			бкрат бкратЗнач;
			бцел бцелЗнач;
			бдол бдолЗнач;
			ДЕСЯТОК* удесЗнач;
			байт* убайтЗнач;
			крат* укратЗнач2;
			бцел* убцелЗнач;
			бдол* убдолЗнач;
			struct {
			  ук запись;
			  ИИнфОЗаписи инфОЗап;
			}
		  }
		}
		ДЕСЯТОК десЗнач;
	  }

	  /// Представляет значение _missing.
	  static ВАРИАНТ Отсутствует = { вт: ПТипВарианта.Ошибка, скод: ПОшДисп.ПарамНеНайден };

	  /// Представляет значение _nothing.
	  static ВАРИАНТ Ничто = { вт: ПТипВарианта.Диспетчер, депЗнач: пусто };

	  /// Представляет значение _null.
	  static ВАРИАНТ Пусто = { вт: ПТипВарианта.Пусто };


		/**
		 * Инициализует новый экземпляр с помощью указанных _значения и _типа.
		 * Параметры:
		 *   значение = Значение одного из приемлемых типов.
		 *   тип = бкрат, идентифицирующий тип значения.
		 * Возвращает: Итоговый ВАРИАНТ.
		 */
		static ВАРИАНТ opCall(T)(T значение, бкрат тип = ТипВариант!(T)) 
		{
		  ВАРИАНТ сам;
		  инициализуй(сам, значение, тип);
		  return сам;
		}
	  

	  private static проц инициализуй(T)(ref ВАРИАНТ ret, T значение, бкрат тип = ТипВариант!(T))
	  {
		static if (is(T E == enum))
		{
		  инициализуй(ret, cast(E) значение, тип);
		}
		else
		{
		  ret = cast(ВАРИАНТ) значение;
		  if (тип != ret.вт)
			ИзмениТипВариантаДоп(ret, ret,  ДайЛокальНити(), ПВар.АльфаБул, тип);
		}
	  }

	  проц opAssign(дол значение);
	  проц opAssign(цел значение);
	  проц opAssign(ббайт значение);
	  проц opAssign(крат значение);
	  проц opAssign(плав значение);
	  проц opAssign(дво значение);
	  проц opAssign(бул значение);
	  проц opAssign(БУЛ_ВАРИАНТ значение);
	  проц opAssign(ткст значение);
	  проц opAssign(Инкогнито значение);
	  проц opAssign(БЕЗОПМАС* значение);
	  проц opAssign(байт значение);
	  проц opAssign(бкрат значение);
	  проц opAssign(бцел значение);
	  проц opAssign(бдол значение);
	  проц opAssign(ДЕСЯТОК значение);
	  проц opAssign(ббайт[] значение);

	  /**
	   * Стирает значение данного экземпляра и высвобождает связанную с ним память.
	   * See_Also: $(LINK2 http://msdn2.microsoft.com/en-us/library/ms221165.aspx, VariantClear).
	   */
	  проц сотри() ;

	  /**
	   * Копирует данный экземпляр в целевое значение.
	   * Параметры: dest = Вариант, в который копируется.
	   */
	  проц копируй_в(out ВАРИАНТ куда);

	  /**
	   * Преобразует вариант из одного типа в другой.
	   * Параметры: новТип = Тип для изменения.
	   */
	  ВАРИАНТ измениТип(бкрат новТип);

	  /**
	   * Преобразует содержащееся в данном экземпле значение в текст.
	   * Возвращает: Текстовое представление содержащегося в экземпле значения.
	   */
	  ткст вТкст() ;
	  
	  /**
	   * Возвращает _value, заключённое в этом экземпляре.
	   */
	  V значение(V)()
	  {
		static if (is(V == дол)) return долЗнач;
		else static if (is(V == цел)) return целЗнач;
		else static if (is(V == ббайт)) return ббайтЗнач;
		else static if (is(V == крат)) return кратЗнач;
		else static if (is(V == плав)) return плавЗнач;
		else static if (is(V == дво)) return двоЗнач;
		else static if (is(V == бул)) return (булЗнач == ДА_ВАРИАНТ) ? да : нет;
		else static if (is(V == БУЛ_ВАРИАНТ)) return булЗнач;
		else static if (is(V : ткст)) return бткстВТкст(бстрЗнач);
		else static if (is(V == шим*)) return бстрЗнач;
		else static if (is(V : ИДиспетчер)) return cast(V)депЗнач;
		else static if (is(V : Инкогнито)) return cast(V)инкЗнач;
		else static if (is(V == БЕЗОПМАС*)) return массив;
		else static if (массив_ли!(V)) return массив.вМассив!(typeof(*V))();
		else static if (is(V == ВАРИАНТ*)) return уварЗнач;
		else static if (is(V : Объект)) return cast(V)байреф;
		else static if (указатель_ли!(V)) return cast(V)байреф;
		else static if (is(V == байт)) return байтЗнач;
		else static if (is(V == бкрат)) return бкратЗнач;
		else static if (is(V == бцел)) return бцелЗнач;
		else static if (is(V == бдол)) return бдолЗнач;
		else static if (is(V == ДЕСЯТОК)) return десЗнач;
		else static assert(нет, stdrus.вЮ8(cast(ткст)"'" ~ V.stringof ~ "' не относится к допустимым типам."));
	  }

	  /**
	   * Определяет, пуст ли данный экземпляр.
	   */
	  бул пуст_ли();
	  /**
	   * Определяет, является ли экземпляр _null.
	   */
	  бул нулл_ли();

	  /**
	   * Определяет, является ли экземпляр Nothing.
	   */
	  бул ничто_ли() ;

	  цел opCmp(ВАРИАНТ тот);

	  бул opEquals(ВАРИАНТ тот);

	  ВАРИАНТ opCat(ВАРИАНТ тот);
	   проц opCatAssign(ВАРИАНТ тот);
	   
	  ВАРИАНТ opSub(ВАРИАНТ тот) ;
	   проц opSubAssign(ВАРИАНТ тот) ;
	   
		ВАРИАНТ opDiv(ВАРИАНТ тот) ;
	   проц opDivAssign(ВАРИАНТ тот) ;
	 
		ВАРИАНТ opMul(ВАРИАНТ тот);
	   проц opMulAssign(ВАРИАНТ тот) ;
	   
		ВАРИАНТ opMod(ВАРИАНТ тот);
	   проц opModAssign(ВАРИАНТ тот);
	   
		ВАРИАНТ opAnd(ВАРИАНТ тот);
	   проц opAndAssign(ВАРИАНТ тот) ;
	  
		ВАРИАНТ opOr(ВАРИАНТ тот);
	   проц opOrAssign(ВАРИАНТ тот) ;
	   
		ВАРИАНТ opXor(ВАРИАНТ тот) ;
	   проц opXorAssign(ВАРИАНТ тот);
	 
	}

}

extern (Windows):

struct ОтладИнфОбАдр
 {
    align(1) {
        т_мера  адр;
        ткст0   файл;
        ткст0   функц;
        бкрат  строка;
    }
}

 struct КонтекстСледа
 {
        КОНТЕКСТ контекст;
        ук процесс;
        ук нить;
 }
////////////////////////////////////////////////////////////////

	struct АСИНХРОН // OVERLAPPED 
	{
	бцел внутрен;
	бцел внутренСтарш;
	бцел смещение;
	бцел смещениеСтарш;
	ук событие;
	}
////////////////////////////////////////////////////////////////////	
	struct ЖАНРОВЫЙ_МАППИНГ //GENERIC_MAPPING
	{
	МАСКА_ДОСТУПА ЖанрЗап;
	МАСКА_ДОСТУПА ЖанрЧтен;
	МАСКА_ДОСТУПА ЖанрВып;
	МАСКА_ДОСТУПА ЖанрВсё;
	}	
	alias ЖАНРОВЫЙ_МАППИНГ ЖАНРМАП;
	
///////////////////////////////////////////////////////////////////	

	struct АТРИБУТЫ_БЕЗОПАСНОСТИ //SECURITY_ATTRIBUTES
	{
	бцел длина;
	ук дескрБезоп;
	Бул наследДескр;//BOOL: 1 или 0.
	}
	alias АТРИБУТЫ_БЕЗОПАСНОСТИ БЕЗАТРЫ;	
///////////////////////////////////////////////////////////////	

	struct СКД //ACL (Список Контроля Доступа (СКД))
	{
	  ббайт ревизияСКД;
	  ббайт Sbsz1;
	  бкрат размерСКД;
	  бкрат счётЗкд; //ACE - Запись Контроля Доступа (ЗКД)
	  бкрат Sbsz2;
	}	
	
	struct ИНФО_РЕВИЗИИ_СКД//ACL_REVISION_INFORMATION
	{
	бцел ревСкд;
	}
	
	struct ИНФО_РАЗМЕРА_СКД//ACL_SIZE_INFORMATION
	{
	бцел счётЗкд;
	бцел испБайтовСкд;
	бцел свобБайтовСкд;
	}
	
	struct ЗКДЗАГ//ACE_HEADER
	{
	ббайт типЗкд;
	ббайт флагиЗкд;
	бкрат размЗкд;
	}
	
	struct ЗКД_ДОСТУП_ОТКРЫТ//ACCESS_ALLOWED_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_ДОСТУП_ЗАКРЫТ//ACCESS_DENIED_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_СИСТ_АУДИТ//SYSTEM_AUDIT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_СИСТ_ТРЕВОГА //SYSTEM_ALARM_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_ОТКРЫТ//ACCESS_ALLOWED_OBJECT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_ЗАКРЫТ//ACCESS_DENIED_OBJECT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_СИСТ_АУДИТА//SYSTEM_AUDIT_OBJECT_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_СИСТ_ТРЕВОГИ//SYSTEM_ALARM_OBJECT_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ДЕСКРИПТОР_БЕЗОПАСНОСТИ //SECURITY_DESCRIPTOR
	  {
		ббайт ревизия;
		ббайт Sbz1;
		УПР_ДЕСКРИПТОРА_БЕЗОПАСНОСТИ упр;
		УкБИД владелец;
		УкБИД группа;
		СКД* сскд;//SACL
		СКД* дскд;//DACL
	  }
	alias ДЕСКРИПТОР_БЕЗОПАСНОСТИ ДЕСКРБЕЗОП;	
/////////////////////////////////////////////////

	struct ФВРЕМЯ //FILETIME
	{
	бцел датаВремяМладш;
	бцел датаВремяСтарш;
	}	

/////////////////////////////////////////////	

	struct ПОИСК_ДАННЫХ_А //WIN32_FIND_DATA
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	сим имяФайла[sys.WinConsts.МАКС_ПУТЬ];
	сим альтИмяФайла[14];
	}
	alias ПОИСК_ДАННЫХ_А ПДАН_А;	

/////////////////////////////////	

	struct ПОИСК_ДАННЫХ //WIN32_FIND_DATAW
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	шим имяФайла[МАКС_ПУТЬ];
	шим альтИмяФайла[14];
	}
	alias ПОИСК_ДАННЫХ ПДАН;	
/////////////////////////////////////////////

	struct СТАТУС_ПАМЯТИ //MEMORYSTATUS
	{
	бцел длина;
	бцел загрузкаПамяти;
	бцел всегоФиз;
	бцел всегоДоступнФиз;
	бцел всегоФайлСтр;
	бцел всегоДоступнФайлСтр;
	бцел всегоВиртуал;
	бцел всегоДоступнВиртуал;

	}
	alias СТАТУС_ПАМЯТИ СТАТПАМ;		
/////////////////////////////////////////////////////////

	struct БАЗОВАЯ_ИНФ_О_ПАМЯТИ // MEMORY_BASIC_INFORMATION 
	{
		ук АдресБазы;
		ук БазаАллокации;
		бцел ПротектАллокации;
		бцел РазмерОбласти;
		бцел Состояние;
		бцел Протект;
		бцел Тип;
		
	}
	alias БАЗОВАЯ_ИНФ_О_ПАМЯТИ БАЗИОП;
//////////////////////////////////////////////////

	struct ЗАПИСЬ_СПИСКА //LIST_ENTRY
	{
		ЗАПИСЬ_СПИСКА *СЗук;//Flink - указание на следующщую запись
		ЗАПИСЬ_СПИСКА *ПЗук;//Blink - указание на предыдущую запись
	}
	alias ЗАПИСЬ_СПИСКА СПИСЗАП;
/////////////////////////////////////////////////////////////

	struct КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА //RTL_CRITICAL_SECTION_DEBUG
	{

	бкрат Тип;
	бкрат ИндексОбратнойТрассировкиСоздателя;
	КРИТИЧЕСКАЯ_СЕКЦИЯ *КритическаяСекция;
	ЗАПИСЬ_СПИСКА СписокБлокировокПроцесса;
	бцел СчётЗаписей;
	бцел СчётРасхождений;
	бцел Свободно[2]; //Spare

	}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА КРИТСЕКЦОТЛ;
//////////////////////////////////////////////////////////////////////////////////

	struct КРИТИЧЕСКАЯ_СЕКЦИЯ //_RTL_CRITICAL_SECTION,
	{

		КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА *ОтладИнфо;
		цел СчётБлокировок;
		цел СчётРекурсий;
		ук ВладеющаяНить;
		ук СемафорБлокировок;
		бцел СпинСчёт;
		
	}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ КРИТСЕКЦ;
///////////////////////////////////////////////////////////////////////
	struct СИСТВРЕМЯ // SYSTEMTIME
	{

	бкрат год;
	бкрат месяц;
	бкрат день_недели;
	бкрат день;
	бкрат час;
	бкрат минута;
	бкрат секунда;
	бкрат миллисекунды;

	}
////////////////////////////////////

	struct ИНФ_О_ЧАСОВОМ_ПОЯСЕ
	{
	цел Разница;
	шим СтандартноеНазвание[32];
	СИСТВРЕМЯ СтандартнаяДата;
	цел СтандартнаяРазница;
	шим ИмяДейлайт [32];
	СИСТВРЕМЯ ДатаДейлайт;
	цел РазницаДейлайт;

	}
	alias ИНФ_О_ЧАСОВОМ_ПОЯСЕ ИНФОЧП;
///////////////////////////////////////////////////

	struct ЗОНА_СОХР_ПЛАВ //FLOATING_SAVE_AREA
	{
	бцел СловоУправления;
	бцел СловоСостояния;
	бцел СловоТег;
	бцел СмещениеОшибки;
	бцел СелекторОшибки;
	бцел СмещениеДанных;
	бцел СелекторДанных;
	ббайт ЗонаРегистра[80];
	бцел  СостояниеCr0Npx;
	}
///////////////////////////////////////////////////////

	struct КОНТЕКСТ //CONTEXT
	{
	бцел ФлагиКонтекста;
	бцел Рд0;
	бцел Рд1;
	бцел Рд2;
	бцел Рд3;
	бцел Рд6;
	бцел Рд7;
	ЗОНА_СОХР_ПЛАВ ПлавСохр;
	бцел СегГс;
	бцел СегФс;
	бцел СегЕс;
	бцел СегДс;
		бцел   Edi;
		бцел   Esi;
		бцел   Ebx;
		бцел   Edx;
		бцел   Ecx;
		бцел   Eax;
		
		бцел   Ebp;
		бцел   Eip;
		бцел   SegCs;              
		бцел   EFlags;            
		бцел   Esp;
		бцел   SegSs;
		ббайт[512/*ПКонтекст.МаксПоддержРасш*/] РасширенныеРегистры;
	}
//////////////////////////////////////////
	struct АДРЕС //ADDRESS
	{
	бцел Смещение;
	бкрат Сегмент;
	ПРежим_Адресации  Режим;
	}
///////////////////////////////////////
	struct АДРЕС64 //ADDRESS64
	{
	бдол Смещение;
	бкрат Сегмент;
	ПРежим_Адресации  Режим;
	}
/////////////////////////////////////////////
	struct ПОМОЩЬОЯ //KDHELP
	// вспомогательная структура для отладчика уровня ядра
	{
    бцел       Нить;
	//Адрес объекта нити ядра, предоставленный в пакете WAIT_STATE_CHANGE.
    бцел       СтэкОбрВызова;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бцел       АдрФцииЯдраВызПользРеж;
    бцел      АдрФцииДиспетчераПользРеж;
    бцел       МладшАдрУрЯдра;
    бцел       СмещКУкВозврХр;
    бцел       АдрФцииДиспетчераИсклПользРеж;
    бцел       ОваСтэка;
    бцел       ЛимитСтэка;
    бцел[5]    Резерв;
	}
//////////////////////////////////////////////////
	struct ПОМОЩЬОЯ64 //KDHELP64
	{
    бдол     Нить;
    бцел       СтэкОбрВызова;
    бцел       СмещКУкВозврХр;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бдол     АдрФцииЯдраВызПользРеж;
    бдол    АдрФцииДиспетчераПользРеж;
    бдол     МладшАдрУрЯдра;
    бдол     АдрФцииДиспетчераИсклПользРеж;
    бдол     ОваСтэка;
    бдол     ЛимитСтэка;
    бдол[5]  Резерв;
	}
///////////////////////////////////
	struct КАДР_СТЕКА //STACKFRAME
	{
    АДРЕС     АдрСчётчикаПрограммы; //x86:EIP, x64:RIP
    АДРЕС     АдрВозврата;
    АДРЕС     АдрКадра;//x86:EBP, x64:RBP
    АДРЕС     АдрСтэка;//x86:ESP, x64:RSP
    ук       ЗаписьТабФций;//_FPO_DATA struct
    бцел[4]    АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бцел[3]    Резерв;//для ф-ции StackWalk64

    ПОМОЩЬОЯ      помОЯ;
    АДРЕС     АдрВозврХр;
	}
///////////////////////////

	struct КАДР_СТЕКА64 //STACKFRAME64
	{
    АДРЕС64   АдрСчётчикаПрограммы;
    АДРЕС64   АдрВозврата;
    АДРЕС64   АдрКадра;
    АДРЕС64   АдрСтэка;
    АДРЕС64   АдрВозврХр;
    ук       ЗаписьТабФций;
    бдол[4]  АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бдол[3]  Резерв;
    ПОМОЩЬОЯ64    помОЯ;
	}
////////////////////////////////

	struct ТОЧКА //POINT
	{
	  цел x;//ш - координата ширины
	  цел y;//в - коордиата высоты
	  alias x ш, ширина;
	  alias y в, высота;
	}
/////////////////////////////////////////////////////////

	struct РАЗМЕР //SIZE
	{
	  цел cx;//дш - дельта координат ширины
	  цел cy;//дв - дельта координат высоты
	  alias cx дш, ширина;
	  alias cy дв, высота;
	}
//////////////////////////////

	struct ПРЯМ  //RECT
	{
		цел    лево;
		цел    верх;
		цел    право;
		цел    низ;
	}
/////////////////////////////////////////////////

	struct РИССТРУКТ //PAINTSTRUCT
	{
		ук ку;
		бул cтереть;
		ПРЯМ        пкРис;
		бул восстановить;
		бул инкОбнов;
		ббайт        кзсРезерв[32];
	}	
////////////////////////////////////////////////
	struct ЗАПОБИСКЛ //EXCEPTION_RECORD 
	{
	бцел кодИскл;
	бцел флагиИскл;
	ЗАПОБИСКЛ* запОбИскл;
	ук адрИскл;
	бцел парамыНомера;
	бцел[МАКС_ИСКЛ_ПАРАМЫ] исклИнфо;
	}
	alias ЗАПОБИСКЛ ЗАПИСЬ_ОБ_ИСКЛЮЧЕНИИ;
	
	/////////////////////////////////////
	
	struct ИСКЛУКАЗАТЕЛИ//EXCEPTION_POINTERS
	{
	ЗАПОБИСКЛ* исклЗап;
	КОНТЕКСТ* контЗап;
	}
	alias ИСКЛУКАЗАТЕЛИ ИСКЛУКАЗЫ, УКАЗАТЕЛИ_НА_ИСКЛ;
	//////////////////////////////////////////

	struct протзап //protoent
	{
	ткст0 имя;
	ткст0* алиасы;
	крат прот;
	}
/////////////////////////
	
	struct служзап //servent
	{
	ткст0 имя;
	ткст0* алиасы;
	крат порт;
	ткст0 прот;
	}
//////////////////////////
	struct хостзап //hostent
	{
		ткст0 имя;
		ткст0* алиасы;
        version(Win32)
        {
                крат типадр;
                крат длина;
        }
        else version(BsdSockets)
        {
                цел типадр;
                цел длина;
        }
		ткст0* списадр;		
		
		ткст0 адр()
		{
			return списадр[0];
		}
	  }
////////////////////////
	
	struct адрессок //sockaddr
	{
	крат семейство;
	ббайт[14] данные;
	}
///////////////////////
	struct адрессок_ин //sockaddr_in
	{
	крат семейство =cast(крат) ПСемействоАдресов.ИНЕТ;
	крат порт;
	адрес_ин адр;
	ббайт[8] иас_ноль;
	}
////////////////////////////
	
	struct адрессок_ин6 //sockaddr_in6
	{
		крат семейство = cast(крат) ПСемействоАдресов.ИНЕТ6;
		крат порт;
		бцел инфПоток;
		адрес_ин6 адр;
		бцел скопид;
	}
////////////////////////////
	union адрес_ин //in_addr
	{
		private union _С_ун_т
		{
			private struct _С_ун_б_т
			{
				ббайт с_б1, с_б2, с_б3, с_б4;
			}
			_С_ун_в_т С_ун_б;
			
			private struct _С_ун_в_т
			{
				бкрат с_в1, с_в2;
			}
			_С_ун_в_т С_ун_в;
			
			бцел С_адр;
		}
		_С_ун_т S_ун;
		
		бцел с_адр;
		
		struct
		{
			ббайт с_сеть, с_хост;
			
			union
			{
				бкрат с_имп;
				
				struct
				{
					ббайт с_лх, с_импнет;
				}
			}
		}
	}
/////////////////////////////

	union адрес_ин6 //in6_addr
	{
		private union _ин6_у_т
		{
			ббайт[16] у6_адр8;
			бкрат[8] у6_адр16;
			бцел[4] у6_адр32;
		}
		_ин6_у_т ин6_у;
		ббайт[16] с6_адр8;
		
		бкрат[8] с6_адр16;
		бцел[4] с6_адр32;
		
		alias с6_адр8 с6_адр;
	}
//////////////////////////

	struct значврем //timeval
	{
	цел сек;//-унды;
	цел микросек;//-унды;
	alias сек секунды;
	alias микросек микросекунды;
	}
////////////////////////////

	struct набор_уд //fd_set
	{
		бцел счёт_уд;
		СОКЕТ[РАЗМНАБ_УД] массив_уд;
	}
	alias набор_уд уднаб;
//////////////////////////////
	
	union заминка //linger
	{
	struct{
		бкрат вкл;
		бкрат время;
		}
	бкрат[2] массив; 
	}
/////////////////////////////
	struct адринфо //addrinfo
	{
		цел флаги; 
		цел семейство;
		цел типсок;
		цел протокол;
		т_мера длинадр;
		ткст0 канонимя;
		адрессок* адр;
		адринфо* следщ;
	}
/////////////////////////////////////

	struct КВАДКЗС //RGBQUAD
	 {
			ббайт    кзсСиний;
			ббайт    кзсЗелёный;
			ббайт    кзсКрасный;
			ббайт    кзсРезерв;
	}
//////////////////////////////////////////////////
	struct ИНФОБИТМАПЗАГ //BITMAPINFOHEADER
	{
			бцел      размер;
			цел       ширина;
			цел       высота;
			бкрат       плоскости;
			бкрат       счётБит;
			бцел      сжатие;
			бцел      размОбр;
			цел       горизПиксНаМетр;
			цел       вертПиксНаМетр;
			бцел      использУпр;
			бцел      важнЦвета;//biClrImportant;
	}
////////////////////////////////////////////

	struct ИНФОБИТМАП //BITMAPINFO
	 {
		ИНФОБИТМАПЗАГ    заголовок;//bmiHeader;
		КВАДКЗС             цвета[1];
	}
//////////////////////////////////////////////////////////
	struct ЗАПИСЬ_ПАЛИТРЫ //PALETTEENTRY
	 {
		ббайт        крас;
		ббайт        зел;
		ббайт        син;
		ббайт        флаги;
	}
	alias ЗАПИСЬ_ПАЛИТРЫ ПАЛИТЗАП;
////////////////////////////////////////////////////
	struct ЛОГ_ПАЛИТРЫ //LOGPALETTE
	 {
		бкрат        версия;
		бкрат        члоЗап;
		ПАЛИТЗАП        палЗап[1];
	}
	alias ЛОГ_ПАЛИТРЫ ПАЛИТЛОГ;
/////////////////////////////////////////////
	/* Pixel format descriptor */

	struct ДЕСКРФОРМАТАПИКСЕЛЯ //PIXELFORMATDESCRIPTOR
	{
		бкрат  размер;
		бкрат  версия;
		бцел   флаги;
		ббайт  типПикселя;
		ббайт  битыЦвета;
		ббайт  кБиты;//к - красный
		ббайт  кСдвиг;
		ббайт  зБиты;//з -зелёный
		ббайт  зСдвиг;
		ббайт  сБиты;//с - синий
		ббайт  сСдвиг;
		ббайт  аБиты;//а - альфа (прозрачность)
		ббайт  аСдвиг;
		ббайт  аккумБиты;
		ббайт  аккумКБиты;
		ббайт  аккумЗБиты;
		ббайт  аккумСБиты;
		ббайт  аккумАБиты;
		ббайт  битыДали; //даль = depth = "глубина" пикселей на экране
		ббайт  битыШаблона;//шаблон = stencil
		ббайт  допБуферы;
		ббайт  типСлоя;
		ббайт  резерв;
		бцел   маскаСлоя;
		бцел   маскаВидимого;
		бцел   маскаПовреждения;
	}
///////////////////////////////////////////////

	struct КЛАССОКДОП_А //WNDCLASSEXA
	 {
		бцел     размер;
		/* Win 3.x */
		бцел    стиль;
		ОКОНПРОЦ  оконПроц;
		цел     упрэлтыЭкстра;
		цел     окнаЭкстра;
		экз  	экземпляр;
		ук      пиктограмма;
		ук    	курсор;
		ук      фон;
		ткст0   имяМеню;
		ткст0   имяКласса;
		/* Win 4.0 */
		ук      пиктограммаМал;
	}
	alias КЛАССОКДОП_А КЛАССОКДОП;
//////////////////////////////////////////
	struct КЛАССОК_А //WNDCLASSA
	 {
		бцел        стиль;
		ОКОНПРОЦ    оконПроц;
		цел         упрэлтыЭкстра;
		цел         окЭкстра;
		экз  		экземпляр;
		ук      	пиктограмма;
		ук    		курсор;
		ук      	фон;
		ткст0       имяМеню;
		ткст0       имяКласса;
	}
	alias КЛАССОК_А КЛАССОК;
////////////////////////////////////////////
	struct СООБ //MSG
	{
		ук      окноПолучатель;
		бцел    сообщение;
		бцел    вПарам;
		цел     лПарам;
		бцел    время;
		ТОЧКА   тчк;
	}
/////////////////////////////////////////////////
	struct МЕТРИКА_ТЕКСТА //TEXTMETRICA
	{
		цел        высота;
		цел        подъём;
		цел        спуск;
		цел        внутрВступ;
		цел        внешнийВступ;
		цел        среднШирСим;
		цел        максШирСим;
		цел        вес;
		цел        перевес;
		цел        оцифрАспектШ;
		цел        оцифрАспектВ;
		ббайт        первСим;
		ббайт        последнСим;
		ббайт        дефолтнСим;
		ббайт        брейкСим;
		ббайт        курсив;
		ббайт        подчерк;
		ббайт        струкАут;
		ббайт        питчИСемейство;
		ббайт        гарнитура;
	}
	alias МЕТРИКА_ТЕКСТА ТЕКСТМЕТР;
////////////////////////////////////////////////////////
	struct ОТКРФАЙЛ_А
	 {
	   бцел        размерСтрукт;
	   ук         окХозяин;
	   экз    		экземпляр;
	   ткст0       фильтр;
	   ткст0        фильтрАдапт;
	   бцел        максЧлоАдаптФильтров;
	   бцел        индексФильтра;
	   ткст0        файл;
	   бцел        максЧлоФайлов;
	   ткст0        титулФ;
	   бцел        максЧлоФТитулов;
	   ткст0       исхПапка;
	   ткст0       титул;
	   бцел        Флаги;
	   бкрат         фСмещен;
	   бкрат         члоФРасш;
	   ткст0       дефРасш;
	   цел       допДанные;
	   ОТКРФЛХУКПРОЦ офХук;
	   ткст0       имяШаблона;
	}
//////////////////////////////////////////////////
	struct ОТКРФАЙЛ //FILEOPEN
	 {
	   бцел        размерСтрукт;
	   ук         окХозяин;
	   экз    экземпляр;
	   шим*      фильтр;
	   шим*       фильтрАдапт;
	   бцел        максЧлоАдаптФильтров;
	   бцел        индексФильтра;
	   шим*       файл;
	   бцел        максЧлоФайлов;
	   шим*       титулФ;
	   бцел        максЧлоФТитулов;
	   шим*      исхПапка;
	   шим*      титул;
	   бцел        Флаги;
	   бкрат         фСмещен;
	   бкрат         члоФРасш;
	   шим*      дефРасш;
	   цел       допДанные;
	   ОТКРФЛХУКПРОЦ офХук;
	   шим*      имяШаблона;
	}
////////////////////////////////////////
/* Bitmap Header Definition */

	struct БИТМАП //BITMAP
	{
		цел        тип;
		цел        ширина;
		цел        высота;
		цел        байтыШирины;
		бкрат      плоскости;
		бкрат      пиксельБит;
		ук         биты;
	}
///////////////////////////////////////////////////////
	struct ЛОГ_ШРИФТА //LOGFONTA
	{
		цел      высота;
		цел      ширина;
		цел      lfEscapement;
		цел      ориентация;
		цел      вес;
		ббайт      курсив;
		ббайт      подчерк;
		ббайт      перечерк;
		ббайт      гарнитура;
		ббайт      выхТочность;
		ббайт      обрезТочность;
		ббайт      качество;
		ббайт      питчИСемейство;
		сим      имяКегля[32 ];
	}
	alias ЛОГ_ШРИФТА ШРИФТЛОГ;
////////////////////////////////////////////////////////

	align (2) struct ШАБЛОНДЛГ//DLGTEMPLATE
	 {
		бцел стиль;
		бцел расширеннСтиль;
		бкрат cdit;
		крат x; alias x ш;
		крат y; alias y в;
		крат cx; alias cx дш;
		крат cy; alias cy дв;
	}
////////////////////////////////////////////////////////

	struct ЛОГ_ПЕРА //LOGPEN
	  {
		бцел        Стиль;
		ТОЧКА       Ширина;
		ЦВЕТ       Цвет;
	}
	alias ЛОГ_ПЕРА ПЕРЛОГ;
//////////////////////////////////////////////////

	struct КООРД //COORD
	 {
		крат X; alias X Ш;//Ширина
		крат Y; alias Y В;//Высота
	}
/////////////////////////////////////////////////////

	struct МПРЯМ //SMALL_RECT
	 {
		крат лево;
		крат верх;
		крат право;
		крат низ;
	}
/////////////////////////////////////////////

	struct ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ
	 {
		Бул 	клВнизу;
		бкрат 	счётПовторов;
		бкрат 	кодВиртКл;
		бкрат 	кодВиртСкан;
		union {
			шим симЮникода;
			сим   симАски;
		}
		бцел состКлУпр;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ ЗАПСОБКЛ;
///////////////////////////////////////////////

	struct ЗАПИСЬ_СОБЫТИЯ_МЫШИ 
	{
		КООРД позМыши;
		ПСостКнопкиМыши состКнопки;
		ПСостКлУпр состКлУпр;
		ПТипСобМыши флагиСобытия;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_МЫШИ ЗАПСОБМЫШ;
//////////////////////////////////////////////////////////
	struct ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА
	 {
		КООРД размер;
	 }
	alias ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА ЗАПРАЗМБУФОК;
////////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_МЕНЮ
	 {
		бцел идКоманды;
	 }
	alias ЗАПИСЬ_СОБЫТИЯ_МЕНЮ ЗАПСОБМЕНЮ;
/////////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_ФОКУСА
	 {
		Бул установитьФокус;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_ФОКУСА ЗАПСОБФОК;
//////////////////////////////////////////////////
	struct ЗАПИСЬ_ВВОДА
	 {
		бкрат типСобытия;
		union {
			ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ собКлав;
			ЗАПИСЬ_СОБЫТИЯ_МЫШИ 	собМыши;
			ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА собРазмБуфОк;
			ЗАПИСЬ_СОБЫТИЯ_МЕНЮ собМеню;
			ЗАПИСЬ_СОБЫТИЯ_ФОКУСА собФок;
		}
	}
	alias ЗАПИСЬ_ВВОДА ЗАПВВОДА;
///////////////////////////////////

	struct ИНФОСИМ//CHAR_INFO
	 {
		union
		{
			шим симЮникода;
			сим   симАски;
		}
		ПАтрыИнфосим атрибуты;
	}
/////////////////////////////
	struct ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ //CONSOLE_SCREEN_BUFFER_INFO
	{
		КООРД размер;
		КООРД позКурсора;
		бкрат  атрибуты;
		МПРЯМ окно;
		КООРД максРазмОкна;
	}
	alias ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ ИНФОКОНСЭКРБУФ;
////////////////////////////////////////////////////////////////

	struct ИНФ_О_КУРСОРЕ_КОНСОЛИ //CONSOLE_CURSOR_INFO
	{
		бцел  размер;
		Бул   видимый;
	}
	alias ИНФ_О_КУРСОРЕ_КОНСОЛИ ИНФОКОНСКУРСОР;
////////////////////////////////////////////////////

	struct ВИНСОКДАН //WSADATA
	{
		бкрат версия;
		бкрат хВерсия;
		сим описание[cast(цел) ДЛИНА_ВСАОПИСАНИЯ + 1];
		сим сисСтатус[cast(цел) ДЛИНА_ВСАСИС_СТАТУСА + 1];
		бкрат максЧлоСок;
		бкрат максДгПпд;//iMaxUdpDg;
		ткст0 инфОПроизв;//lpVendorInfo;
	}
////////////////////////////////////////////////////	
struct ВИНСОКБУФ //WSABUF
{
        бцел    длина;
        ук   буф;
}

/////////////////////////////////////////////////////
	struct ВавЗаг
	{
		сим рифф[4] = "RIFF";
		бцел размер;
		сим фмт[4] = "WAVE";
		
		сим идЦилиндраФмт[4]= "fmt ";
		бцел размерЦилиндраФмт;
		бкрат аудиоФормат;
		бкрат члоКаналов;
		бцел семплРейт;
		бцел байтРейт;
		бкрат раскладкаБлока;
		бкрат битНаСемпл;
		
		сим идЦилиндраДанных[4]= "data";
		бцел размерЦилиндраДанных;
		// data follows
	}
////////////////////////////////////////////////
	struct ИНФОСТАРТА //STARTUPINFO
	{
	 бцел размер;//этой стр-ры
	 шим *резерв;//пусто
	 шим *рабСтол;//название процесса на раб.ст.
	 шим *титул;//если пусто, то отображается просто имя программы
	 бцел ш;//смещение по ширине от левого верхнего угла
	 бцел в;//то же по высоте
	 бцел шразм;//ширина окна
	 бцел вразм;//высота окна
	 бцел школвосим;//ширина экранного буфера
	 бцел вколвосим;//высота экранного буфера
	 бцел запатр;//начальные цвета текста и фона
	 бцел флаги; //Перечень флагов
	 бкрат показОкна;
	 бкрат резерв2;
	 ббайт *резерв2Ук;
	 ук стдвво;
	 ук стдвыв;
	 ук стдош;
	}
///////////////////////////////////////////////////////

	struct ИНФОПРОЦ //PROCESS_INFO
	{
	 ук процесс;
	 ук нить;
	 бцел идПроцесса;
	 бцел идНити;
	}
/////////////////////////////////////////////////////////

	struct ГРАНБЕЗОПМАСА 
	{
	  бцел члоЭлтов;
	  цел нижГран;
	}

	struct КОСЕРВЕРИНФО //COSERVERINFO
	 {
	  бцел резерв1;
		  шим* имяОбъ;  
	  КОАУТИНФО* аутИнф;
	  бцел резерв2;
	}

	struct КОАУТИДЕНТИЧНОСТЬ //COAUTHIDENTITY
	{
	  шим* Пользователь;
	  бцел ПользовательДлина;
	  шим* Домен;
	  бцел ДоменДлина;
	  шим* Пароль;
	  бцел ПарольДлина;
	  бцел Флаги;
	}

	struct КОАУТИНФО //COAUTHINFO
	{
	  бцел службаАутн;
	  бцел службаАутз;
	  шим* имяПринкСервера;
	  бцел уровеньАутн;
	  бцел уровеньИмперсонации;
	  КОАУТИДЕНТИЧНОСТЬ* данныеАутИдент;
	  бцел способности;
	}

	struct ОТКРПМБ //STATSTG
	 {
	  шим* укНаШ0Имя;
	  бцел тип;
	  бдол бРазм;
	  ФВРЕМЯ ивремя;
	  ФВРЕМЯ свремя;
	  ФВРЕМЯ двремя;
	  бцел послРежДост;
	  бцел поддержТипыБлокРгна;
	  ГУИД клсид;
	  бцел битыТекСостХр;
	  бцел резерв;
	}

	struct ОПЦИИХР //STGOPTIONS
	 {
	  бкрат испВерсия;
	  бкрат резерв;
	  бцел бдРазмСектора;
	  шим* укНаШ0ФайлШаблона;
	}

	struct СВЯЗОПЦИИ //
	 {
	  бцел бСтрукт = СВЯЗОПЦИИ.sizeof;
	  бцел мсоФлаги;
	  бцел послРежДост;
	  бцел бцПредельнСрокТик;
	}

	struct СВЯЗОПЦИИ2 
	{
	  бцел бСтрукт = СВЯЗОПЦИИ2.sizeof;
	  бцел мсоФлаги;
	  бцел послРежДост;
	  бцел бцПредельнСрокТик;
	  бцел бцТрэкФлаги;
	  бцел бцКонтекстКласса;
	  бцел локаль;
	  КОСЕРВЕРИНФО* укНаСерверИнфо;
	}

	struct МУЛЬТИ_ОИ //MULTI_QI
	 {
	  ГУИД* укНаИИд;  
	  Инкогнито укНаИз;
	  цел хрез;
	}

	struct ЦУСТРОЙСТВО //DVTARGETDEVICE
	 {
	  бцел цуРазм;
	  бкрат цуСмещКИмениДрайвера;
	  бкрат цуСмещКИмениУстрва;
	  бкрат цуСмещКИмениПорта;
	  бкрат цуСмещКДопУстрреж;
	  ббайт* цуДанные;
	}

	struct ФОРМАТИТД //FORMATETC
	 {
	  бкрат формат;
	  ЦУСТРОЙСТВО* укнад;
	  бцел аспект;
	  цел индекс;
	  бцел тимед;
	}

	struct НОСИТЕЛЬПАМ //STGMEDIUM
	{
	  бцел тимед;
	  union {
		ук битмап;
		ук метаФайлПикт;
		ук усМетаФайл;
		ук глоб;
		шим* имяф;
		ИПоток птк;
		ИХранилище хран;
	  }
	  Инкогнито инкДляВысвобожд;
	}

	struct ОЛЕВЕРБ //OLEVERB
	 {
	  цел верб;
	  шим* имяВерба;
	  бцел флаги;
	  бцел грфАтры;
	}

	struct СТАТДАННЫЕ //STATDATA
	{
	  ФОРМАТИТД форматетц;
	  бцел адвф;
	  IAdviseSink адвСинк;
	  бцел соединение;
	}

	struct ДИСППАРАМЫ //DISPPARAMS
	 {
	  ВАРИАНТ* ргварг;
	  цел* ргдиспидИменованыеАрги;
	  бцел арги;
	  бцел именованыеАрги;
	}

	struct ИСКЛИНФО //EXCEPINFO
	 {
	  бкрат код;
	  бкрат резерв1;
	  шим* исток;
	  шим* описание;
	  шим* файлСправки;
	  бцел контекстСправки;
	  ук   резерв2;
	  цел function(ИСКЛИНФО*) измененЗаполнение;
	  цел скод;
	}

	struct ТИПДЕСКР //TYPEDESC
	 {
	  union {
		ТИПДЕСКР* деск;
		МАССДЕСКР* адеск;
		бцел ссылтип;
	  }
	  бкрат вт;
	}

	struct МАССДЕСКР//ARRAYDESC
	 {
	  ТИПДЕСКР элемДеск;
	  бкрат меры;
	  ГРАНБЕЗОПМАСА[1] ргграни;
	}

	struct ПАРАМДЕСКРДОП //PARAMDESCEX
	{
	  бцел байты;
	  ВАРИАНТ дефЗнач;
	}

	struct ПАРАМДЕСКР //PARAMDESC
	 {
	  ПАРАМДЕСКРДОП* ппарамдесцекс;
	  бкрат флагиПарам;
	}

	struct ИДЛДЕСКР //IDLDESC
	 {
	  бцел резерв;
	  бкрат флпгиИДЛ;
	}

	struct ЭЛЕМДЕСКР //ELEMDESC
	{
	  ТИПДЕСКР дескт;
	  union {
		ИДЛДЕСКР дескИДЛ;
		ПАРАМДЕСКР дескпарам;
	  }
	}

	struct ТИПАТР//TYPEATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  бцел резерв;
	  цел конструкторПамИД;
	  цел деструкторПамИД;
	  шим* схема;
	  бцел размерЭкземпляра;
	  ПВидТипа типвид;
	  бкрат функи;
	  бкрат пермы;
	  бкрат имплТипы;
	  бкрат размерВфт;
	  бкрат раскладка;
	  бкрат флагиТипов;
	  бкрат номСтаршВерс;
	  бкрат номМладшВерс;
	  ТИПДЕСКР алиасДеск;
	  ИДЛДЕСКР типДескИДЛ;
	}

	struct ФУНКЦДЕСКР//FUNCDESC
	{
	  цел идпам;
	  цел* ргскод;
	  ЭЛЕМДЕСКР* парамРгэлемдеск;
	  ПВидФунк видфунк;
	  ПВидВызова типвыз;
	  ПКонвВызова конввыз;
	  крат парамы;
	  крат опцПарамов;
	  крат ВфтО;
	  крат скоды;
	  ЭЛЕМДЕСКР функЭлемдеск;
	  бкрат флагиФунк;
	}

	struct ПЕРЕМДЕСКР //VARDESC
	{
	  цел идпам;
	  шим* схема;
	  union {
		бцел экзО;
		ВАРИАНТ* значПерем;
	  }
	  ЭЛЕМДЕСКР перемДескЭлем;
	  бкрат флагиПерем;
	  ПВидПерем типперем;
	}

	struct УКПРИВЯЗ//BINDPTR
	 {
	  ФУНКЦДЕСКР* функдескр;
	  ПЕРЕМДЕСКР* вардескр;
	  ITypeComp ткомп;
	}

	struct ОСОБЭЛДАН//CUSTDATAITEM 
	{
	  ГУИД гуид;
	  ВАРИАНТ значВар;
	}

	struct ОСОБДАН //CUSTDATA
	 {
	  бцел особДанные;
	  ОСОБЭЛДАН* осДан;
	}

	struct ИНФ_О_КАТЕГОРИИ//CATEGORYINFO
	 {
	  ГУИД идКат;
	  бцел лкид;
	  шим[128] описание;
	}
	alias ИНФ_О_КАТЕГОРИИ ИНФОКАТ;

	struct АТРТБИБ //TLIBATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  ПВидСистемы видсис;
	  бкрат старшНомВер;
	  бкрат младНомВер;
	  бкрат флагиБиб;
	}

	struct РИСДЕСКР//PICTDESC
	 {
	  бцел размер = РИСДЕСКР.sizeof;
	  бцел типРис;
	  ук укз;
	}

	struct СОЕДДАН //CONNECTDATA
	 {
	  Инкогнито инк;
	  бцел куки;
	}

	struct ИНФОЛИЦ //LICINFO
	 {
	  цел инфолиц = ИНФОЛИЦ.sizeof;
	  цел доступнРантаймКлюч;
	  цел лицВерифицирована;
	}

	struct МЕТРИКА_ОЛЕ_ТЕКСТА //TEXTMETRICOLE
	 {
	  цел высота;
	  цел подъём;
	  цел спуск;
	  цел внутреннийВвод;
	  цел внешнийВвод;
	  цел средШирСим;
	  цел максШирСим;
	  цел вес;
	  цел свис;
	  цел оцифрАспектШ;
	  цел оцифрАспектВ;
	  шим первСим;
	  шим последнСим;
	  шим дефСим;
	  шим брейкСим;
	  ббайт курсив;
	  ббайт подчерк;
	  ббайт tmStruckOut;
	  ббайт tmPitchAndFamily;
	  ббайт гарнитура;
	}
	alias МЕТРИКА_ОЛЕ_ТЕКСТА ОЛЕТЕКСТМЕТР;

	struct ЗАПИСЬ_КУЧИ_ПРОЦЕССА //PROCESS_HEAPENTRY
	{
	 ук данук;
	 бцел данные;
	 ббайт излишек;
	 ббайт индексРегиона;
	 бкрат флаги;
	 union 
	 { 
		 struct Блок
		 {
		 ук пам;
		 бцел резерв[3];
		 }
		 
		 struct Регион
		 {
		 бцел переданныйРазм;
		 бцел непереданныйРазм;
		 ук первБлок;
		 ук последнБлок;
		 } 
	 }
	}
	alias ЗАПИСЬ_КУЧИ_ПРОЦЕССА ЗАППРОЦКУЧ;
	
	
	union БОЛЬШЕЦЕЛ //БОЛЬШЕЦЕЛ
	 {
		struct {
			бцел младшЧасть;
			цел старшЧасть;
		}
		дол квадрЧасть;
	}
alias БОЛЬШЕЦЕЛ ЛУИД;

	union ББОЛЬШЕЦЕЛ //UБОЛЬШЕЦЕЛ
	 {
		struct {
			бцел младшЧасть;
			бцел старшЧасть;
		}
		бдол квадрЧасть;
	}
	
	align(4) struct ЛУИД_И_АТРЫ//LUID_AND_ATTRIBUTES
	{
	ЛУИД луид;
	бцел атры;
	}
	
	struct УСТПРИВ//PRIVILEGE_SET 
	{
	бцел члоПрив;
	бцел упр;
	ЛУИД_И_АТРЫ _Привилегия;

	ЛУИД_И_АТРЫ* Привилегия() { return &_Привилегия; }
	}

	struct КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ//SECURITY_QUALITY_OF_SERVICE 
	{
	бцел длина;
	ПУровеньИмперсонацииБезопасности   уровеньИмп;
	РЕЖИМ_ОТСЛЕЖИВАНИЯ_КОНТЕКСТА_БЕЗОПАСНОСТИ режимОтслежКонтекста;
	бул толькоДейств;
	}
	alias КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ КАЧБЕЗОПСЛУЖБ;
	
	struct БЕЗОПИМПЕРССОСТ//SE_IMPERSONATION_STATE
	{
	УкТОКЕН_ДОСТУПА 				 токен;
	бул 							 копироватьПриОткр;
	бул								 толькоДейств;
	ПУровеньИмперсонацииБезопасности уровень;
	}
	
	struct БИДИДЕНТАВТОРИТ//SID_IDENTIFIER_AUTHORITY
	{
	ббайт[6] знач;
	}
	
	struct БИД//SID
	{
	ббайт			ревизия;
	ббайт 			члоСубАвторитов;
	БИДИДЕНТАВТОРИТ идентАвторит;
	бцел 			_ПодАвторит;

	бцел* ПодАвторит() { return &_ПодАвторит; }
	}
	
	struct БИД_И_АТРЫ//SID_AND_ATTRIBUTES
	{
	УкБИД бид;
	бцел атры;
	}
	
	struct ИСТОК_ТОКЕНА 
	{
	сим[ДЛИНА_ИСТОКА_ТОКЕНА] имяИстока;
	ЛУИД идИстока;
	}
	alias ИСТОК_ТОКЕНА ТОКИСТ;
	
	struct ТОКЕНУПР//TOKEN_CONTROL 
	{
	ЛУИД         идТокена;
	ЛУИД         идАутентик;
	ЛУИД         идИзмененный;
	ТОКИСТ		 токИст;
	}
	
	struct ДЕФОЛТ_ДСКД_ТОКЕН//TOKEN_DEFAULT_DACL 
	{
	СКД* дефолтДскд;
	}
	alias ДЕФОЛТ_ДСКД_ТОКЕН ДЕФДСКДТОК;
	
	struct ГРУППЫ_ТОКЕНОВ//TOKEN_GROUPS
	{
	бцел 		члоГрупп;
	БИД_И_АТРЫ	 _Группы;

	БИД_И_АТРЫ* Группы() { return &_Группы; }
	}
	alias ГРУППЫ_ТОКЕНОВ ТОКЕНГРУП;
	
	struct ВЛАДЕЛЕЦ_ТОКЕНА //TOKEN_OWNER 
	{
	УкБИД владелец;
	}
	
	struct ПЕРВИЧН_ГРУППА_ТОКЕНОВ//TOKEN_PRIMARY_GROUP 
	{
	УкБИД первичнГруппа;
	}
	
	struct ПРИВИЛЕГИИ_ТОКЕНОВ//TOKEN_PRIVILEGES
	{
	бцел 		члоПривилегий;
	ЛУИД_И_АТРЫ _Привилегии;

	ЛУИД_И_АТРЫ* Привилегии() { return &_Привилегии; }
	}
	
	struct ТОКЕНСТАТ //TOKEN_STATISTICS
	{
	ЛУИД         					 идТокена;
	ЛУИД         					 идАутентификации;
	БОЛЬШЕЦЕЛ 						 времяУстаревания;
	ПТипТокена  					 типТокена;
	ПУровеньИмперсонацииБезопасности уровеньИмп;
	бцел        					 динамичПрисв;
	бцел       						 динамичДоступ;
	бцел      						 члоГрупп;
	бцел     						 члоПривилегий;
	ЛУИД      						 идИзменённый;
	}
	
	struct ПОЛЬЗОВАТЕЛЬ_ТОКЕНА//TOKEN_USER 
	{
	БИД_И_АТРЫ пользователь;
	}
	
struct ПРЕДЕЛЫ_КВОТ//QUOTA_LIMITS 
{
	т_мера пределПулаСтр;
	т_мера пределПулаБезСтр;
	т_мера минРазмРабНабора;
	т_мера максРазмРабНабора;
	т_мера пределПейджфайла;
	БОЛЬШЕЦЕЛ пределВремени;
}

///////////////////////////////////
align(4):
struct ФАЙЛЗАГ_ОБРАЗА//IMAGE_FILE_HEADER
 {
    бкрат    Машина;
    бкрат    ЧлоСекций;
    бцел      ШтампВремени;
    бцел      УкНаСимТаб;
    бцел      ЧлоСим;
    бкрат    РазмОпцЗаг;
    бкрат    Характеристики;
}
alias ФАЙЛЗАГ_ОБРАЗА ФЗАГОБР;
////////////////////////////////////

struct ПАПКА_ДАННЫХ_ОБРАЗА //IMAGE_DATA_DIRECTORY
 {
	бцел ВиртАдрес;
	бцел Размер;
}
alias ПАПКА_ДАННЫХ_ОБРАЗА ПАПДАНОБР;
/////////////////////////////////////////////////////

struct ОПЦЗАГ_ОБРАЗА //IMAGE_OPTIONAL_HEADER32
 {
    //
    // Стандартные поля.
    //
    бкрат  Маг;
    ббайт  СтаршВерсКомпоновщика;
    ббайт   МладшВерсКомпоновщика;
    бцел   РазмерКода;
    бцел   РазмерИнициализДанных;
    бцел   РазмерНеинициализДанных;
    бцел   АдресТочкиВхода;
    бцел   ОваКода;
    бцел   ОваДанных;
    //
    // дополнительные поля НТ.
    //
    бцел   ОваОбраза;
    бцел   РаскладСекц;
    бцел   РаскладФайла;
    бкрат  СтаршВерсОС;
    бкрат  МладшВерсОС;
    бкрат  СтаршВерсОбр;
    бкрат  МладшВерсОбр;
    бкрат  СтаршВерсПодсист;
    бкрат  МладшВерсПодсист;
    бцел   ЗначВерсВин32;
    бцел   РазмерОбраза;
    бцел   РазмерЗагов;
    бцел   КСумма;
    бкрат  Подсистема;
    бкрат  ХарактеристикиДЛЛ;
    бцел   РазмерСтэкРезерва;
    бцел   РазмерСтэкКоммит;
    бцел   РазмерРезерваКучи;
    бцел   РазмерКоммитКучи;
    бцел   ФлагиЗагрузчика;
    бцел   ЧлоОВАиРазмеры;

    ПАПДАНОБР ПапкаДанных[16];
}
alias ОПЦЗАГ_ОБРАЗА ОПЦЗАГОБР;
////////////////////////////////////////////////

struct ОПЦЗАГ_ОБРАЗА_РОМ //IMAGE_ROM_OPTIONAL_HEADER
{
	бкрат     Маг;
	ббайт     СтаршВерсКомпоновщика;
	ббайт     МладшВерсКомпоновщика;
	бцел    РазмерКода;
	бцел    РазмерИнициализДанных;
	бцел    РазмерНеинициализДанных;
	бцел    АдресТочкиВхода;
	бцел    ОваКода;
	бцел    ОваДанных;
	бцел    ОваБсс;
	бцел    МаскаГпр;
	бцел[4] МаскаЦпр;
	бцел    ЗначениеГп;
}
alias ОПЦЗАГ_ОБРАЗА_РОМ ОПЦЗАГОБРРОМ;
///////////////////////////////////////////////////////////////////
align(2):
struct ЗАГОЛОВОК_ОБРАЗА_ДОС //IMAGE_DOS_HEADER
 {
	бкрат     маг;
	бкрат     члобайтпослстр;//число байтов последней страницы
	бкрат     члопар; //число страниц в файле
	бкрат     релок;//релокации
	бкрат     члопарвзаг;//число параграфов в заголовке
	бкрат     минтребдоппараг;//минимальное необходимое число дополнительных параграфов
	бкрат     макстребдоппараг;//максимальное число необходимых доп. параграфов
	бкрат     сс;//Начальное (относительное) значение SS
	бкрат     сп;//Начальное значение SP
	бкрат     кс;//контрольная сумма
	бкрат     ип;//Начальное значение IP
	бкрат     цс;//Начальное значение CS
	бкрат     фадртабрелок;//Файловый адрес таблицы релокаций
	бкрат     номовер;//Номер оверлея
	бкрат[4]  резерв;//Резервированные слова
	бкрат     оемид;//Идентификатор OEM
	бкрат     оеминфо;//Информация OEM
	бкрат[10]  резерв2;//Резервированные слова
	LONG      фадрновэкезаг;//Файловый адрес нового заголовка экзэ
}

alias ЗАГОЛОВОК_ОБРАЗА_ДОС ЗАГОБРДОС;
////////////////////////////////////////

struct ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА //IMAGE_SECTION_HEADER
 {
	ббайт[8] Имя;//ПРазмОбраза.РазмКратИмени
	union _Разное {
		бцел ФизичАдрес;
		бцел ВиртРазмер;
	}
	_Разное Разное;
	бцел ВиртАдрес;
	бцел РазмерНеобрДанных;
	бцел УкНаНеобрДанные;
	бцел УкНаРелокации;
	бцел УкНаНомераСтрок;
	бкрат  ЧлоРелокаций;
	бкрат  ЧлоНОмеровСтрок;
	бцел Характеристики;
}
alias ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА ЗАГСЕКЦОБР;

////////////////////////////////////////////

struct ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА //IMAGE_SEPARATE_DEBUG_HEADER
 {
    бкрат        Сигнатура;
    бкрат        Флаги;
    бкрат        Машина;
    бкрат        Characteristics;
    бцел       ШтампВремени;
    бцел       КСумма;
    бцел       ОваОбраза;
    бцел       РазмерОбраза;
    бцел       ЧлоСекций;
    бцел       РазмЭкпортИмён;
    бцел       РазмПапкиОтлад;
    бцел       РаскладСекц;
    бцел       Резерв[2];
}
alias ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА ОТДЕЛЬНОТЛАДЗАГОБР;
///////////////////////////////////////

struct ЗАГОЛОВКИ_ОБРАЗА_НТ //IMAGE_NT_HEADERS
 {
    бцел Сигнатура;
    ФЗАГОБР ФайлЗаг;
    ОПЦЗАГОБР ОпцЗаг;
}
alias ЗАГОЛОВКИ_ОБРАЗА_НТ НТОБРЗАГИ;
////////////////////////////////////////

struct ИНФ_О_СИМВОЛЕ
	{
        бцел РазмерСтруктуры;
        бцел ИндексТипа;
        бдол Резерв[2];
        бцел Индекс;
        бцел Размер;
        бдол ОваМод;
        бцел Флаги;
        бдол Значение;
        бдол Адрес;
        бцел Регистр;
        бцел Масштаб;
        бцел Тэг;
        бцел ДлинаИм;
        бцел МаксДлинаИм;
        сим Имя[1];
    }
	
//////////////////////////
struct СКУ //DCB
{
	бцел СКУразм = СКУ.sizeof;
	бцел бодрейт;
/+
	бцел fBinary:1;              // Binary Mode (skip EOF check)
	бцел fParity:1;              // Enable parity checking
	бцел fOutxCtsFlow:1;         // CTS handshaking on output
	бцел fOutxDsrFlow:1;         // DSR handshaking on output
	бцел fDtrControl:2;          // DTR Flow control
	бцел fDsrSensitivity:1;      // DSR Sensitivity
	бцел fTXContinueOnXoff:1;    // Continue TX when Xoff sent
	бцел fOutX:1;                // Enable output X-ON/X-OFF
	бцел fInX:1;                 // Enable input X-ON/X-OFF
	бцел fErrorChar:1;           // Enable Err Replacement
	бцел fNull:1;                // Enable Null stripping
	бцел fRtsControl:2;          // Rts Flow control
	бцел fAbortOnError:1;        // Abort all reads and writes on Error
	бцел fDummy2:17;             // Reserved
	
	typedef struct _DCB {  DWORD DCBlength;  DWORD BaudRate;  DWORD fBinary  :1;  DWORD fParity  :1;  DWORD fOutxCtsFlow  :1;  DWORD fOutxDsrFlow  :1;  DWORD fDtrControl  :2;  DWORD fDsrSensitivity  :1;  DWORD fTXContinueOnXoff  :1;  DWORD fOutX  :1;  DWORD fInX  :1;  DWORD fErrorChar  :1;  DWORD fNull  :1;  DWORD fRtsControl  :2;  DWORD fAbortOnError  :1;  DWORD fDummy2  :17;  WORD wReserved;  WORD XonLim;  WORD XoffLim;  BYTE ByteSize;  BYTE Parity;  BYTE StopBits;  char XonChar;  char XoffChar;  char ErrorChar;  char EofChar;  char EvtChar;  WORD wReserved1;
} DCB;

+/
	бцел _бф;
	бул фБинар(бул ф)           { _бф = (_бф & ~0x0001) | ф; return ф; }
	бул фПаритет(бул ф)           { _бф = (_бф & ~0x0002) | (ф<<1); return ф; }
	бул фСиТиЭс(бул ф)      { _бф = (_бф & ~0x0004) | (ф<<2); return ф; }
	бул фДиЭсАр(бул ф)      { _бф = (_бф & ~0x0008) | (ф<<3); return ф; }
	байт фДиТиАр(байт x)       { _бф = (_бф & ~0x0030) | (x<<4); return cast(байт)(x & 3); }
	бул фЧувствительностьДиЭсАр(бул ф)   { _бф = (_бф & ~0x0040) | (ф<<6); return ф; }
	бул фПродолжитьТиЭксПриЭксвыкл(бул ф) { _бф = (_бф & ~0x0080) | (ф<<7); return ф; }
	бул фВыхЭкс(бул ф)             { _бф = (_бф & ~0x0100) | (ф<<8); return ф; }
	бул фВхЭкс(бул ф)              { _бф = (_бф & ~0x0200) | (ф<<9); return ф; }
	бул фОшСим(бул ф)        { _бф = (_бф & ~0x0400) | (ф<<10); return ф; }
	бул фНулл(бул ф)             { _бф = (_бф & ~0x0800) | (ф<<11); return ф; }
	байт фАрТиЭс(байт x)       { _бф = (_бф & ~0x3000) | (x<<12); return cast(байт)(x & 3); }
	бул фАбортПриОш(бул ф)     { _бф = (_бф & ~0x4000) | (ф<<14); return ф; }

	бул фБинар()           { return cast(бул) (_бф & 1); }
	бул фПаритет()           { return cast(бул) (_бф & 2); }
	бул фСиТиЭс()      { return cast(бул) (_бф & 4); }
	бул фДиЭсАр()      { return cast(бул) (_бф & 8); }
	байт фДиТиАр()       { return cast(байт) ((_бф & (32+16))>>4); }
	бул фЧувствительностьДиЭсАр()   { return cast(бул) (_бф & 64); }
	бул фПродолжитьТиЭксПриЭквыкл() { return cast(бул) (_бф & 128); }
	бул фВыхЭкс()             { return cast(бул) (_бф & 256); }
	бул фВхЭкс()              { return cast(бул) (_бф & 512); }
	бул фОшСим()        { return cast(бул) (_бф & 1024); }
	бул фНулл()             { return cast(бул) (_бф & 2048); }
	байт фАрТиЭс()       { return cast(байт) ((_бф & (4096+8192))>>12); }
	бул фАбортПриОш()     { return cast(бул) (_бф & 16384); }

	бкрат резерв;
	бкрат эксвклЛим;
	бкрат эксвыклЛим;
	ббайт байтРазм;
	ббайт паритет;
	ббайт стопБиты;
	сим эксвклСим;
	сим эксвыклСим;
	сим ошСим;
	сим кфСим;
	сим собСим;
	бкрат резерв1;
}
alias СКУ СЕРИЙНЫЕ_КОММУНИКАЦИОННЫЕ_УСТРОЙСТВА;

struct КОММТАЙМАУТЫ //COMTIMEOUTS
{
	бцел ТаймаутИнтервалаЧтения;
	бцел МультипликаторТаймаутаОбщегоЧтения;
	бцел КонстантаТаймаутаОбщегоЧтения;
	бцел МультипликаторТаймаутаОбщейЗаписи;
	бцел КонстантаТаймаутаОбщейЗаписи;
}

struct КОММСТАТ //COMSTAT
{
/+
	DWORD fCtsHold:1;
	DWORD fDsrHold:1;
	DWORD fRlsdHold:1;
	DWORD fXoffHold:1;
	DWORD fXoffSent:1;
	DWORD fEof:1;
	DWORD fTxim:1;
	DWORD fReserved:25;
+/
	бцел _бф;
    бул фОжиданиеСиТиЭс(бул ф)  { _бф = (_бф & ~1) | ф; return ф; }
	бул фОжиданиеДиЭсАр(бул ф)  { _бф = (_бф & ~2) | (ф<<1); return ф; }
	бул фОжиданиеАрЭлЭсДи(бул ф) { _бф = (_бф & ~4) | (ф<<2); return ф; }
	бул фОжиданиеЭксвыкл(бул ф) { _бф = (_бф & ~8) | (ф<<3); return ф; }
	бул фОтправленЭксвыкл(бул ф) { _бф = (_бф & ~16) | (ф<<4); return ф; }
	бул фКф(бул ф)      { _бф = (_бф & ~32) | (ф<<5); return ф; }
	бул фТиэксим(бул ф)     { _бф = (_бф & ~64) | (ф<<6); return ф; }

    бул фОжиданиеСиТиЭс()  { return cast(бул) (_бф & 1); }
	бул фОжиданиеДиЭсАр()  { return cast(бул) (_бф & 2); }
	бул фОжиданиеАрЭлЭсДи() { return cast(бул) (_бф & 4); }
	бул фОжиданиеЭксвыкл() { return cast(бул) (_бф & 8); }
	бул фОтправленЭксвыкл() { return cast(бул) (_бф & 16); }
	бул фКф()      { return cast(бул) (_бф & 32); }
	бул фТиэксим()     { return cast(бул) (_бф & 64); }

	бцел вхОч;
	бцел выхОч;
}
alias КОММСТАТ СТАТИСТИКА_КОММУНИКАЦИИ;
/////////////////////////////////////////
struct КОММКОНФИГ {
	бцел размер = КОММКОНФИГ.sizeof;
	бкрат  версия;
	бкрат  резерв;
	СКУ   ску;
	бцел подтипПровайдера;
	бцел СмещениеПровайдера;
	бцел размерПровайдера;
	шим _данныеОПровайдере;

	шим* данныеОПровайдере() { return &_данныеОПровайдере; }
}
alias КОММКОНФИГ КОНФИГУРАЦИЯ_КОММУНИКАЦИИ;
//////////////////////////////////////////////
	
	struct АКТКТКСА //ACTCTXA
	{
		бцел размер = this.sizeof;
		бцел флаги;
		ткст0 исток;
		бкрат архПроцессора;
		ИДЯз идЯзыка;
		ткст0 папкаСборки;
		ткст0 имяРесурса;
		ткст0 имяПриложения;
		ук модуль;
	}
	alias АКТКТКСА КОНТЕКСТ_АКТИВАЦИИ_А;
//////////////////////////////////////////////
	
	struct АКТКТКС //ACTCTXW
	{
		бцел размер = this.sizeof;
		бцел флаги;
		ткст0 исток;
		бкрат архПроцессора;
		ИДЯз идЯзыка;
		шткст *папкаСборки;
		шткст *имяРесурса;
		шткст *имяПриложения;
		ук модуль;
	}
	alias АКТКТКС КОНТЕКСТ_АКТИВАЦИИ;