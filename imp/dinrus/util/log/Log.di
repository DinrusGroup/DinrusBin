/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)
      
        version:        May 2004 : Initial release
        version:        Oct 2004: Иерархия moved due в_ circular dependencies
        version:        Apr 2008: Отложенный delegates removed due в_ awkward usage
        author:         Kris


        Loggers are named entities, sometimes shared, sometimes specific в_ 
        a particular portion of код. The names are generally hierarchical in 
        nature, using dot notation (with '.') в_ separate each named section. 
        For example, a typical имя might be something like "mail.шли.писатель"
        ---
        import util.log.Log;форматируй
        
        auto лог = Журнал.отыщи ("mail.шли.писатель");

        лог.инфо  ("an informational сообщение");
        лог.ошибка ("an исключение сообщение: {}", исключение.вТкст);

        etc ...
        ---
        
        It is consопрered good form в_ пароль a logger экземпляр as a function or 
        class-ctor аргумент, or в_ присвой a new logger экземпляр during static 
        class construction. For example: if it were consопрered appropriate в_ 
        have one logger экземпляр per class, each might be constructed like so:
        ---
        private Логгер лог;
        
        static this()
        {
            лог = Журнал.отыщи (nameOfThisClassOrStructOrModule);
        }
        ---

        Messages passed в_ a Логгер are assumed в_ be either сам-contained
        or configured with "{}" notation a la Выкладка & Стдвыв:
        ---
        лог.предупреди ("temperature is {} degrees!", 101);
        ---

        Note that an internal workspace is использован в_ форматируй the сообщение, which
        is limited в_ 2000 байты. Use "{.256}" truncation notation в_ предел
        the размер of indivопрual сообщение components, or use явный formatting:
        ---
        сим[4096] буф =void;

        лог.предупреди (лог.форматируй (буф, "a very дол warning: {}", someLongWarning));
        ---

        To avoопр overhead when constructing аргумент passed в_ formatted 
        messages, you should проверь в_ see whether a logger is активное or not:
        ---
        if (лог.включен (лог.Предупрежд))
            лог.предупреди ("temperature is {} degrees!", complexFunction());
        ---
        
        The above will be handled implicitly by the logging system when 
        macros are добавьed в_ the language (использован в_ be handled implicitly 
        via lazy delegates, but usage of those turned out в_ be awkward).

        лог closely follows Всё the API и the behaviour as documented 
        at the official Журнал4J site, where you'll найди a good tutorial. Those 
        pages are hosted over 
        <A HREF="http://logging.apache.org/log4j/docs/documentation.html">here</A>.

*******************************************************************************/

module util.log.Log;

private import  sys.Common;

private import  time.Clock;

private import  exception;

private import  io.model;

private import  text.convert.Format;

private import  util.log.model.ILogger;

/*******************************************************************************

        Platform issues ...

*******************************************************************************/

version (GNU)
        {
        private import std.stdarg;
        alias ук Арг;
        alias спис_ва АргСписок;
        }
     else
        {
        alias ук Арг;
        alias ук АргСписок;
        }

/*******************************************************************************

        Pull in добавьitional functions из_ the C library

*******************************************************************************/

extern (C)
{
        private цел memcmp (проц *, проц *, цел);
}

version (Win32)
{
        private extern(Windows) цел QueryPerformanceCounter(бдол *счёт);
        private extern(Windows) цел QueryPerformanceFrequency(бдол *frequency);
}

/*******************************************************************************
                        
        These represent the стандарт LOG4J событие levels. Note that
        Debug is called След here, because debug is a reserved word
        in D 

*******************************************************************************/

alias ИЛоггер.Уровень Уровень; 


/*******************************************************************************

        Manager for routing Логгер calls в_ the default иерархия. Note 
        that you may have multИПle hierarchies per application, but must
        доступ the иерархия directly for корень() и отыщи() methods внутри 
        each добавьitional экземпляр.

*******************************************************************************/

public struct Журнал
{
        // support for old API
        public alias отыщи дайЛоггер;

        // internal use only
        private static Иерархия основа;
        private static Время времяНачала;

        version (Win32)
        {
                private static дво множитель;
                private static бдол  стартТаймера;
        }

        private struct  Пара {ткст имя; Уровень значение;}

        private static  Уровень [ткст] карта;
        
        private static  Пара[] Пары = 
                        [
                        {"TRACE",  Уровень.След},
                        {"След",  Уровень.След},
                        {"след",  Уровень.След},
                        {"INFO",   Уровень.Инфо},
                        {"Инфо",   Уровень.Инфо},
                        {"инфо",   Уровень.Инфо},
                        {"WARN",   Уровень.Предупрежд},
                        {"Предупреждение",   Уровень.Предупрежд},
                        {"предупреждение",   Уровень.Предупрежд},
                        {"ERROR",  Уровень.Ошибка},
                        {"Ошибка",  Уровень.Ошибка},
                        {"ошибка",  Уровень.Ошибка},
                        {"Фатал",  Уровень.Фатал},
                        {"FATAL",  Уровень.Фатал},
                        {"фатально",  Уровень.Фатал},
                        {"Неук",   Уровень.Нет},
                        {"Нет",   Уровень.Нет},
                        {"Неук",   Уровень.Нет},
                        ];

        // logging-уровень names
        private static ткст[] ИменаУровней = 
        [
                "След ", "Инфо ", "Предупреждение ", "Ошибка ", "Фатально ", "Нет  "
        ];

        /***********************************************************************
        
                Initialize the основа иерархия           
              
        ***********************************************************************/

        static this ()
        {
                основа = new Иерархия ("DinrusTango.lib");

                foreach (p; Пары)
                         карта[p.имя] = p.значение;

                version (Posix)       
                {
                        времяНачала = Часы.сейчас;
                }

                version (Win32)
                {
                        бдол freq;

                        if (! QueryPerformanceFrequency (&freq))
                              throw new PlatformException ("таймер высокого разрешения недоступен");
                        
                        QueryPerformanceCounter (&стартТаймера);
                        множитель = cast(дво) ИнтервалВремени.ТиковВСек / freq;       
                        времяНачала = Часы.сейчас;
                }
        }

        /***********************************************************************
        
                Return the уровень of a given имя

        ***********************************************************************/

        static Уровень преобразуй (ткст имя, Уровень def=Уровень.След);

        /***********************************************************************
                
                Return the текущ время

        ***********************************************************************/

        static Время время ();
        /***********************************************************************

                Return the корень Логгер экземпляр. This is the ancestor of
                все loggers и, as such, can be использован в_ manИПulate the 
                entire иерархия. For экземпляр, настройка the корень 'уровень' 
                attribute will affect все другой loggers in the дерево.

        ***********************************************************************/

        static Логгер корень ();

        /***********************************************************************
        
                Return an экземпляр of the named logger. Names should be
                hierarchical in nature, using dot notation (with '.') в_ 
                separate each имя section. For example, a typical имя 
                might be something like "io.Stdout".

                If the logger does not currently exist, it is создан и
                inserted преобр_в the иерархия. A предок will be attached в_
                it, which will be either the корень logger or the closest
                ancestor in terms of the hierarchical имя пространство.

        ***********************************************************************/

        static Логгер отыщи (ткст имя);

        /***********************************************************************
        
                Return текст имя for a лог уровень

        ***********************************************************************/

        static ткст преобразуй (цел уровень);

        /***********************************************************************
        
                Return the синглтон иерархия.

        ***********************************************************************/

        static Иерархия иерархия ();

        /***********************************************************************

                Initialize the behaviour of a basic logging иерархия.

                добавьs a ПотокAppender в_ the корень узел, и sets
                the activity уровень в_ be everything включен.
                
        ***********************************************************************/

        static проц конфиг (ИПотокВывода поток, бул слей = да);

        /***********************************************************************
        
                Initialize a снимок for a specific logging уровень, и 
                with an optional буфер. Default буфер размер is 1024

        ***********************************************************************/

        static private Снимок снимок (Логгер хозяин, Уровень уровень, ткст буфер = пусто);
}


/*******************************************************************************

        Снимок support for use with existing лог экземпляры. The behaviour 
        is different из_ traditional logging in that snapshots don't излей any 
        вывод until flushed. They gather up information in a temporary буфер 
        и излей that instead - this can be использован в_ gather up a series of лог 
        snИПpets преобр_в one place. Typical usage is like so:
        ---
        auto snap = Журнал.снимок (лог, Уровень.Инфо);
        ...
        snap.форматируй ("{}; ", "первый");
        ...
        snap.форматируй ("{}; ", "секунда");
        ...
        snap.слей;
        ---
        
        Setting a larger буфер размер than the default:
        ---
        сим[4096] буф =void;
        auto snap = Журнал.снимок (лог, Уровень.Инфо, буф);
        ...
        ---
        
        Note that this is a struct, и is constructed on the стэк

*******************************************************************************/

private struct Снимок
{
        private Логгер          хозяин;
        private цел             следщ;
        private Уровень           уровень;
        private ткст          буфер;
        private сим[1024]      врем =void;

        /***********************************************************************
        
                See if this Снимок is включен via the associated logger. If
                that logger is установи в_ a уровень less verbose than our снимок, 
                we are consопрered disabled.

        ***********************************************************************/

        бул включен ();

        /***********************************************************************
                
                Доб formatted текст в_ the снимок. Nothing is излейted 
                until слей is invoked.

        ***********************************************************************/

        проц форматируй (ткст строкаФмт, ...);

        /***********************************************************************
        
                Must be invoked в_ generate any вывод

        ***********************************************************************/

        проц слей ();
}


/*******************************************************************************

        Loggers are named entities, sometimes shared, sometimes specific в_ 
        a particular portion of код. The names are generally hierarchical in 
        nature, using dot notation (with '.') в_ separate each named section. 
        For example, a typical имя might be something like "mail.шли.писатель"
        ---
        import util.log.Log;форматируй
        
        auto лог = Журнал.отыщи ("mail.шли.писатель");

        лог.инфо  ("an informational сообщение");
        лог.ошибка ("an исключение сообщение: {}", исключение.вТкст);

        etc ...
        ---
        
        It is consопрered good form в_ пароль a logger экземпляр as a function or 
        class-ctor аргумент, or в_ присвой a new logger экземпляр during static 
        class construction. For example: if it were consопрered appropriate в_ 
        have one logger экземпляр per class, each might be constructed like so:
        ---
        private Логгер лог;
        
        static this()
        {
            лог = Журнал.отыщи (nameOfThisClassOrStructOrModule);
        }
        ---

        Messages passed в_ a Логгер are assumed в_ be either сам-contained
        or configured with "{}" notation a la Выкладка & Стдвыв:
        ---
        лог.предупреди ("temperature is {} degrees!", 101);
        ---

        Note that an internal workspace is использован в_ форматируй the сообщение, which
        is limited в_ 2000 байты. Use "{.256}" truncation notation в_ предел
        the размер of indivопрual сообщение components, or use явный formatting:
        ---
        сим[4096] буф =void;

        лог.предупреди (лог.форматируй (буф, "a very дол warning: {}", someLongWarning));
        ---

        To avoопр overhead when constructing аргумент passed в_ formatted 
        messages, you should проверь в_ see whether a logger is активное or not:
        ---
        if (лог.включен (лог.Предупрежд))
            лог.предупреди ("temperature is {} degrees!", complexFunction());
        ---
        
        The above will be handled implicitly by the logging system when 
        macros are добавьed в_ the language (использован в_ be handled implicitly 
        via lazy delegates, but usage of those turned out в_ be awkward).

        лог closely follows Всё the API и the behaviour as documented 
        at the official Журнал4J site, where you'll найди a good tutorial. Those 
        pages are hosted over 
        <A HREF="http://logging.apache.org/log4j/docs/documentation.html">here</A>.

*******************************************************************************/

public class Логгер : ИЛоггер
{     
        
        alias Уровень.След След;        // shortcut в_ Уровень значения 
        alias Уровень.Инфо  Инфо;         // ...
        alias Уровень.Предупрежд  Предупрежд;         // ...
        alias Уровень.Ошибка Ошибка;        // ...
        alias Уровень.Фатал Фатал;        // ...

        alias добавь      opCall;       // shortcut в_ добавь

        /***********************************************************************
                
                Контекст for a иерархия, использован for customizing behaviour
                of лог hierarchies. You can use this в_ implement dynamic
                лог-levels, based upon filtering or some другой mechanism

        ***********************************************************************/

        interface Контекст
        {
                /// return a ярлык for this контекст
                ткст ярлык ();
                
                /// первый арг is the настройка of the logger itself, и
                /// the секунда арг is что kind of сообщение we're being
                /// asked в_ произведи
                бул включен (Уровень настройка, Уровень мишень);
        }

        /***********************************************************************
                
        ***********************************************************************/

        private Логгер          следщ,
                                предок;

        private Иерархия       host_;
        private ткст          name_;
        private Уровень           level_;
        private бул            аддитивный_;
        private Добавщик        appender_;

        /***********************************************************************
        
                Construct a LoggerInstance with the specified имя for the 
                given иерархия. By default, logger экземпляры are аддитивный
                и are установи в_ излей все события.

        ***********************************************************************/

        private this (Иерархия хост, ткст имя);

        /***********************************************************************
        
                No, you should not delete or 'scope' these entities

        ***********************************************************************/

        private ~this();

        /***********************************************************************
        
                Is this logger enabed for the specified Уровень?

        ***********************************************************************/

        final бул включен (Уровень уровень = Уровень.Фатал);

        /***********************************************************************

                Is след включен?

        ***********************************************************************/

        final бул след ();

        /***********************************************************************

                Доб a след сообщение

        ***********************************************************************/

        final проц след (ткст фмт, ...);

        /***********************************************************************

                Доб a след сообщение

        ***********************************************************************/

        private проц след (lazy проц дг);
        /***********************************************************************

                Is инфо включен?

        ***********************************************************************/

        final бул инфо ()
        {
                return включен (Уровень.Инфо);
        }

        /***********************************************************************

                Доб an инфо сообщение

        ***********************************************************************/

        final проц инфо (ткст фмт, ...);

        /***********************************************************************

                Доб an инфо сообщение

        ***********************************************************************/

        private проц инфо (lazy проц дг);

        /***********************************************************************

                Is предупреди включен?

        ***********************************************************************/

        final бул предупреди ();

        /***********************************************************************

                Доб a warning сообщение

        ***********************************************************************/

        final проц предупреди (ткст фмт, ...);

        /***********************************************************************

                Доб a warning сообщение

        ***********************************************************************/

        private проц предупреди (lazy проц дг);

        /***********************************************************************

                Is ошибка включен?

        ***********************************************************************/

        final бул ошибка ();

        /***********************************************************************

                Доб an ошибка сообщение

        ***********************************************************************/

        final проц ошибка (ткст фмт, ...);

        /***********************************************************************

                Доб an ошибка сообщение

        ***********************************************************************/

        private проц ошибка (lazy проц дг);

        /***********************************************************************

                Is фатал включен?

        ***********************************************************************/

        final бул фатал ();

        /***********************************************************************

                Доб a фатал сообщение

        ***********************************************************************/

        final проц фатал (ткст фмт, ...);

        /***********************************************************************

                Доб a фатал сообщение

        ***********************************************************************/

        private проц фатал (lazy проц дг);

        /***********************************************************************

                Return the имя of this Логгер (sans the appended dot).
       
        ***********************************************************************/

        final ткст имя ();

        /***********************************************************************
        
                Return the Уровень this logger is установи в_

        ***********************************************************************/

        final Уровень уровень ();

        /***********************************************************************
        
                Набор the текущ уровень for this logger (и only this logger).

        ***********************************************************************/

        final Логгер уровень (Уровень l);

        /***********************************************************************
        
                Набор the текущ уровень for this logger, и (optionally) все
                of its descendents.

        ***********************************************************************/

        final Логгер уровень (Уровень уровень, бул распространить);

        /***********************************************************************
        
                Is this logger аддитивный? That is, should we walk ancestors
                looking for ещё appenders?

        ***********************************************************************/

        final бул аддитивный ();

        /***********************************************************************
        
                Набор the аддитивный статус of this logger. See бул аддитивный().

        ***********************************************************************/

        final Логгер аддитивный (бул включен);

        /***********************************************************************
        
                Добавь (другой) добавщик в_ this logger. Appenders are each
                invoked for лог события as they are produced. At most, one
                экземпляр of each добавщик will be invoked.

        ***********************************************************************/

        final Логгер добавь (Добавщик другой);

        /***********************************************************************
        
                Удали все appenders из_ this Логгер

        ***********************************************************************/

        final Логгер очисть ();

        /***********************************************************************
        
                Get время since this application пущен

        ***********************************************************************/

        final ИнтервалВремени рантайм ();

        /***********************************************************************
        
                Отправка a сообщение в_ this logger via its добавщик список.

        ***********************************************************************/

        final Логгер добавь (Уровень уровень, lazy ткст эксп);

        /***********************************************************************
        
                Отправка a сообщение в_ this logger via its добавщик список.

        ***********************************************************************/

        private проц добавь (СобытиеЛога событие);
        /***********************************************************************

                Формат текст using the форматёр configured in the associated
                иерархия 

        ***********************************************************************/

        final ткст форматируй (ткст буфер, ткст строкаФмт, ...);
        /***********************************************************************

                Формат текст using the форматёр configured in the associated
                иерархия. 

        ***********************************************************************/

        final Логгер форматируй (Уровень уровень, ткст фмт, ИнфОТипе[] типы, АргСписок арги);

        /***********************************************************************
        
                See if the provопрed Логгер имя is a предок of this one. Note 
                that each Логгер имя имеется a '.' appended в_ the конец, such that 
                имя segments will not partially сверь.

        ***********************************************************************/

        private final бул ветвь_ли_от (ткст кандидат);

        /***********************************************************************
        
                See if the provопрed Логгер is a better сверь as a предок of
                this one. This is использован в_ restructure the иерархия when a
                new logger экземпляр is introduced

        ***********************************************************************/

        private final бул близкийПотомок_ли (Логгер другой);
}

/*******************************************************************************
 
        The Логгер иерархия implementation. We keep a reference в_ each
        logger in a хэш-таблица for convenient отыщи purposes, plus keep
        each logger linked в_ the другие in an ordered группа. Ordering
        places shortest names at the голова и longest ones at the хвост, 
        making the дело of опрentifying ancestors easier in an orderly
        fashion. For example, when propagating levels across descendents
        it would be a mistake в_ распространить в_ a ветвь before все of its
        ancestors were taken care of.

*******************************************************************************/

private class Иерархия : Логгер.Контекст
{
        private Логгер                  root_;
        private ткст                  name_,
                                        адрес_;      
        private Логгер.Контекст          context_;
        private Логгер[ткст]          loggers;


        /***********************************************************************
        
                Construct a иерархия with the given имя.

        ***********************************************************************/

        this (ткст имя);

        /**********************************************************************

        **********************************************************************/

        final ткст ярлык ();
        /**********************************************************************


        **********************************************************************/

        final бул включен (Уровень уровень, Уровень тест);

        /**********************************************************************

                Return the имя of this Иерархия

        **********************************************************************/

        final ткст имя ();
        /**********************************************************************

                Набор the имя of this Иерархия

        **********************************************************************/

        final проц имя (ткст имя);

        /**********************************************************************

                Return the адрес of this Иерархия. This is typically
                attached when Отправкаing события в_ remote monitors.

        **********************************************************************/

        final ткст адрес ();

        /**********************************************************************

                Набор the адрес of this Иерархия. The адрес is attached
                использован when Отправкаing события в_ remote monitors.

        **********************************************************************/

        final проц адрес (ткст адрес);

        /**********************************************************************

                Return the diagnostic контекст.  Useful for настройка an 
                override logging уровень.

        **********************************************************************/
        
        final Логгер.Контекст контекст ();
        
        /**********************************************************************

                Набор the diagnostic контекст.  Not usually necessary, as a 
                default was создан.  Useful when you need в_ provопрe a 
                different implementation, such as a ThreadLocal variant.

        **********************************************************************/
        
        final проц контекст (Логгер.Контекст контекст);
        
        /***********************************************************************
        
                Return the корень узел.

        ***********************************************************************/

        final Логгер корень ();

        /***********************************************************************
        
                Return the экземпляр of a Логгер with the provопрed ярлык. If
                the экземпляр does not exist, it is создан at this время.

                Note that an пустой ярлык is consопрered illegal, и will be
                ignored.

        ***********************************************************************/

        final Логгер отыщи (ткст ярлык);

        /***********************************************************************

                traverse the установи of configured loggers

        ***********************************************************************/

        final цел opApply (цел delegate(ref Логгер) дг);

        /***********************************************************************
        
                Return the экземпляр of a Логгер with the provопрed ярлык. If
                the экземпляр does not exist, it is создан at this время.

        ***********************************************************************/

        private synchronized Логгер инъекцируй (ткст ярлык, Логгер delegate(ткст имя) дг);

        /***********************************************************************
        
                Loggers are maintained in a sorted linked-список. The order 
                is maintained such that the shortest имя is at the корень, 
                и the longest at the хвост.

                This is готово so that updateLoggers() will always have a
                known environment в_ manИПulate, making it much faster.

        ***********************************************************************/

        private проц вставь (Логгер l);

        /***********************************************************************
        
                Propagate hierarchical changes across known loggers. 
                This включает changes in the иерархия itself, и в_
                the various settings of ветвь loggers with respect в_ 
                their предок(s).              

        ***********************************************************************/

        private проц обнови (Логгер изменён, бул force);

        /***********************************************************************
        
                Propagate changes in the иерархия downward в_ ветвь Loggers.
                Note that while 'предок' и 'breakpoint' are always forced
                в_ обнови, the обнови of 'уровень' is selectable.

        ***********************************************************************/

        private проц распространить (Логгер logger, Логгер изменён, бул force);
}



/*******************************************************************************

        Contains все information about a logging событие, и is passed around
        between methods once it имеется been determined that the invoking logger
        is включен for вывод.

        Note that Событие экземпляры are maintained in a freelist rather than
        being allocated each время, и they include a scratchpad area for
        EventLayout форматёрs в_ use.

*******************************************************************************/

package struct СобытиеЛога
{
        private ткст          msg_,
                                name_;
        private Время            time_;
        private Уровень           level_;
        private Иерархия       host_;

        /***********************************************************************
                
                Набор the various атрибуты of this событие.

        ***********************************************************************/

        проц установи (Иерархия хост, Уровень уровень, ткст сооб, ткст имя);
        /***********************************************************************
                
                Return the сообщение attached в_ this событие.

        ***********************************************************************/

        ткст вТкст ();

        /***********************************************************************
                
                Return the имя of the logger which produced this событие

        ***********************************************************************/

        ткст имя ();

        /***********************************************************************
                
                Return the logger уровень of this событие.

        ***********************************************************************/

        Уровень уровень ();

        /***********************************************************************
                
                Return the иерархия where the событие was produced из_

        ***********************************************************************/

        Иерархия хост ();

        /***********************************************************************
                
                Return the время this событие was produced, relative в_ the 
                старт of this executable

        ***********************************************************************/

        ИнтервалВремени вринтервал ();

        /***********************************************************************
               
                Return the время this событие was produced relative в_ Epoch

        ***********************************************************************/

        Время время ();

        /***********************************************************************
                
                Return время when the executable пущен

        ***********************************************************************/

        Время пущен ();

        /***********************************************************************
                
                Return the logger уровень имя of this событие.

        ***********************************************************************/

        ткст имяУровня ();

        /***********************************************************************
                
                Convert a время значение (in milliseconds) в_ аски

        ***********************************************************************/

        static ткст вМилли (ткст s, ИнтервалВремени время);
        
}


/*******************************************************************************

        База class for все Appenders. These objects are responsible for
        излейting messages sent в_ a particular logger. There may be ещё
        than one добавщик attached в_ any logger. The actual сообщение is
        constructed by другой class known as an EventLayout.
        
*******************************************************************************/

public class Добавщик
{
        typedef цел Маска;

        private Добавщик        next_;
        private Выкладка          layout_;
        private static Выкладка   генерный;

        /***********************************************************************

                Interface for все logging выкладка экземпляры

                Implement this метод в_ perform the formatting of  
                сообщение контент.

        ***********************************************************************/

        interface Выкладка
        {
                проц форматируй (СобытиеЛога событие, т_мера delegate(проц[]) дг);
        }

        /***********************************************************************
                
                Return the маска использован в_ опрentify this Добавщик. The маска
                is использован в_ figure out whether an добавщик имеется already been 
                invoked for a particular logger.

        ***********************************************************************/

        abstract Маска маска ();

        /***********************************************************************
                
                Return the имя of this Добавщик.

        ***********************************************************************/

        abstract ткст имя ();
                
        /***********************************************************************
                
                Доб a сообщение в_ the вывод.

        ***********************************************************************/

        abstract проц добавь (СобытиеЛога событие);

        /***********************************************************************
              
              Созд an Добавщик и default its выкладка в_ LayoutSimple.  

        ***********************************************************************/

        this ();

        /***********************************************************************
              
              Созд an Добавщик и default its выкладка в_ LayoutSimple.  

        ***********************************************************************/

        static this ();

        /***********************************************************************
                
                Static метод в_ return a Маска for опрentifying the Добавщик.
                Each Добавщик class should have a unique fingerprint so that
                we can figure out which ones have been invoked for a given
                событие. A bitmask is a simple an efficient way в_ do that.

        ***********************************************************************/

        protected Маска регистрируй (ткст тэг);
        /***********************************************************************
                
                Набор the текущ выкладка в_ be that of the аргумент, or the
                генерный выкладка where the аргумент is пусто

        ***********************************************************************/

        проц выкладка (Выкладка как);

        /***********************************************************************
                
                Return the текущ Выкладка

        ***********************************************************************/

        Выкладка выкладка ();

        /***********************************************************************
                
                Attach другой добавщик в_ this one

        ***********************************************************************/

        проц следщ (Добавщик добавщик);

        /***********************************************************************
                
                Return the следщ добавщик in the список

        ***********************************************************************/

        Добавщик следщ ();

        /***********************************************************************
                
                Close this добавщик. This would be использован for файл, СОКЕТs, 
                и such like.

        ***********************************************************************/

        проц закрой ();
}


/*******************************************************************************

        An добавщик that does nothing. This is useful for cutting и
        pasting, и for benchmarking the лог environment.

*******************************************************************************/

public class ДобНуль : Добавщик
{
        private Маска маска_;

        /***********************************************************************
                
                Созд with the given Выкладка

        ***********************************************************************/

        this (Выкладка как = пусто);

        /***********************************************************************
                
                Возвращает фингерпринт для данного класса

        ***********************************************************************/

        final Маска маска ();

        /***********************************************************************
                
                Вернуть имя данного класса

        ***********************************************************************/

        final ткст имя ();
                
        /***********************************************************************
                
                Доб an событие в_ the вывод.
                 
        ***********************************************************************/

        final проц добавь (СобытиеЛога событие);
}


/*******************************************************************************

        Доб в_ a configured ИПотокВывода

*******************************************************************************/

public class ДобПоток : Добавщик
{
        private Маска            маска_;
        private бул            flush_;
        private ИПотокВывода    Поток_;

        /***********************************************************************
                
                Созд with the given поток и выкладка

        ***********************************************************************/

        this (ИПотокВывода поток, бул слей = нет, Добавщик.Выкладка как = пусто);

        /***********************************************************************
                
                Возвращает фингерпринт для данного класса

        ***********************************************************************/

        final Маска маска ();

        /***********************************************************************
                
                Вернуть имя данного класса

        ***********************************************************************/

        ткст имя ();
                
        /***********************************************************************
               
                Доб an событие в_ the вывод.
                 
        ***********************************************************************/

        final проц добавь (СобытиеЛога событие);
}

/*******************************************************************************

        A simple выкладка comprised only of время(ms), уровень, имя, и сообщение

*******************************************************************************/

public class ТаймерВыкладки : Добавщик.Выкладка
{
        /***********************************************************************
                
                Subclasses should implement this метод в_ perform the
                formatting of the actual сообщение контент.

        ***********************************************************************/

        проц форматируй (СобытиеЛога событие, т_мера delegate(проц[]) дг);
}


/*******************************************************************************

*******************************************************************************/

debug (Журнал)
{
        import io.Console;
 
        проц main()
        {
                Журнал.конфиг (Кош.поток);
                auto лог = Журнал.отыщи ("fu.bar");
                лог.уровень = лог.След;
                // traditional usage
                лог.след ("hello {}", "world");

                сим[100] буф;
                лог (лог.След, лог.форматируй(буф, "hello {}", "world"));

                // formatted вывод
/*                /
                auto форматируй = Журнал.форматируй;
                лог.инфо (форматируй ("blah{}", 1));

                // снимок
                auto snap = Журнал.снимок (лог, Уровень.Ошибка);
                snap.форматируй ("арг{}; ", 1);
                snap.форматируй ("арг{}; ", 2);
                //лог.след (snap.форматируй ("ошибка! арг{}", 3));
                snap.слей;
*/
        }
}
