/*******************************************************************************

        copyright:      Copyright (c) 2008 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)
        
        version:        Initial release: April 2008      
        
        author:         Kris

        Since:          0.99.7

*******************************************************************************/

module util.container.more.Stack;

private import exception: ГранМасИскл;

/******************************************************************************

        Стэк заданного значения-типа V, с максимальной глубиной = Размер. Обратите
        внимание, что размещение в собственную память не происходит, если Размер != 0,
        и происходит размещение в  кучу, если Размер == 0. Поэтому олучается
        экземпляр с фиксированным размером и низким избытком(low-overhead),
		либо экземпляр, ориентирующийся на кучу.

******************************************************************************/

struct Стэк (V, цел Размер = 0) 
{
        alias н_ый              opIndex;
        alias срез            opSlice;
        alias вращайВправо      opShrAssign;
        alias вращайВлево       opShlAssign;
        alias сунь             opCatAssign;
          
        
        static if (Размер == 0)
                  {
                  private бцел глубина;
                  private V[]  стэк;
                  }
               else
                  {
                  private бцел     глубина;
                  private V[Размер]  стэк;
                  }

        /***********************************************************************

                Очисть стэк

        ***********************************************************************/

        Стэк* очисть ()
        {
                глубина = 0;
                return this;
        }

        /***********************************************************************
                
                Возвращает глубину стэка

        ***********************************************************************/

        бцел размер ()
        {
                return глубина;
        }

        /***********************************************************************
                
                Вернуть свобожные неиспользованнные ячейки

        ***********************************************************************/

        бцел неиспользовано ()
        {
                return стэк.length - глубина;
        }

        /***********************************************************************
                
                Возвращает (shallow) клон данного стэке стэк на данный стэк

        ***********************************************************************/

        Стэк клонируй ()
        {       
                Стэк s =void;
                static if (Размер == 0)
                           s.стэк.length = стэк.length;
                s.стэк[] = стэк;
                s.глубина = глубина;
                return s;
        }

        /***********************************************************************
                
                Вталкивает и возвращает (shallow) копию самого верхнего элемента

        ***********************************************************************/

        V dup ()
        {
                auto v = верх;
                сунь (v);       
                return v;
        }

        /**********************************************************************

               Втолкнуть значение на стэк.

                Выводит исключение, если стэк полон

        **********************************************************************/

        Стэк* сунь (V значение)
        {
                static if (Размер == 0)
                          {
                          if (глубина >= стэк.length)
                              стэк.length = стэк.length + 64;
                          стэк[глубина++] = значение;
                          }
                       else
                          {                         
                          if (глубина < стэк.length)
                              стэк[глубина++] = значение;
                          else
                             ошибка (__LINE__);
                          }
                return this;
        }

        /**********************************************************************

                Поместитьв стэк ряд значений.

                Выводит исключение, если стэк полон

        **********************************************************************/

        Стэк* добавь (V[] значение...)
        {
                foreach (v; значение)
                         сунь (v);
                return this;
        }

        /**********************************************************************

                Удаляет и возвращает на стэк последнюю добавку.

                Выводит исключение, если стэк пуст

        **********************************************************************/

        V вынь ()
        {
                if (глубина)
                    return стэк[--глубина];

                return ошибка (__LINE__);
        }

        /**********************************************************************

                Удаляет и возвращает на стэк последнюю добавку.

                Выводит исключение, если стэк пуст
				
        **********************************************************************/

        V верх ()
        {
                if (глубина)
                    return стэк[глубина-1];

                return ошибка (__LINE__);
        }

        /**********************************************************************

                Меняет местами две верхних записи и возвращает верхнюю

                Выводит исключение, если в стэке  недостаточно записей

        **********************************************************************/

        V обменяй ()
        {
                auto p = стэк.ptr + глубина;
                if ((p -= 2) >= стэк.ptr)
                   {
                   auto v = p[0];
                   p[0] = p[1];
                   return p[1] = v; 
                   }

                return ошибка (__LINE__);                
        }

        /**********************************************************************

                Index стэк записи, where a zero индекс represents the
                newest стэк Запись (the верх).

                Throws an исключение when the given индекс is out of range

        **********************************************************************/

        V н_ый (бцел i)
        {
                if (i < глубина)
                    return стэк [глубина-i-1];

                return ошибка (__LINE__);
        }

        /**********************************************************************

                Rotate the given число of стэк записи 

                Throws an исключение when the число is out of range

        **********************************************************************/

        Стэк* вращайВлево (бцел d)
        {
                if (d <= глубина)
                   {
                   auto p = &стэк[глубина-d];
                   auto t = *p;
                   while (--d)
                          *p++ = *(p+1);
                   *p = t;
                   }
                else
                   ошибка (__LINE__);
                return this;
        }

        /**********************************************************************

                Rotate the given число of стэк записи 

                Throws an исключение when the число is out of range

        **********************************************************************/

        Стэк* вращайВправо (бцел d)
        {
                if (d <= глубина)
                   {
                   auto p = &стэк[глубина-1];
                   auto t = *p;
                   while (--d)
                          *p-- = *(p-1);
                   *p = t;
                   }
                else
                   ошибка (__LINE__);
                return this;
        }

        /**********************************************************************

                Return the стэк as an Массив of значения, where the первый
                Массив Запись represents the oldest значение. 
                
                Doing a foreach() on the returned Массив will traverse in
                the opposite direction of foreach() upon a стэк
                 
        **********************************************************************/

        V[] срез ()
        {
                return стэк [0 .. глубина];
        }

        /**********************************************************************

                Throw an исключение 

        **********************************************************************/

        private V ошибка (т_мера строка)
        {
                throw new ГранМасИскл (__FILE__, строка);
        }

        /***********************************************************************

                Iterate из_ the most recent в_ the oldest стэк записи

        ***********************************************************************/

        цел opApply (цел delegate(ref V значение) дг)
        {
                        цел результат;

                        for (цел i=глубина; i-- && результат is 0;)
                             результат = дг (стэк[i]);
                        return результат;
        }
}

/+
/*******************************************************************************

*******************************************************************************/
import io.Stdout;
unittest
{
        

        проц main()
        {
                Стэк!(цел) v;
                v.сунь(1);
                
                Стэк!(цел, 10) s;

                Стдвыв.форматнс ("сунь four");
                s.сунь (1);
                s.сунь (2);
                s.сунь (3);
                s.сунь (4);
                foreach (v; s)
                         Стдвыв.форматнс ("{}", v);
                s <<= 4;
                s >>= 4;
                foreach (v; s)
                         Стдвыв.форматнс ("{}", v);

                s = s.клонируй;
                Стдвыв.форматнс ("вынь one: {}", s.вынь);
                foreach (v; s)
                         Стдвыв.форматнс ("{}", v);
                Стдвыв.форматнс ("верх: {}", s.верх);

                Стдвыв.форматнс ("вынь three");
                s.вынь;
                s.вынь;
                s.вынь;
                foreach (v; s)
                         Стдвыв.форматнс ("> {}", v);
        }
}
        
+/