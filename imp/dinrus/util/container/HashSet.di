/*******************************************************************************

        copyright:      Copyright (c) 2008 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)

        version:        Apr 2008: Initial release

        authors:        Kris

        Since:          0.99.7

        Based upon Doug Lea's Java collection package

*******************************************************************************/

module util.container.HashSet;

private import  util.container.Slink;

public  import  util.container.Container;

private import util.container.model.IContainer;

/*******************************************************************************

        Хэш таблица implementation of a Набор

        ---
        Обходчик обходчик ()
        цел opApply (цел delegate(ref V значение) дг)

        бул добавь (V элемент)
        бул содержит (V элемент)
        бул возьми (ref V элемент)
        бул удали (V элемент)
        т_мера удали (ИКонтейнер!(V) e)
        бул замени (V старЭлемент, V новЭлемент)

        т_мера размер ()
        бул пуст_ли ()
        V[] вМассив (V[] приёмн)
        HashSet dup ()
        HashSet очисть ()
        HashSet сбрось ()

        т_мера корзины ()
        проц корзины (т_мера cap)
        плав порог ()
        проц порог (плав desired)
        ---

*******************************************************************************/

class HashSet (V, alias Хэш = Контейнер.хэш, 
                  alias Извл = Контейнер.извлеки, 
                  alias Куча = Контейнер.ДефСбор) 
                  : ИКонтейнер!(V)
{
        // use this тип for Разместитель configuration
        public alias Slink!(V)  Тип;
        
        private alias Тип      *Реф;

        private alias Куча!(Тип) Размест;

        // Each таблица Запись is a список - пусто if no таблица allocated
        private Реф             таблица[];
        
        // число of элементы contained
        private т_мера          счёт;

        // the порог загрузи factor
        private плав           факторЗагрузки;

        // configured куча manager
        private Размест           куча;
        
        // мутация тэг updates on each change
        private т_мера            мутация;

        /***********************************************************************

                Construct a HashSet экземпляр

        ***********************************************************************/

        this (плав f = Контейнер.дефФакторЗагрузки)
        {
                факторЗагрузки = f;
        }

        /***********************************************************************

                Clean up when deleted

        ***********************************************************************/

        ~this ()
        {
                сбрось;
        }

        /***********************************************************************

                Return a генерный обходчик for contained элементы
                
        ***********************************************************************/

        final Обходчик обходчик ()
        {
                Обходчик i =void;
                i.мутация = мутация;
                i.таблица = таблица;
                i.хозяин = this;
                i.ячейка = пусто;
                i.ряд = 0;
                return i;
        }

        /***********************************************************************


        ***********************************************************************/

        final цел opApply (цел delegate(ref V значение) дг)
        {
                return обходчик.opApply (дг);
        }

        /***********************************************************************

                Return the число of элементы contained
                
        ***********************************************************************/

        final т_мера размер ()
        {
                return счёт;
        }
        
        /***********************************************************************

                Добавь a new элемент в_ the установи. Does not добавь if there is an
                equivalent already present. Returns да where an элемент
                is добавьed, нет where it already есть_ли
                
                Время complexity: O(1) average; O(n) worst.
                
        ***********************************************************************/

        final бул добавь (V элемент)
        {
                if (таблица is пусто)
                    перемерь (Контейнер.дефНачКорзины);

                auto h = Хэш  (элемент, таблица.length);
                auto hd = таблица[h];

                if (hd && hd.найди (элемент))
                    return нет;

                таблица[h] = размести.установи (элемент, hd);
                инкремент;

                // only проверь if bin was Неукmpty                    
                if (hd)
                    проверьЗагрузку; 
                return да;
        }

        /***********************************************************************

                Does this установи contain the given элемент?
        
                Время complexity: O(1) average; O(n) worst
                
        ***********************************************************************/

        final бул содержит (V элемент)
        {
                if (счёт)
                   {
                   auto p = таблица[Хэш (элемент, таблица.length)];
                   if (p && p.найди (элемент))
                       return да;
                   }
                return нет;
        }

        /***********************************************************************

                Make an independent копируй of the container. Does not клонируй
                элементы
                
                Время complexity: O(n)
                
        ***********************************************************************/

        final HashSet dup ()
        {
                auto клонируй = new HashSet!(V, Хэш, Извл, куча) (факторЗагрузки);
                
                if (счёт)
                   {
                   клонируй.корзины (корзины);

                   foreach (значение; обходчик)
                            клонируй.добавь (значение);
                   }
                return клонируй;
        }

        /***********************************************************************

                Удали the provопрed элемент. Returns да if найдено, нет
                otherwise
                
                Время complexity: O(1) average; O(n) worst

        ***********************************************************************/

        final т_мера удали (V элемент, бул все)
        {
                return удали(элемент) ? 1 : 0;
        }

        /***********************************************************************

                Удали the provопрed элемент. Returns да if найдено, нет
                otherwise
                
                Время complexity: O(1) average; O(n) worst

        ***********************************************************************/

        final бул удали (V элемент)
        {
                if (счёт)
                   {
                   auto h = Хэш (элемент, таблица.length);
                   auto hd = таблица[h];
                   auto trail = hd;
                   auto p = hd;

                   while (p)
                         {
                         auto n = p.следщ;
                         if (элемент == p.значение)
                            {
                            декремент (p);
                            if (p is таблица[h])
                               {
                               таблица[h] = n;
                               trail = n;
                               }
                            else
                               trail.следщ = n;
                            return да;
                            } 
                         else
                            {
                            trail = p;
                            p = n;
                            }
                         }
                   }
                return нет;
        }

        /***********************************************************************

                Замени the первый экземпляр of старЭлемент with новЭлемент.
                Returns да if старЭлемент was найдено и replaced, нет
                otherwise.
                
        ***********************************************************************/

        final т_мера замени (V старЭлемент, V новЭлемент, бул все)
        {
                return замени (старЭлемент, новЭлемент) ? 1 : 0;
        }

        /***********************************************************************

                Замени the первый экземпляр of старЭлемент with новЭлемент.
                Returns да if старЭлемент was найдено и replaced, нет
                otherwise.
                
        ***********************************************************************/

        final бул замени (V старЭлемент, V новЭлемент)
        {

                if (счёт && старЭлемент != новЭлемент)
                   if (содержит (старЭлемент))
                      {
                      удали (старЭлемент);
                      добавь (новЭлемент);
                      return да;
                      }
                return нет;
        }

        /***********************************************************************

                Удали и expose the первый элемент. Returns нет when no
                ещё элементы are contained
        
                Время complexity: O(n)

        ***********************************************************************/

        final бул возьми (ref V элемент)
        {
                if (счёт)
                    foreach (ref список; таблица)
                             if (список)
                                {
                                auto p = список;
                                элемент = p.значение;
                                список = p.следщ;
                                декремент (p);
                                return да;
                                }
                return нет;
        }

        /***********************************************************************

        ************************************************************************/

        public проц добавь (ИКонтейнер!(V) e)
        {
                foreach (значение; e)
                         добавь (значение);
        }

        /***********************************************************************

        ************************************************************************/

        public т_мера удали (ИКонтейнер!(V) e)
        {
                т_мера c;
                foreach (значение; e)
                         if (удали (значение))
                             ++c;
                return c;
        }

        /***********************************************************************

                Clears the ХэшКарта contents. Various атрибуты are
                retained, such as the internal таблица itself. Invoke
                сбрось() в_ drop everything.

                Время complexity: O(n)
                
        ***********************************************************************/

        final HashSet очисть ()
        {
                return очисть (нет);
        }

        /***********************************************************************

                Reset the HashSet contents и optionally конфигурируй a new
                куча manager. This releases ещё память than очисть() does

                Время complexity: O(1)
                
        ***********************************************************************/

        final HashSet сбрось ()
        {
                очисть (да);
                куча.собери (таблица);
                таблица = пусто;
                return this;
        }

        /***********************************************************************

                Return the число of корзины

                Время complexity: O(1)

        ***********************************************************************/

        final т_мера корзины ()
        {
                return таблица ? таблица.length : 0;
        }

        /***********************************************************************

                Набор the число of корзины и перемерь as требуется
                
                Время complexity: O(n)

        ***********************************************************************/

        final HashSet корзины (т_мера cap)
        {
                if (cap < Контейнер.дефНачКорзины)
                    cap = Контейнер.дефНачКорзины;

                if (cap !is корзины)
                    перемерь (cap);
                return this;
        }

        /***********************************************************************

                Return the перемерь порог
                
                Время complexity: O(1)

        ***********************************************************************/

        final плав порог ()
        {
                return факторЗагрузки;
        }

        /***********************************************************************

                Набор the перемерь порог, и перемерь as требуется
                
                Время complexity: O(n)
                
        ***********************************************************************/

        final проц порог (плав desired)
        {
                assert (desired > 0.0);
                факторЗагрузки = desired;
                if (таблица)
                    проверьЗагрузку;
        }

        /***********************************************************************

                Configure the назначено разместитель with the размер of each
                allocation блок (число of узелs allocated at one время)
                и the число of узелs в_ pre-наполни the кэш with.
                
                Время complexity: O(n)

        ***********************************************************************/

        final HashSet кэш (т_мера чанк, т_мера счёт=0)
        {
                куча.конфиг (чанк, счёт);
                return this;
        }

        /***********************************************************************

                Copy и return the contained установи of значения in an Массив, 
                using the optional приёмн as a реципиент (which is resized 
                as necessary).

                Returns a срез of приёмн representing the container значения.
                
                Время complexity: O(n)
                
        ***********************************************************************/

        final V[] вМассив (V[] приёмн = пусто)
        {
                if (приёмн.length < счёт)
                    приёмн.length = счёт;

                т_мера i = 0;
                foreach (v; this)
                         приёмн[i++] = v;
                return приёмн [0 .. счёт];                        
        }

        /***********************************************************************

                Is this container пустой?
                
                Время complexity: O(1)
                
        ***********************************************************************/

        final бул пуст_ли ()
        {
                return счёт is 0;
        }

        /***********************************************************************

                Sanity проверь
                 
        ***********************************************************************/

        final HashSet проверь()
        {
                assert(!(таблица is пусто && счёт !is 0));
                assert((таблица is пусто || таблица.length > 0));
                assert(факторЗагрузки > 0.0f);

                if (таблица)
                   {
                   т_мера c = 0;
                   for (т_мера i = 0; i < таблица.length; ++i)
                       {
                       for (auto p = таблица[i]; p; p = p.следщ)
                           {
                           ++c;
                           assert(содержит(p.значение));
                           assert(Хэш (p.значение, таблица.length) is i);
                           }
                       }
                   assert(c is счёт);
                   }
                return this;
        }

        /***********************************************************************

                Размести a узел экземпляр. This is использован as the default разместитель
                 
        ***********************************************************************/

        private Реф размести ()
        {
                return куча.размести;
        }
        
        /***********************************************************************

                 Check в_ see if we are past загрузи factor порог. If so,
                 перемерь so that we are at half of the desired порог.
                 
        ***********************************************************************/

        private проц проверьЗагрузку ()
        {
                плав fc = счёт;
                плав ft = таблица.length;
                if (fc / ft > факторЗагрузки)
                    перемерь (2 * cast(т_мера)(fc / факторЗагрузки) + 1);
        }

        /***********************************************************************

                перемерь таблица в_ new ёмкость, rehashing все элементы
                
        ***********************************************************************/

        private проц перемерь (т_мера newCap)
        {
                //Стдвыв.форматнс ("перемерь {}", newCap);
                auto newtab = куча.размести (newCap);
                измени;

                foreach (bucket; таблица)
                         while (bucket)
                               {
                               auto n = bucket.следщ;
                               auto h = Хэш (bucket.значение, newCap);
                               bucket.следщ = newtab[h];
                               newtab[h] = bucket;
                               bucket = n;
                               }

                // release the приор таблица и присвой new one
                куча.собери (таблица);
                таблица = newtab;
        }

        /***********************************************************************

                Удали the indicated узел. We need в_ traverse корзины
                for this, since we're singly-linked only. Better в_ save
                the per-узел память than в_ gain a little on each удали

                Used by iterators only
                 
        ***********************************************************************/

        private бул удали (Реф узел, т_мера ряд)
        {
                auto hd = таблица[ряд];
                auto trail = hd;
                auto p = hd;

                while (p)
                      {
                      auto n = p.следщ;
                      if (p is узел)
                         {
                         декремент (p);
                         if (p is hd)
                             таблица[ряд] = n;
                         else
                            trail.следщ = n;
                         return да;
                         } 
                      else
                         {
                         trail = p;
                         p = n;
                         }
                      }
                return нет;
        }

        /***********************************************************************

                Clears the HashSet contents. Various атрибуты are
                retained, such as the internal таблица itself. Invoke
                сбрось() в_ drop everything.

                Время complexity: O(n)
                
        ***********************************************************************/

        private HashSet очисть (бул все)
        {
                измени;

                // собери each узел if we can't собери все at once
                if (куча.собери(все) is нет)
                    foreach (ref v; таблица)
                             while (v)
                                   {
                                   auto n = v.следщ;
                                   декремент (v);
                                   v = n;
                                   }

                // retain таблица, but удали bucket chains
                foreach (ref v; таблица)
                         v = пусто;

                счёт = 0;
                return this;
        }

        /***********************************************************************

                new элемент was добавьed
                
        ***********************************************************************/

        private проц инкремент()
        {
                ++мутация;
                ++счёт;
        }
        
        /***********************************************************************

                элемент was removed
                
        ***********************************************************************/

        private проц декремент (Реф p)
        {
                Извл (p.значение);
                куча.собери (p);
                ++мутация;
                --счёт;
        }
        
        /***********************************************************************

                установи was изменён
                
        ***********************************************************************/

        private проц измени()
        {
                ++мутация;
        }

        /***********************************************************************

                Обходчик with no filtering

        ***********************************************************************/

        private struct Обходчик
        {
                т_мера  ряд;
                Реф     ячейка,
                        приор;
                Реф[]   таблица;
                HashSet хозяин;
                т_мера  мутация;

                /***************************************************************

                        Dопр the container change underneath us?

                ***************************************************************/

                бул действителен ()
                {
                        return хозяин.мутация is мутация;
                }               

                /***************************************************************

                        Accesses the следщ значение, и returns нет when
                        there are no further значения в_ traverse

                ***************************************************************/

                бул следщ (ref V v)
                {
                        auto n = следщ;
                        return (n) ? v = *n, да : нет;
                }
                
                /***************************************************************

                        Return a pointer в_ the следщ значение, or пусто when
                        there are no further значения в_ traverse

                ***************************************************************/

                V* следщ ()
                {
                        while (ячейка is пусто)
                               if (ряд < таблица.length)
                                   ячейка = таблица [ряд++];
                               else
                                  return пусто;
  
                        приор = ячейка;
                        ячейка = ячейка.следщ;
                        return &приор.значение;
                }

                /***************************************************************

                        Foreach support

                ***************************************************************/

                цел opApply (цел delegate(ref V значение) дг)
                {
                        цел результат;

                        auto c = ячейка;
                        loop: while (да)
                              {
                              while (c is пусто)
                                     if (ряд < таблица.length)
                                         c = таблица [ряд++];
                                     else
                                        break loop;
  
                              приор = c;
                              c = c.следщ;
                              if ((результат = дг(приор.значение)) != 0)
                                   break loop;
                              }

                        ячейка = c;
                        return результат;
                }                               

                /***************************************************************

                        Удали значение at the текущ обходчик location

                ***************************************************************/

                бул удали ()
                {
                        if (приор)
                            if (хозяин.удали (приор, ряд-1))
                               {
                               // ignore this change
                               ++мутация;
                               return да;
                               }

                        приор = пусто;
                        return нет;
                }
        }
}



/*******************************************************************************

*******************************************************************************/

debug (HashSet)
{
        import io.Stdout;
        import thread;
        import time.StopWatch;
       
        проц main()
        {
                // usage examples ...
                auto установи = new HashSet!(ткст);
                установи.добавь ("foo");
                установи.добавь ("bar");
                установи.добавь ("wumpus");

                // implicit генерный iteration
                foreach (значение; установи)
                         Стдвыв (значение).нс;

                // явный генерный iteration
                foreach (значение; установи.обходчик)
                         Стдвыв (значение).нс;

                // генерный iteration with optional удали
                auto s = установи.обходчик;
                foreach (значение; s)
                        {} // s.удали;

                // incremental iteration, with optional удали
                ткст v;
                auto обходчик = установи.обходчик;
                while (обходчик.следщ(v))
                      {} //обходчик.удали;
                
                // incremental iteration, with optional failfast
                auto it = установи.обходчик;
                while (it.действителен && it.следщ(v))
                      {}

                // удали specific элемент
                установи.удали ("wumpus");

                // удали первый элемент ...
                while (установи.возьми(v))
                       Стдвыв.форматнс ("taking {}, {} left", v, установи.размер);
                
                
                // установи for benchmark, with a установи of целыйs. We
                // use a чанк разместитель, и presize the bucket[]
                auto тест = new HashSet!(цел, Контейнер.хэш, Контейнер.извлеки, Контейнер.Чанк);
                тест.кэш (1000, 1_000_000);
                тест.корзины = 1_500_000;
                const счёт = 1_000_000;
                Секундомер w;

                // benchmark добавим
                w.старт;
                for (цел i=счёт; i--;)
                     тест.добавь(i);
                Стдвыв.форматнс ("{} добавьs: {}/s", тест.размер, тест.размер/w.stop);

                // benchmark reading
                w.старт;
                for (цел i=счёт; i--;)
                     тест.содержит(i);
                Стдвыв.форматнс ("{} lookups: {}/s", тест.размер, тест.размер/w.stop);

                // benchmark добавим without allocation overhead
                тест.очисть;
                w.старт;
                for (цел i=счёт; i--;)
                     тест.добавь(i);
                Стдвыв.форматнс ("{} добавьs (after очисть): {}/s", тест.размер, тест.размер/w.stop);

                // benchmark duplication
                w.старт;
                auto dup = тест.dup;
                Стдвыв.форматнс ("{} элемент dup: {}/s", dup.размер, dup.размер/w.stop);

                // benchmark iteration
                w.старт;
                foreach (значение; тест) {}
                Стдвыв.форматнс ("{} элемент iteration: {}/s", тест.размер, тест.размер/w.stop);

                тест.проверь;
        }
}
