/*******************************************************************************

        copyright:      Copyright (c) 2008 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)

        version:        Apr 2008: Initial release

        authors:        Kris

        Since:          0.99.7

        Based upon Doug Lea's Java collection package

*******************************************************************************/

module util.container.CircularList;

private import util.container.Clink;

public  import  util.container.Container;

private import util.container.model.IContainer;

/*******************************************************************************

        Циркулярно связанный список

        ---
        Обходчик обходчик ()
        цел opApply (цел delegate(ref V значение) дг)

        ЦиркулярныйСписок добавь (V элемент)
        ЦиркулярныйСписок добавьПо (т_мера индекс, V элемент)
        ЦиркулярныйСписок добавь (V элемент)
        ЦиркулярныйСписок приставь (V элемент)
        т_мера добавьПо (т_мера индекс, ИКонтейнер!(V) e)
        т_мера добавь (ИКонтейнер!(V) e)
        т_мера приставь (ИКонтейнер!(V) e)

        бул возьми (ref V v)
        бул содержит (V элемент)
        V получи (т_мера индекс)
        т_мера первый (V элемент, т_мера startingIndex = 0)
        т_мера последний (V элемент, т_мера startingIndex = 0)

        V голова ()
        V хвост ()
        V голова (V элемент)
        V хвост (V элемент)
        V удалиГолову ()
        V удалиХвост ()

        бул удалиПо (т_мера индекс)
        т_мера удали (V элемент, бул все)
        т_мера удалиДиапазон (т_мера отИндекса, т_мера доИндекса)

        т_мера замени (V старЭлемент, V новЭлемент, бул все)
        бул замениПо (т_мера индекс, V элемент)

        т_мера размер ()
        бул пуст_ли ()
        V[] вМассив (V[] приёмн)
        ЦиркулярныйСписок dup ()
        ЦиркулярныйСписок поднабор (т_мера из_, т_мера length)
        ЦиркулярныйСписок очисть ()
        ЦиркулярныйСписок сбрось ()
        ЦиркулярныйСписок проверь ()
        ---

*******************************************************************************/

class ЦиркулярныйСписок (V, alias Извл = Контейнер.извлеки, 
                       alias Куча = Контейнер.ДефСбор) 
                       : ИКонтейнер!(V)
{
        // use this тип for Разместитель configuration
        public alias ЦСвязка!(V)  Тип;
        
        private alias Тип      *Реф;

        private alias Куча!(Тип) Размест;

        // число of элементы contained
        private т_мера          счёт;

        // configured куча manager
        private Размест           куча;
        
        // мутация тэг updates on each change
        private т_мера          мутация;

        // голова of the список. Пусто if пустой
        private Реф             список;


        /***********************************************************************

                Make an пустой список

        ***********************************************************************/

        this ()
        {
                this (пусто, 0);
        }

        /***********************************************************************

                Make an configured список

        ***********************************************************************/

        protected this (Реф h, т_мера c)
        {
                список = h;
                счёт = c;
        }

        /***********************************************************************

                Clean up when deleted

        ***********************************************************************/

        ~this ()
        {
                сбрось;
        }

        /***********************************************************************

                Return a генерный обходчик for contained элементы
                
        ***********************************************************************/

        final Обходчик обходчик ()
        {
                // использован в_ be Обходчик i =void, but that doesn't инициализуй
                // fields that are not инициализован here.
                Обходчик i;
                i.хозяин = this;
                i.мутация = мутация;
                i.ячейка = i.голова = список;
                i.счёт = счёт;
                i.индекс = 0;
                return i;
        }

        /***********************************************************************

                Configure the назначено разместитель with the размер of each
                allocation блок (число of узелs allocated at one время)
                и the число of узелs в_ pre-наполни the кэш with.
                
                Время complexity: O(n)

        ***********************************************************************/

        final ЦиркулярныйСписок кэш (т_мера чанк, т_мера счёт=0)
        {
                куча.конфиг (чанк, счёт);
                return this;
        }

        /***********************************************************************


        ***********************************************************************/

        final цел opApply (цел delegate(ref V значение) дг)
        {
                return обходчик.opApply (дг);
        }

        /***********************************************************************

                Return the число of элементы contained
                
        ***********************************************************************/

        final т_мера размер ()
        {
                return счёт;
        }
        
        /***********************************************************************

                Make an independent копируй of the список. Elements themselves 
                are not cloned

        ***********************************************************************/

        final ЦиркулярныйСписок dup ()
        {
                return new ЦиркулярныйСписок!(V, Извл, куча) (список ? список.копируйСписок(&куча.размести) : пусто, счёт);
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final бул содержит (V элемент)
        {
                if (список)
                    return список.найди (элемент) !is пусто;
                return нет;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V голова ()
        {
                return перваяЯчейка.значение;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V хвост ()
        {
                return последняяЯчейка.значение;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final V получи (т_мера индекс)
        {
                return ячейкаПо(индекс).значение;
        }

        /***********************************************************************

                Время complexity: O(n)
                Returns т_мера.max if no элемент найдено.

        ***********************************************************************/

        final т_мера первый (V элемент, т_мера startingIndex = 0)
        {
                if (startingIndex < 0)
                    startingIndex = 0;

                auto p = список;
                if (p is пусто)
                    return т_мера.max;

                for (т_мера i = 0; да; ++i)
                    {
                    if (i >= startingIndex && элемент == p.значение)
                        return i;

                    p = p.следщ;
                    if (p is список)
                        break;
                    }
                return т_мера.max;
        }

        /***********************************************************************
                
                Время complexity: O(n)
                Returns т_мера.max if no элемент найдено.

        ***********************************************************************/

        final т_мера последний (V элемент, т_мера startingIndex = 0)
        {
                if (счёт is 0)
                    return т_мера.max;

                if (startingIndex >= счёт)
                    startingIndex = счёт - 1;

                if (startingIndex < 0)
                    startingIndex = 0;

                auto p = ячейкаПо (startingIndex);
                т_мера i = startingIndex;
                for (;;)
                    {
                    if (элемент == p.значение)
                        return i;
                    else
                       if (p is список)
                           break;
                       else
                          {
                          p = p.предш;
                          --i;
                          }
                    }
                return т_мера.max;
        }

        /***********************************************************************

                Время complexity: O(length)

        ***********************************************************************/

        final ЦиркулярныйСписок поднабор (т_мера из_, т_мера length)
        {
                Реф новый_список = пусто;

                if (length > 0)
                   {
                   проверьИндекс (из_);
                   auto p = ячейкаПо (из_);
                   auto текущ = новый_список = куча.размести.установи (p.значение);

                   for (т_мера i = 1; i < length; ++i)
                       {
                       p = p.следщ;
                       if (p is пусто)
                           length = i;
                       else
                          {
                          текущ.добавьСледщ (p.значение, &куча.размести);
                          текущ = текущ.следщ;
                          }
                       }
                   }

                return new ЦиркулярныйСписок (новый_список, length);
        }

        /***********************************************************************

                 Время complexity: O(1)

        ***********************************************************************/

        final ЦиркулярныйСписок очисть ()
        {
                return очисть (нет);
        }

        /***********************************************************************

                Reset the ХэшКарта contents и optionally конфигурируй a new
                куча manager. This releases ещё память than очисть() does

                Время complexity: O(n)
                
        ***********************************************************************/

        final ЦиркулярныйСписок сбрось ()
        {
                return очисть (да);
        }

        /***********************************************************************

                Время complexity: O(n)

                Takes the последний элемент on the список

        ***********************************************************************/

        final бул возьми (ref V v)
        {
                if (счёт)
                   {
                   v = хвост;
                   удалиХвост ();
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final ЦиркулярныйСписок приставь (V элемент)
        {
                if (список is пусто)
                    список = куча.размести.установи (элемент);
                else
                   список = список.добавьПредш (элемент, &куча.размести);
                инкремент;
                return this;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V голова (V элемент)
        {
                auto p = перваяЯчейка;
                auto v = p.значение;
                p.значение = элемент;
                измени;
                return v;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V удалиГолову ()
        {
                auto p = перваяЯчейка;
                if (p.синглтон)
                   список = пусто;
                else
                   {
                   auto n = p.следщ;
                   p.отвяжи;
                   список = n;
                   }

                auto v = p.значение;
                декремент (p);
                return v;
        }

       /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final ЦиркулярныйСписок добавь (V элемент)
        {
                return добавь (элемент);
        }

       /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final ЦиркулярныйСписок добавь (V элемент)
        {
                if (список is пусто)
                    приставь (элемент);
                else
                   {
                   список.предш.добавьСледщ (элемент, &куча.размести);
                   инкремент;
                   }
                return this;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V хвост (V элемент)
        {
                auto p = последняяЯчейка;
                auto v = p.значение;
                p.значение = элемент;
                измени;
                return v;
        }

        /***********************************************************************

                Время complexity: O(1)

        ***********************************************************************/

        final V удалиХвост ()
        {
                auto p = последняяЯчейка;
                if (p is список)
                    список = пусто;
                else
                   p.отвяжи;

                auto v = p.значение;
                декремент (p);
                return v;
        }

        /***********************************************************************
                
                Время complexity: O(n)

        ***********************************************************************/

        final ЦиркулярныйСписок добавьПо (т_мера индекс, V элемент)
        {
                if (индекс is 0)
                    приставь (элемент);
                else
                   {
                   ячейкаПо(индекс - 1).добавьСледщ(элемент, &куча.размести);
                   инкремент;
                   }
                return this;
        }

        /***********************************************************************
                
                Время complexity: O(n)

        ***********************************************************************/

        final ЦиркулярныйСписок замениПо (т_мера индекс, V элемент)
        {
                ячейкаПо(индекс).значение = элемент;
                измени;
                return this;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final ЦиркулярныйСписок удалиПо (т_мера индекс)
        {
                if (индекс is 0)
                    удалиГолову;
                else
                   {
                   auto p = ячейкаПо(индекс);
                   p.отвяжи;
                   декремент (p);
                   }
                return this;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final т_мера удали (V элемент, бул все)
        {
                auto c = счёт;
                if (список)
                   {
                   auto p = список;
                   for (;;)
                       {
                       auto n = p.следщ;
                       if (элемент == p.значение)
                          {
                          p.отвяжи;
                          декремент (p);
                          if (p is список)
                             {
                             if (p is n)
                                {
                                список = пусто;
                                break;
                                }
                             else
                                список = n;
                             }
   
                          if (! все)
                                break;
                          else
                             p = n;
                          }
                       else
                          if (n is список)
                              break;
                          else
                             p = n;
                       }
                   }
                return c - счёт;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final т_мера замени (V старЭлемент, V новЭлемент, бул все)
        {
                т_мера c;
                if (список)
                   {
                   auto p = список;
                   do {
                      if (старЭлемент == p.значение)
                         {
                         ++c;
                         измени;
                         p.значение = новЭлемент;
                         if (! все)
                               break;
                         }
                      p = p.следщ;
                      } while (p !is список);
                   }
                return c;
        }

        /***********************************************************************

                Время complexity: O(число of элементы in e)

        ***********************************************************************/

        final т_мера приставь (ИКонтейнер!(V) e)
        {
                Реф hd = пусто;
                Реф текущ = пусто;
                auto c = счёт;

                foreach (элемент; e)
                        {
                        инкремент;

                        if (hd is пусто)
                           {
                           hd = куча.размести.установи(элемент);
                           текущ = hd;
                           }
                        else
                           {
                           текущ.добавьСледщ (элемент, &куча.размести);
                           текущ = текущ.следщ;
                           }
                      }

                if (список is пусто)
                    список = hd;
                else
                   if (hd)
                      {
                      auto tl = список.предш;
                      текущ.следщ = список;
                      список.предш = текущ;
                      tl.следщ = hd;
                      hd.предш = tl;
                      список = hd;
                      }
                return счёт - c;
        }

        /***********************************************************************
                
                Время complexity: O(число of элементы in e)

        ***********************************************************************/

        final т_мера добавь (ИКонтейнер!(V) e)
        {
                auto c = счёт;
                if (список is пусто)
                    приставь (e);
                else
                   {
                   auto текущ = список.предш;
                   foreach (элемент; e)
                           {
                           инкремент;
                           текущ.добавьСледщ (элемент, &куча.размести);
                           текущ = текущ.следщ;
                           }
                   }
                return счёт - c;
        }

        /***********************************************************************

                Время complexity: O(размер() + число of элементы in e)

        ***********************************************************************/

        final т_мера добавьПо (т_мера индекс, ИКонтейнер!(V) e)
        {
                auto c = счёт;
                if (список is пусто || индекс is 0)
                    приставь (e);
                else
                   {
                   auto текущ = ячейкаПо (индекс - 1);
                   foreach (элемент; e)
                           {
                           инкремент;
                           текущ.добавьСледщ (элемент, &куча.размести);
                           текущ = текущ.следщ;
                           }
                   }
                return счёт - c;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        final т_мера удалиДиапазон (т_мера отИндекса, т_мера доИндекса)
        {
                auto p = ячейкаПо (отИндекса);
                auto последний = список.предш;
                auto c = счёт;
                for (т_мера i = отИндекса; i <= доИндекса; ++i)
                    {
                    auto n = p.следщ;
                    p.отвяжи;
                    декремент (p);
                    if (p is список)
                       {
                       if (p is последний)
                          {
                          список = пусто;
                          break;
                          }
                       else
                          список = n;
                       }
                    p = n;
                    }
                return c - счёт;
        }

        /***********************************************************************

                Copy и return the contained установи of значения in an Массив, 
                using the optional приёмн as a реципиент (which is resized 
                as necessary).

                Returns a срез of приёмн representing the container значения.
                
                Время complexity: O(n)
                
        ***********************************************************************/

        final V[] вМассив (V[] приёмн = пусто)
        {
                if (приёмн.length < счёт)
                    приёмн.length = счёт;

                т_мера i = 0;
                foreach (v; this)
                         приёмн[i++] = v;
                return приёмн [0 .. счёт];                        
        }

        /***********************************************************************

                Is this container пустой?
                
                Время complexity: O(1)
                
        ***********************************************************************/

        final бул пуст_ли ()
        {
                return счёт is 0;
        }

        /***********************************************************************


        ***********************************************************************/

        final ЦиркулярныйСписок проверь()
        {
                assert(((счёт is 0) is (список is пусто)));
                assert((список is пусто || список.размер is счёт));

                if (список)
                   {
                   т_мера c = 0;
                   auto p = список;
                   do {
                      assert(p.предш.следщ is p);
                      assert(p.следщ.предш is p);
                      assert(экземпляры(p.значение) > 0);
                      assert(содержит(p.значение));
                      p = p.следщ;
                      ++c;
                      } while (p !is список);
                   assert(c is размер);
                   }
                return this;
        }

        /***********************************************************************

                Время complexity: O(n)

        ***********************************************************************/

        private т_мера экземпляры (V элемент)
        {
                if (список)
                    return список.счёт (элемент);
                return 0;
        }

        /***********************************************************************


        ***********************************************************************/

        private проц проверьИндекс (т_мера i)
        {
                if (i >= счёт)
                    throw new Исключение ("вне диапазона");
        }

        /***********************************************************************

                return the первый ячейка, or throw исключение if пустой

        ***********************************************************************/

        private Реф перваяЯчейка ()
        {
                проверьИндекс (0);
                return список;
        }

        /***********************************************************************

                return the последний ячейка, or throw исключение if пустой

        ***********************************************************************/

        private Реф последняяЯчейка ()
        {
                проверьИндекс (0);
                return список.предш;
        }

        /***********************************************************************

                 return the индекс'th ячейка, or throw исключение if bad индекс

        ***********************************************************************/

        private Реф ячейкаПо (т_мера индекс)
        {
                проверьИндекс (индекс);
                return список.н_ый (индекс);
        }

        /***********************************************************************

                 Время complexity: O(1)

        ***********************************************************************/

        private ЦиркулярныйСписок очисть (бул все)
        {
                измени;

                // собери each узел if we can't собери все at once
                if (куча.собери(все) is нет && счёт)
                   {
                   auto p = список;
                   do {
                      auto n = p.следщ;
                      декремент (p);
                      p = n;
                      } while (p != список);
                   }
        
                список = пусто;
                счёт = 0;
                return this;
        }

        /***********************************************************************

                new элемент was добавьed
                
        ***********************************************************************/

        private проц инкремент ()
        {
                ++мутация;
                ++счёт;
        }
        
        /***********************************************************************

                элемент was removed
                
        ***********************************************************************/

        private проц декремент (Реф p)
        {
                Извл (p.значение);
                куча.собери (p);
                ++мутация;
                --счёт;
        }
        
        /***********************************************************************

                установи was изменён
                
        ***********************************************************************/

        private проц измени ()
        {
                ++мутация;
        }

        /***********************************************************************

                Обходчик with no filtering

        ***********************************************************************/

        private struct Обходчик
        {
                бул              рев;
                Реф               ячейка,
                                  голова,
                                  приор;
                ЦиркулярныйСписок      хозяин;
                т_мера            индекс,
                                  счёт;
                т_мера            мутация;

                /***************************************************************

                        Dопр the container change underneath us?

                ***************************************************************/

                бул действителен ()
                {
                        return хозяин.мутация is мутация;
                }               

                /***************************************************************

                        Accesses the следщ значение, и returns нет when
                        there are no further значения в_ traverse

                ***************************************************************/

                бул следщ (ref V v)
                {
                        auto n = следщ;
                        return (n) ? v = *n, да : нет;
                }
                
                /***************************************************************

                        Return a pointer в_ the следщ значение, or пусто when
                        there are no further значения в_ traverse

                ***************************************************************/

                V* следщ ()
                {
                        V* r;

                        if (индекс < счёт)
                           {
                           ++индекс;
                           приор = ячейка;
                           r = &ячейка.значение;
                           ячейка = (рев ? ячейка.предш : ячейка.следщ);
                           }
                        else
                           ячейка = пусто;
                        return r;
                }

                /***************************************************************

                        Foreach support

                ***************************************************************/

                цел opApply (цел delegate(ref V значение) дг)
                {
                        цел результат;
                        auto c = ячейка;

                        while (индекс < счёт)
                              {
                              ++индекс;
                              приор = c;
                              c = (рев ? c.предш : c.следщ);
                              if ((результат = дг(приор.значение)) != 0)
                                   break;
                              }
                        ячейка = пусто;
                        return результат;
                }                               

                /***************************************************************

                        Удали значение that was just iterated.

                ***************************************************************/

                бул удали ()
                {
                        if (приор)
                           {
                           auto следщ = (рев ? приор.предш : приор.следщ);
                           if (приор is голова)
                              {
                              if (приор is следщ)
                                  хозяин.список = пусто;
                              else
                                 голова = хозяин.список = следщ;
                              }

                           приор.отвяжи;
                           хозяин.декремент (приор);
                           приор = пусто;

                           --счёт;
                           // ignore this change
                           ++мутация;
                           return да;
                           }
                        return нет;
                }

                /***************************************************************

                        Insert a new значение before the узел about в_ be
                        iterated (or after the узел that was just iterated).

                        Возвращает: a копируй of this обходчик for chaining.

                ***************************************************************/

                Обходчик вставь (V значение)
                {
                    // Note: this needs some attention, not sure как
                    // в_ укз when обходчик is in реверс.
                    if (ячейка is пусто)
                        приор.добавьСледщ (значение, &хозяин.куча.размести);
                    else
                       ячейка.добавьПредш (значение, &хозяин.куча.размести);
                    хозяин.инкремент;

                    ++счёт;
                    // ignore this change
                    ++мутация;
                    return *this;
                }

                /***************************************************************
        
                        FlИП the direction of следщ() и opApply(), и 
                        сбрось the termination point such that we can do
                        другой full traversal.

                ***************************************************************/

                Обходчик реверс ()
                {
                        рев ^= да;
                        следщ;
                        индекс = 0;
                        return *this;
                }
        }
}

/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
    unittest
    {
        auto список = new ЦиркулярныйСписок!(цел);
        список.добавь(1);
        список.добавь(2);
        список.добавь(3);

        цел i = 1;
        foreach(v; список)
        {
            assert(v == i);
            i++;
        }

        auto итер = список.обходчик;
        итер.следщ();
        итер.удали();                          // delete the первый item

        i = 2;
        foreach(v; список)
        {
            assert(v == i);
            i++;
        }

        // тест вставь functionality
        итер = список.обходчик;
        итер.следщ;
        итер.вставь(4);

        цел[] compareto = [2, 4, 3];
        i = 0;
        foreach(v; список)
        {
            assert(v == compareto[i++]);
        }
    }
}

/*******************************************************************************

*******************************************************************************/

debug (ЦиркулярныйСписок)
{
        import io.Stdout;
        import thread;
        import time.StopWatch;

        проц main()
        {
                // usage examples ...
                auto список = new ЦиркулярныйСписок!(ткст);
                foreach (значение; список)
                         Стдвыв (значение).нс;

                список.добавь ("foo");
                список.добавь ("bar");
                список.добавь ("wumpus");

                // implicit генерный iteration
                foreach (значение; список)
                         Стдвыв (значение).нс;

                // явный генерный iteration   
                foreach (значение; список.обходчик.реверс)
                         Стдвыв.форматнс ("> {}", значение);

                // генерный iteration with optional удали
                auto s = список.обходчик;
                foreach (значение; s)
                         {} //s.удали;

                // incremental iteration, with optional удали
                ткст v;
                auto обходчик = список.обходчик;
                while (обходчик.следщ(v))
                       {}//обходчик.удали;
                
                // incremental iteration, with optional failfast
                auto it = список.обходчик;
                while (it.действителен && it.следщ(v))
                      {}

                // удали specific элемент
                список.удали ("wumpus", нет);

                // удали первый элемент ...
                while (список.возьми(v))
                       Стдвыв.форматнс ("taking {}, {} left", v, список.размер);
                
                
                // установи for benchmark, with a установи of целыйs. We
                // use a чанк разместитель, и presize the bucket[]
                auto тест = new ЦиркулярныйСписок!(бцел, Контейнер.извлеки, Контейнер.Чанк);
                тест.кэш (1000, 1_000_000);
                const счёт = 1_000_000;
                Секундомер w;

                // benchmark добавьing
                w.старт;
                for (бцел i=счёт; i--;)
                     тест.добавь(i);
                Стдвыв.форматнс ("{} добавьs: {}/s", тест.размер, тест.размер/w.stop);

                // benchmark добавьing without allocation overhead
                тест.очисть;
                w.старт;
                for (бцел i=счёт; i--;)
                     тест.добавь(i);
                Стдвыв.форматнс ("{} добавьs (after очисть): {}/s", тест.размер, тест.размер/w.stop);

                // benchmark duplication
                w.старт;
                auto dup = тест.dup;
                Стдвыв.форматнс ("{} элемент dup: {}/s", dup.размер, dup.размер/w.stop);

                // benchmark iteration
                w.старт;
                foreach (значение; тест) {}
                Стдвыв.форматнс ("{} элемент iteration: {}/s", тест.размер, тест.размер/w.stop);

                тест.проверь;
        }
}
