/*********************************************************
   Авторское право: (C) 2008 принадлежит Steven Schveighoffer.
              Все права защищены

   Лицензия: $(LICENSE)

**********************************************************/
module col.DefaultAllocator;
        private import cidrus;
		
/+ ИНТЕРФЕЙС:

  struct БлокРазместитель(З, бцел элтовНаБлок)
    {
        const бул нужноСвоб = да;
        struct элемент
        {
            элемент *следщ;
        }
        struct блок
        {
            блок *следщ;
            блок *предш;
            элемент *списокОсвобождения;
            бцел члоОсвоб;
            З[элтовНаБлок] элты;
            З *разместиИзОсвоб();
            бул вымести(З *з);
        }

        блок *используется;
        блок *свеж;
        бцел следщСвеж;

        З* размести();
        проц освободи(З* з);
        проц освободиВсе();
    }

struct ПростойРазместитель(З)
{
    const бул нужноСвоб = нет;

    З* размести();
}

template ДефолтныйРазместитель(З);
+/
//==========================================================


    /**
     * Поместить сразу в память блок элементов, а затем использовать его для возврата
     * элементов.  Это делает размещение конкретных элементов более эффективным,
     * так как СМ не используется для размещения каждого элемента, только каждого
     * блока элементов.
     *
     * Единственное требование, чтобы размер З<начения> был равен >= размеру указателя.
     * По той причине, что З<начение> данных используется как указатель при освобождении
     * элемента.
     *
     *Если освобождается весь блок элементов, затем этот блок возвращается
     * СМ.
     */
    struct БлокРазместитель(З, бцел элтовНаБлок)
    {
        /**
         * Для рециклирования узлов на новое размещение требуется высвобождение памяти
         */
        const бул нужноСвоб = да;
        static if(З.sizeof < (ук).sizeof)
        {
            static assert(false, "Ошибка, Разместитель для " ~ З.stringof ~ " не инстанциирован");
        }

        /**
         * Эта форма используется для линковки вместе рециклируемых элементов.
         */
        struct элемент
        {
            элемент *следщ;
        }

        /**
         * Блок элементов
         */
        struct блок
        {
            /**
             * Следующий блок в цепочке
             */
            блок *следщ;

            /**
             * Предыдущий блок в цепочке.  Требуется для удаления O(1)
             * из цепочки.
             */
            блок *предш;

            /**
             * Линкованный список освобождаемых в блоке элементов.  Этот список
             * составляется каждый раз, когда в этом блоке освобождается элемент.
             */
            элемент *списокОсвобождения;

            /**
             * Число освобождаемых элементов в списокОсвобождения.  Используется для определения
             * может ли этот блок быть подан на тыл СМ
             */
            бцел члоОсвоб;

            /**
             * Элемент в блоке.
             */
            З[элтовНаБлок] элты;

            /**
             * Разместить З* <указатель на значение> в списке высвобождения.
             */
            З *разместиИзОсвоб()
            {
                элемент *x = списокОсвобождения;
                списокОсвобождения = x.следщ;
                //
                // Очистить указатель, это освобождает элемент, как будто обх
                //размещён только что
                //
                x.следщ = null;
                члоОсвоб--;
                return cast(З*)x;
            }

            /**
             * Выместить З*, послать обх на список высвобождения
             *
             * возвращает да, если блок больше не использует никаких элементов.
             */
            бул вымести(З *з)
            {
                //
                // Очистить элемент, чтобы СМ не интерпретировал его,
                // как указывающий на что-то ещё.
                //
                memset(з, 0, (З).sizeof);
                элемент *x = cast(элемент *)з;
                x.следщ = списокОсвобождения;
                списокОсвобождения = x;
                return (++члоОсвоб == элтовНаБлок);
            }
        }

        /**
         * Цепочка используемых чанков.  Используемые чанки должны были все свои элементы
         * разместить хотя бы раз.
         */
        блок *используется;

        /**
         * Свежий блок.  Это работает только если элементы доступны в
         * цепочке использований.
         */
        блок *свеж;

        /**
         * Следующий элемент в свежем блоке.  Так как нас не волнует то, что
         * список освобождения находится в свежем блоке, нам нужно отслеживать следующий
         * используемый свежий элемент.
         */
        бцел следщСвеж;

        /**
         * Разместить З*
         */
        З* размести()
        {
            if(используется !is null && используется.члоОсвоб > 0)
            {
                //
                // Разместить один элемент, если лист использования
                //
                З* рез = используется.разместиИзОсвоб();
                if(используется.члоОсвоб == 0)
                    //
                    // переместить использование в конец списка
                    //
                    используется = используется.следщ;
                return рез;
            }

            //
            //Нет элементов используется, размещение не имеет свежих
            // элементы
            //
            if(свеж is пусто)
            {
                свеж = new блок;
                следщСвеж = 0;
            }

            З* рез = &свеж.элты[следщСвеж];
            if(++следщСвеж == элтовНаБлок)
            {
                if(используется is пусто)
                {
                    используется = свеж;
                    свеж.следщ = свеж;
                    свеж.предш = свеж;
                }
                else
                {
                    //
                    // Вставить свеж в цепочку используется
                    //
                    свеж.предш = используется.предш;
                    свеж.следщ = используется;
                    свеж.предш.следщ = свеж;
                    свеж.следщ.предш = свеж;
                    if(свеж.члоОсвоб != 0)
                    {
                        //
                        // Можно рециклировать элементы из свеж
                        //
                        используется = свеж;
                    }
                }
                свеж = пусто;
            }
            return рез;
        }

        /**
         * освободи a З*
         */
        проц освободи(З* з)
        {
            //
            // нужно выяснить, какой блок з входит
            //
            блок *тек = cast(блок *)смАдрес(з);

            if(тек !is свеж && тек.члоОсвоб == 0)
            {
                //
                // переместить тек в фронт списка используется, обх освободил узлы
                //которые будут использоваться.
                //
                if(тек !is используется)
                {
                    if(используется.члоОсвоб != 0)
                    {
                        //
                        // первый, открепить тек от его текущего положения
                        //
                        тек.предш.следщ = тек.следщ;
                        тек.следщ.предш = тек.предш;

                        //
                        //теперь, вставить тек перед используется.
                        //
                        тек.предш = используется.предш;
                        тек.следщ = используется;
                        используется.предш = тек;
                        тек.предш.следщ = тек;
                    }
                    используется = тек;
                }
            }

            if(тек.вымести(з))
            {
                //
                // тек больше не имеет в использовании элементов, обх может быть удалён.
                //
                if(тек.следщ is тек)
                {
                    //
                    // только один элемент, не освобождать обх.
                    //
                }
                else
                {
                    //
                    // удалить тек из списка
                    //
                    if(используется is тек)
                    {
                        //
                        // обновить указатель используется
                        //
                        используется = используется.следщ;
                    }
                    тек.следщ.предш = тек.предш;
                    тек.предш.следщ = тек.следщ;
                    delete тек;
                }
            }
        }

        /**
         * Выместить все чанки используется  this Разместителем.
         */
        проц освободиВсе()
        {
            используется = пусто;

            //
            //поддерживать свеж
            //
            if(свеж !is пусто)
            {
                следщСвеж = 0;
                свеж.списокОсвобождения = пусто;
            }
        }
    }


/**
 * Простой Разместитель использует new, чтобы разместить каждый элемент
 */
struct ПростойРазместитель(З)
{
    /**
     * new не требует освободи
     */
    const бул нужноСвоб = нет;

    /**
     * эквивалентно new З;
     */
    З* размести()
    {
        return new З;
    }
}

/**
 * Разместитель по умолчанию выделяет корректный Разместитель, в зависимости от размера З<начения>.
 */
template ДефолтныйРазместитель(З)
{
    //
    / Если будет более одного З на страницу, использовать блок Разместитель,
    // иначе, использовать простой Разместитель.  Заметьте, что мы поддерживаем только
    // БлокРазместитель из Tango.
    //
    version(Динрус)
    {
        static if((З).sizeof + ((ук).sizeof * 3) + бцел.sizeof >= 4095 / 2)
        {
            alias ПростойРазместитель!(З) ДефолтныйРазместитель;
        }
        else
        {
            alias БлокРазместитель!(З, (4095 - ((ук ).sizeof * 3) - бцел.sizeof) / (З).sizeof) ДефолтныйРазместитель;
        }
    }
    else
    {
        alias ПростойРазместитель!(З) ДефолтныйРазместитель;
    }
}
