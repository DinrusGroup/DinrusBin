/*********************************************************
   Авторское право: (C) 2008 принадлежит Steven Schveighoffer.
              Все права защищены

   Лицензия: $(LICENSE)

   Это коллекция полезных итераторов и итерирующих
   функций.
**********************************************************/
module col.Iterators;

public import col.model.Iterator;

/+ ИНТЕРФЕЙС:

class ТрансформОбходчик(З, U=З) : Обходчик!(З)
{
    this(Обходчик!(U) исток, проц delegate(ref U, ref З) дг);
    this(Обходчик!(U) исток, проц function(ref U, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}


class ТрансформКлючник(К, З, J=К, U=З) : Ключник!(К, З)
{
    this(Ключник!(J, U) исток, проц delegate(ref J, ref U, ref К, ref З) дг);
    this(Ключник!(J, U) исток, проц function(ref J, ref U, ref К, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К к, ref З з) дг);
}

class ОбходчикЦепи(З) : Обходчик!(З)
{

    this(Обходчик!(З)[] цепь ...);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}

class КлючникЦепи(К, З) : Ключник!(К, З)
{
    this(Ключник!(К, З)[] цепь ...);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К, ref З) дг);
}

class ФильтрОбходчик(З) : Обходчик!(З)
{
    this(Обходчик!(З) исток, бул delegate(ref З) дг);
    this(Обходчик!(З) исток, бул function(ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}

class ФильтрКлючник(К, З) : Ключник!(К, З)
{
    this(Ключник!(К, З) исток, бул delegate(ref К, ref З) дг);
    this(Ключник!(К, З) исток, бул function(ref К, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К к, ref З з) дг);
}

class ОбходчикМассива(З) : Обходчик!(З)
{
    this(З[] массив);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З) дг);
}

class ОбходчикАМ(К, З) : Ключник!(К, З)
{
    this(З[К] массив);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref К, ref З) дг);
}

З[] вМассив(З)(Обходчик!(З) обх);
З[К] вАМ(К, З)(Ключник!(К, З) обх);

+/

/**
 * Этот обходчик преобразует каждый элемент из другого обходчика
 * с помощью функции преобразования.
 */
class ТрансформОбходчик(З, U=З) : Обходчик!(З)
{
    private Обходчик!(U) _ист;
    private проц delegate(ref U, ref З) _дг;
    private проц function(ref U, ref З) _фн;

    /**
     * Конструирует трансформ-обходчик, используя делегат.
     *
     * Функция преобразования преобразует объект типа U в типа З.
     */
    this(Обходчик!(U) исток, проц delegate(ref U, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует обходчик, используя указатель на функцию преобразования.
     *
     * Функция преобразования преобразует объект типа U в объект типа З.
     */
    this(Обходчик!(U) исток, проц function(ref U, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает длину истока.
     */
    бцел длина()
    {
        return _ист.length;
    }
	alias длина length;
    /**
     * Обходит исток, работая с временными копиями
     * трансформируемого элемента З.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел privateDG(ref U u)
        {
            З з;
            _дг(u, з);
            return дг(з);
        }

        цел privateFN(ref U u)
        {
            З з;
            _фн(u, з);
            return дг(з);
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }
}

/**
 * Трансформ для обходчика с ключом
 */
class ТрансформКлючник(К, З, J=К, U=З) : Ключник!(К, З)
{
    private Ключник!(J, U) _ист;
    private проц delegate(ref J, ref U, ref К, ref З) _дг;
    private проц function(ref J, ref U, ref К, ref З) _фн;

    /**
     * Конструирует трансформ-обходчик с помощью трансформ-делегата.
     *
     * Функция преобразования преобразует пару J, U в пару К, З.
     */
    this(Ключник!(J, U) исток, проц delegate(ref J, ref U, ref К, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует трансформ-обходчик с помощью указателя на трансформ-функцию.
     *
     * Функция преобразования преобразует пару J, U в пару К, З.
     */
    this(Ключник!(J, U) исток, проц function(ref J, ref U, ref К, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает длину истока.
     */
    бцел длина()
    {
        return _ист.length;
    }
	alias длина length;

    /**
     * Итерирует по  итератору исходника, работая с временными копиями
     * трансформированного элемента З.  Прим.: К можно пропустить, если это единственное
     * использование этого итератора.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел privateDG(ref J j, ref U u)
        {
            К к;
            З з;
            _дг(j, u, к, з);
            return дг(з);
        }

        цел privateFN(ref J j, ref U u)
        {
            К к;
            З з;
            _фн(j, u, к, з);
            return дг(з);
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }

    /**
     * Итерирует по  итератору исходника, работая с временными копиями
     * трансформированной пары К,З.
     */
    цел opApply(цел delegate(ref К к, ref З з) дг)
    {
        цел privateDG(ref J j, ref U u)
        {
            К к;
            З з;
            _дг(j, u, к, з);
            return дг(к, з);
        }

        цел privateFN(ref J j, ref U u)
        {
            К к;
            З з;
            _фн(j, u, к, з);
            return дг(к, з);
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }
}

/**
 * Цепной итератор сцепляет несколько цепей вместе.
 */
class ОбходчикЦепи(З) : Обходчик!(З)
{
    private Обходчик!(З)[] _цепь;
    private бул _поддержкаДлины;

    /**
     * Конструктор.  * Передайте итераторы, которые желаете сцепить в том
     * порядке, в котором вы желаете их сцепить.
     *
     * Если все итераторы поддерживают длину, то и этот тоже поддерживает
     * длина.  * Если один не поддерживает, то длина не поддерживается.
     */
    this(Обходчик!(З)[] цепь ...)
    {
        _цепь = цепь.dup;
        _поддержкаДлины = true;
        foreach(обх; _цепь)
            if(обх.length == ~0)
            {
                _поддержкаДлины = false;
                break;
            }
    }

    /**
     * Возвращает сумму всех длин итераторов в цепи.
     *
     * возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ, если единичный итератор в цепи не поддерживает
     * длина
     */
    бцел длина()
    {
        if(_поддержкаДлины)
        {
            бцел рез = 0;
            foreach(обх; _цепь)
                рез += обх.length;
            return рез;
        }
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     *Итерировать по цепочке итераторов.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }
}

/**
 * Цепной итератор сцепляет несколько цепей вместе.
 */
class КлючникЦепи(К, З) : Ключник!(К, З)
{
    private Ключник!(К, З)[] _цепь;
    private бул _поддержкаДлины;

    /**
     * Конструктор.  * Передайте итераторы, которые желаете сцепить в том
     * порядке, в котором вы желаете их сцепить.
     *
     * Если все итераторы поддерживают длину, то и этот тоже поддерживает
     * длина.  * Если один не поддерживает, то длина не поддерживается.
     */
    this(Ключник!(К, З)[] цепь ...)
    {
        _цепь = цепь.dup;
        _поддержкаДлины = true;
        foreach(обх; _цепь)
            if(обх.length == ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ)
            {
                _поддержкаДлины = false;
                break;
            }
    }

    /**
     * Возвращает сумму всех длин итераторов в цепи.
     *
     * возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ, если любые итераторы в цепи возвращают -1 для длина
     */
    бцел длина()
    {
        if(_поддержкаДлины)
        {
            бцел рез = 0;
            foreach(обх; _цепь)
                рез += обх.length;
            return рез;
        }
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * итерировать по цепочке итераторов, используя только значения.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }

    /**
     * итерировать по цепочке итераторов, используя ключи и значения.
     */
    цел opApply(цел delegate(ref К, ref З) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }
}

/**
 * Итератор Фильтр отфильтровывает нежелательные элементы, основанные на функции или
 * делегате.
 */
class ФильтрОбходчик(З) : Обходчик!(З)
{
    private Обходчик!(З) _ист;
    private бул delegate(ref З) _дг;
    private бул function(ref З) _фн;

    /**
     * Построить итератор-фильтр с указанным делегатом, решающий будет ли
     * элемент итерирован, либо нет.
     *
     * Делегат должен возвращать значение true для элементов, которые должны быть итерированы.
     */
    this(Обходчик!(З) исток, бул delegate(ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * * Построить итератор-фильтр с указанной функцией, решающей, будет ли
     * элемент итерирован, либо нет.
     *
     ** Функция должна возвращать значение true для элементов, которые должны быть итерированы.
     */
    this(Обходчик!(З) исток, бул function(ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ
     */
    бцел длина()
    {
        //
        //неизвестно, что решит делегат/функция фильтр.
        //
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * итерировать через итератор исходника, принимающий только элементы, где
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел privateDG(ref З з)
        {
            if(_дг(з))
                return дг(з);
            return 0;
        }

        цел privateFN(ref З з)
        {
            if(_фн(з))
                return дг(з);
            return 0;
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }
}

/**
 * Итератор Фильтр отфильтровывает нежелательные элементы, основанные на функции или
 * делегате.  * Эта версия фильтрует у итератора с ключами.
 */
class ФильтрКлючник(К, З) : Ключник!(К, З)
{
    private Ключник!(К, З) _ист;
    private бул delegate(ref К, ref З) _дг;
    private бул function(ref К, ref З) _фн;

    /**
     * Конструирует итератор-фильтр с указанным делегатом, решая, будет ли
     * пара ключ/значение итерирована, либо нет.
     *
     * Делегат должен возвращать значение true для элементов, которые должны быть итерированы.
     */
    this(Ключник!(К, З) исток, бул delegate(ref К, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Построить итератор-фильтр с указанной функцией, решающей, будет ли
     * пара ключ/значение итерирована, либо нет.
     *
     ** Функция должна возвращать значение true для элементов, которые должны быть итерированы.
     */
    this(Ключник!(К, З) исток, бул function(ref К, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ
     */
    бцел длина()
    {
        //
        //неизвестно, что решит делегат/функция фильтр.
        //
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * * итерировать через итератор исходника, итерирующий только элементы, где
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел privateDG(ref К к, ref З з)
        {
            if(_дг(к, з))
                return дг(з);
            return 0;
        }

        цел privateFN(ref К к, ref З з)
        {
            if(_фн(к, з))
                return дг(з);
            return 0;
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }

    /**
     * * итерировать через итератор исходника, итерирующий только элементы, где
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref К к, ref З з) дг)
    {
        цел privateDG(ref К к, ref З з)
        {
            if(_дг(к, з))
                return дг(к, з);
            return 0;
        }

        цел privateFN(ref К к, ref З з)
        {
            if(_фн(к, з))
                return дг(к, з);
            return 0;
        }

        if(_дг is null)
            return _ист.opApply(&privateFN);
        else
            return _ист.opApply(&privateDG);
    }
}

/**
 * Простая обёртка итератора для массива
 */
class ОбходчикМассива(З) : Обходчик!(З)
{
    private З[] _массив;

    /**
     * Обернуть данный массив.  * Обратите внимание, что это не создаёт копии.
     */
    this(З[] массив)
    {
        _массив = массив;
    }
	
    /**
     * Возвращает длину массива
     */
    бцел длина()
    {
        return _массив.length;
    }
	alias длина length;
	
    /**
     * Итерирует через массив.
     */
    цел opApply(цел delegate(ref З) дг)
    {
        цел возврзнач = 0;
        foreach(ref x; _массив)
            if((возврзнач = дг(x)) != 0)
                break;
        return возврзнач;
    }
}

/**
 * Итератор-обёртка для ассоциативного массива
 */
class ОбходчикАМ(К, З) : Ключник!(К, З)
{
    private З[К] _массив;

    /**
     * Конструирует обёртку итератора для данного массива
     */
    this(З[К] массив)
    {
        _массив = массив;
    }

    /**
     * Возвращает длину обёрнутого AA
     */
    бцел длина()
    {
        return _массив.length;// || _массив.length;
    }

	alias длина length;
    /**
     * Итерирует через AA
     */
    цел opApply(цел delegate(ref К, ref З) дг)
    {
        цел возврзнач;
        foreach(к, ref з; _массив)
            if((возврзнач = дг(к, з)) != 0)
                break;
        return возврзнач;
    }
}

/**
 * Функция, конвертирующая итератор в массив.
 *
 *Более оптимизирована под итераторы, поддерживающие длина.
 */
З[] вМассив(З)(Обходчик!(З) обх)
{
    З[] рез;
    бцел длин = обх.length;
    if(длин != ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ)
    {
        //
        // можно немного оптимизировать
        //
        рез.length = длин;
        цел i = 0;
        foreach(з; обх)
            рез[i++] = з;
    }
    else
    {
        foreach(з; обх)
            рез ~= з;
    }
    return рез;
}

/**
 *Преобразовать ключный итератор в ассоциативный массив.
 */
З[К] вАМ(К, З)(Ключник!(К, З) обх)
{
    З[К] рез;
    foreach(к, з; обх)
        рез[к] = з;
    return рез;
}
