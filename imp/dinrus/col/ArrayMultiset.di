/*********************************************************
   Авторское право: (C) 2008 принадлежит Steven Schveighoffer.
              Все права защищены

   Лицензия: $(LICENSE)

**********************************************************/
module col.ArrayMultiset;

public import col.model.Multiset;

private import col.Link;
private import col.DefaultAllocator;

/+ ИНТЕРФЕЙС:

class МассивМультинабор(З, alias Разместитель=ДефолтныйРазместитель) : Мультинабор!(З)
{
    alias МассивМультинабор!(З, Разместитель) ТипМассивМультинабор;

    struct курсор
    {
        З значение();
        З значение(З з);
        курсор opPostInc();
        курсор opPostDec();
        курсор opAddAssign(цел прир);
        курсор opSubAssign(цел прир);
        бул opEquals(курсор обх);
    }

    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг);
    цел opApply(цел delegate(ref З з) дг);
    this(бцел gs = 31);
    ТипМассивМультинабор очисти();
    бцел длина();
    курсор начало();
    курсор конец();
    курсор удали(курсор обх);
    курсор найди(З з);
    бул содержит(З з);
    ТипМассивМультинабор удали(З з);
    ТипМассивМультинабор удали(З з, ref бул был_Удалён);
    ТипМассивМультинабор добавь(З з);
    ТипМассивМультинабор добавь(З з, ref бул был_добавлен);
    ТипМассивМультинабор добавь(Обходчик!(З) обх);
    ТипМассивМультинабор добавь(Обходчик!(З) обх, ref бцел чло_добавленных);
    ТипМассивМультинабор добавь(З[] массив);
    ТипМассивМультинабор добавь(З[] массив, ref бцел чло_добавленных);
    бцел счёт(З з);
    ТипМассивМультинабор удалиВсе(З з);
    ТипМассивМультинабор удалиВсе(З з, ref бцел чло_Удалённых);
    ТипМассивМультинабор dup();
    З дай();
    З изыми();
}
+///===============================================================================

/**
 * Этот класс реализует интерфейс мультинабора, посредством содержания линкованного списка
 *массивов для хранения элементов.  Так как набор не нуждается в поддержке
 * определённого порядка, то добавление и удаление является операцией O(1).
 *
 *Удаление элемента делает недействительными все курсоры.
 *
 * Добавление элемента не влияет на валидность ни одно из курсоров.
 */
class МассивМультинабор(З, alias Разместитель=ДефолтныйРазместитель) : Мультинабор!(З)
{
    private alias Связка!(З[]).Узел узел;
    private alias Разместитель!(Связка!(З[])) разместитель;
    private разместитель разм;
    private узел _голова;
    private бцел _счёт;

    private бцел _growSize;

    private узел размести()
    {
        return разм.размести;
    }

    private узел размести(З[] з)
    {
        auto n = размести;
        n.значение = з;
        return n;
    }

    alias МассивМультинабор!(З, Разместитель) ТипМассивМультинабор;

    /**
     *Курсор - это подобие указателя на коллекцию МассивМультинабор.
     */
    struct курсор
    {
        private узел укз; alias укз ptr;
        private бцел инд;

        /**
         * возвращает значение, на которое указывает курсор
         */
        З значение()
        {
            return укз.значение[инд];
        }

        /**
         *Устанавливает значение, на которое указывает курсор
         */
        З значение(З з)
        {
            return (укз.значение[инд] = з);
        }

        /**
         * увеличивает курсор, возвращает значение, которое у него было до
         * увеличения
         */
        курсор opPostInc()
        {
            курсор врм = *this;
            инд++;
            if(инд >= укз.значение.length)
            {
                инд = 0;
                укз = укз.следщ;
            }
            return врм;
        }

        /**
         * уменьшает курсор, возвращая значение до
         * уменьшения
         */
        курсор opPostDec()
        {
            курсор врм = *this;
            if(инд == 0)
            {
                укз = укз.предш;
                инд = укз.значение.length - 1;
            }
            else
                инд--;
            return врм;
        }

        /**
         * добавляет заданное значение к курсору.
         *
         * Выполняется за O(n) раз, но константа равна < 1
         */
        курсор opAddAssign(цел прир)
        {
            if(прир < 0)
                return opSubAssign(-прир);
            while(прир >= укз.значение.length - инд)
            {
                прир -= (укз.значение.length - инд);
                укз = укз.следщ;
                инд = 0;
            }
            инд += прир;
            return *this;
        }

        /**
         *отнять заданное значение от курсора.
         *
         * Выполняется за O(n) раз, но константа равна < 1
         */
        курсор opSubAssign(цел прир)
        {
            if(прир < 0)
                return opAddAssign(-прир);
            while(прир > инд)
            {
                прир -= инд;
                укз = укз.предш;
                инд = укз.значение.length;
            }
            инд -= прир;
            return *this;
        }

        /**
         * Сравнивает два курсора на равенство
         */
        бул opEquals(курсор обх)
        {
            return обх.ptr is укз && обх.инд is инд;
        }
    }

    /**
     * Итерирует по элементам в МассивМультинабор, определяя которые
     * следует удалить.
     *
     * Используйте таким образом:
     * ----------
     * // удалить все нечётные элементы
     * foreach(ref чистить_ли, элт; &МассивМультинабор.очистить)
     * {
     *    чистить_ли = ((элт & 1) == 1)
     * }
     */
    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        return _примени(дг);
    }

    private цел _примени(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        курсор обх = начало;
        бул чистить_ли;
        цел возврдг = 0;
        курсор _конец = конец; //  ***
        while(!возврдг && обх != _конец)
        {
            чистить_ли = нет;
            if((возврдг = дг(чистить_ли, обх.ptr.значение[обх.инд])) != 0)
                break;
            if(чистить_ли)
                обх = удали(обх);
            else
                обх++;
        }
        return возврдг;
    }

    /**
     * Iterate over the collection
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref З з)
        {
            return дг(з);
        }
        return _примени(&_дг);
    }

    /**
     * Создать МассивМультинабор с заданным размером роста.  Размер роста
     * используется для размещения новых массивов для добавления к линкованному списку
     */
    this(бцел gs = 31)
    {
        _growSize = gs;
        _голова = разм.размести();
        узел.крепи(_голова, _голова);
        _счёт = 0;
    }

    /**
     * Очистить коллекцию от всех значений
     */
    ТипМассивМультинабор очисти()
    {
        static if(разместитель.нужноСвоб)
        {
            разм.освободиВсе();
            _голова = размести;
        }
        узел.крепи(_голова, _голова);
        return this;
    }

    /**
     * Возвращает число элементов в коллекции
     */
    бцел длина()
    {
        return _счёт;
    }
	alias длина length;

    /**
     * Возвращает курсор, указывающий на первый элемент в коллекции.
     */
    курсор начало()
    {
        курсор обх;
        обх.ptr = _голова.следщ;
        обх.инд = 0;
        return обх;
    }

    /**
     * Возвращает курсор, который указывает сразу после последнего элемента
     * коллекции.
     */
    курсор конец()
    {
        курсор обх;
        обх.ptr = _голова;
        обх.инд = 0;
        return обх;
    }

    /**
     *Удаляет элемент, на который указывает курсор.  Возвращает действительный
     * курсор, указывающий на другой элемент или конец, если элемент был удалён
     * и был последним элементом.
     *
     * Выполняется за O(1) раз.
     */
    курсор удали(курсор обх)
    {
        узел последн = _голова.предш;
        if(обх.ptr is последн && обх.инд is последн.значение.length - 1)
        {
            обх = конец;
        }
        else
        {
            обх.значение = последн.значение[$-1];
        }
        последн.значение.length = последн.значение.length - 1;
        if(последн.значение.length == 0)
        {
            последн.открепи;
            static if(разместитель.нужноСвоб)
                разм.освободи(последн);
        }
        _счёт--;
        return обх;
    }

    /**
     * * Возвращает курсор, указывающий на первый случай з<начения>
     *
     * Выполняется за O(n) раз.
     */
    курсор найди(З з)
    {
        курсор обх = начало;
        курсор _конец = конец;
        while(обх != _конец && обх.значение != з)
            обх++;
        return обх;
    }

    /**
     * * Возвращает да, если  з является элементом в наборе
     *
     * Выполняется за O(n) раз.
     */
    бул содержит(З з)
    {
        return найди(з) != конец;
    }

    /**
     * Удаляет данный элемент из набора.  Этим удаляется первый
     * лишь случай.
     *
     *Возвращает да, если элемент был найден и удалён.
     *
     * Выполняется за O(n) раз.
     */
    ТипМассивМультинабор удали(З з)
    {
        бул пропущен;
        return удали(з, пропущен);
    }

    /**
     * Удаляет данный элемент из набора.  Этим удаляется первый
     * лишь случай.
     *
     *Возвращает да, если элемент был найден и удалён.
     *
     * Выполняется за O(n) раз.
     */
    ТипМассивМультинабор удали(З з, ref бул был_Удалён)
    {
        курсор обх = найди(з);
        if(обх == конец)
            был_Удалён = нет;
        else
        {
            удали(обх);
            был_Удалён = да;
        }
        return this;
    }

    /**
     * Добавляет заданый элемент в набор.
     *
     * Возвращает да.
     *
     * Выполняется за O(1) раз.
     */
    ТипМассивМультинабор добавь(З з)
    {
        бул пропущен;
        return добавь(з, пропущен);
    }
    /**
     * Добавляет заданый элемент в набор.
     *
     * Возвращает да.
     *
     * Выполняется за O(1) раз.
     */
    ТипМассивМультинабор добавь(З з, ref бул был_добавлен)
    {
        узел последн = _голова.предш;
        if(последн is _голова || последн.значение.length == _growSize)
        {
            //
            // предварительная длина размещения, установливается на 0
            //
            auto массив = new З[_growSize];
            массив.length = 0;
            _голова.приставь(размести(массив));
            последн = _голова.предш;
        }

        последн.значение ~= з;
        был_добавлен = да;
        _счёт++;
        return this;
    }

    //
    //могут быть, вероятно, оптимизированы ещё более
    //

    /**
     *Добавляет все значения из итератора в набор.
     *
     * Возвращает число добавленных элементов.
     */
    ТипМассивМультинабор добавь(Обходчик!(З) обх)
    {
        бцел пропущен;
        return добавь(обх, пропущен);
    }

    /**
     *Добавляет все значения из итератора в набор.
     *
     * Возвращает число добавленных элементов.
     */
    ТипМассивМультинабор добавь(Обходчик!(З) обх, ref бцел чло_добавленных)
    {
        бцел исхдлина = длина;
        foreach(з; обх)
            добавь(з);
        чло_добавленных = длина - исхдлина;
        return this;
    }

    /**
     * Добавляет все значения из заданного массива в набор.
     *
     * Возвращает число добавленных элементов.
     */
    ТипМассивМультинабор добавь(З[] массив)
    {
        бцел пропущен;
        return добавь(массив, пропущен);
    }

    /**
     * Добавляет все значения из заданного массива в набор.
     *
     * Возвращает число добавленных элементов.
     */
    ТипМассивМультинабор добавь(З[] массив, ref бцел чло_добавленных)
    {
        бцел исхдлина = длина;
        foreach(з; массив)
            добавь(з);
        чло_добавленных = длина - исхдлина;
        return this;
    }

    /**
     *Посчитать число случаев з<начения>
     *
     * Выполняется за O(n) раз.
     */
    бцел счёт(З з)
    {
        бцел возврзнач = 0;
        foreach(x; this)
            if(з == x)
                возврзнач++;
        return возврзнач;
    }

    /**
     * Удалить все случаи з<начения>.  Возвращаает число экземпляров, которые
     * были удалены.
     *
     * Выполняется за O(n) раз.
     */
    ТипМассивМультинабор удалиВсе(З з)
    {
        бцел пропущен;
        return удалиВсе(з, пропущен);
    }
    /**
     * Удалить все случаи з<начения>.  Возвращаает число экземпляров, которые
     * были удалены.
     *
     * Выполняется за O(n) раз.
     */
    ТипМассивМультинабор удалиВсе(З з, ref бцел чло_Удалённых)
    {
        бцел исхдлина = длина;
        foreach(ref dp, x; &очистить)
        {
            dp = cast(бул)(з == x);
        }
        чло_Удалённых = исхдлина - длина;
        return this;
    }

    /**
     * Дублировать этот контейнер.  Это не делает "глубокую" копию
     * элементов.
     */
    ТипМассивМультинабор dup()
    {
        auto возврзнач = new ТипМассивМультинабор(_growSize);
        узел n = _голова.следщ;
        while(n !is _голова)
        {
            узел x;
            if(n.значение.length == _growSize)
                x = возврзнач.размести(n.значение.dup);
            else
            {
                auto массив = new З[_growSize];
                массив.length = n.значение.length;
                массив[0..$] = n.значение[];
                x = возврзнач.размести(массив);
            }
            возврзнач._голова.приставь(x);
        }
        возврзнач._счёт = _счёт;
        return возврзнач;
    }

    /**
     * Даёт наиболее подходящий элемент из набора.  * Это элемент, который
     *должен итерироваться первым.  Следовательно, вызов удали(дай())
     * гарантировано меньше, чем операция O(n).
     */
    З дай()
    {
        return начало.значение;
    }

    /**
     *Удалить наиболее подходящий элемент из набора, и вернуть его значение.
     * Это равносильно удали(дай()), только лишь один поиск
     * выполняется.
     */
    З изыми()
    {
        auto c = начало;
        auto возврзнач = c.значение;
        удали(c);
        return возврзнач;
    }
}

version(UnitTest)
{
    void main()
    {
        auto ms = new МассивМультинабор!(бцел);
        ms.добавь([0U, 1, 2, 3, 4, 5]);
        assert(ms.length == 6);
        ms.удали(1);
        assert(ms.length == 5);
        assert(ms._голова.следщ.значение == [0U, 5, 2, 3, 4]);
        foreach(ref бул очистить_ли, бцел з; &ms.очистить)
            очистить_ли = (з % 2 == 1);
        assert(ms.length == 3);
        assert(ms._голова.следщ.значение == [0U, 4, 2]);
    }
}
