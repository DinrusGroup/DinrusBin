/*********************************************************
   Авторское право: (C) 2008 принадлежит Steven Schveighoffer.
              Все права защищены

   Лицензия: $(LICENSE)

**********************************************************/
module col.ArrayList;
public import col.model.List,
       col.model.Keyed;
	   
/+ ИНТЕРФЕЙС:

class МассивСписок(З) : СКлючом!(бцел, З), Список!(З) 
{
    private З[] _массив;
    private бцел _изменение;
    private МассивСписок!(З) _родитель;
    private МассивСписок!(З) _предок;

    final цел очистить(цел delegate(ref бул удалить_ли, ref З значение) дг);
    final цел чисть_ключ(цел delegate(ref бул удалить_ли, ref бцел ключ, ref З значение) дг);
    struct курсор
		{
			private З *укз;		alias укз ptr;

			З значение();
			З значение(З з);
			курсор opPostInc();
			курсор opPostDec();
			курсор opAddAssign(цел прир);
			курсор opSubAssign(цел прир);
			курсор opAdd(цел прир);
			курсор opSub(цел прир);
			цел opSub(курсор обх);
			цел opCmp(курсор обх);
			бул opEquals(курсор обх);
		}
	
    this();
    this(З[] хранилище);
    МассивСписок!(З) очисти();
    бцел длина();
    курсор начало();
    курсор конец();;
    курсор удали(курсор старт, курсор последн);
    курсор удали(курсор элт);
    МассивСписок!(З) удали(З з, ref бул был_Удалён);
    МассивСписок!(З) удали(З з);
    курсор найди(курсор обх, З з);
    курсор найди(З з);
    бул содержит(З з);
    МассивСписок!(З) удалиПо(бцел ключ, ref бул был_Удалён);
    МассивСписок!(З) удалиПо(бцел ключ);
    З opIndex(бцел ключ);
    З opIndexAssign(З значение, бцел ключ);
    МассивСписок!(З) установи(бцел ключ, З значение, ref бул был_добавлен);
    МассивСписок!(З) установи(бцел ключ, З значение);
    цел opApply(цел delegate(ref З значение) дг);
    цел opApply(цел delegate(ref бцел ключ, ref З значение) дг);
    бул имеетКлюч(бцел ключ);
    МассивСписок!(З) добавь(З з, ref бул был_добавлен);
    МассивСписок!(З) добавь(З з);
    МассивСписок!(З) добавь(Обходчик!(З) колл);
    МассивСписок!(З) добавь(Обходчик!(З) колл, ref бцел чло_добавленных);
    МассивСписок!(З) добавь(З[] массив);
    МассивСписок!(З) добавь(З[] массив, ref бцел чло_добавленных);
    МассивСписок!(З) opCatAssign(Список!(З) rhs);
    МассивСписок!(З) opCatAssign(З[] массив);
    МассивСписок!(З) opCat(Список!(З) rhs);
    МассивСписок!(З) opCat(З[] массив);
    МассивСписок!(З) opCat_r(З[] массив); 
    бцел счёт(З з);
    МассивСписок!(З) удалиВсе(З з, ref бцел чло_Удалённых);
    МассивСписок!(З) удалиВсе(З з);
    МассивСписок!(З) opSlice(бцел b, бцел e);
    МассивСписок!(З) opSlice(курсор b, курсор e);
    МассивСписок!(З) dup();
    З[] какМассив();
    цел opEquals(Объект o);
    цел opEquals(З[] массив);
    З фронт();
    З тыл();
    З возьмиФронт();
    З возьмиТыл();
    бцел индексУ(З з);

    class ОсобоеИнфОТипе(бул использоватьФункцию) : ИнфОТипе
    {
        static if(использоватьФункцию)
            alias цел function(ref З v1, ref З v2) ФункцСравнения;
        else
            alias цел delegate(ref З v1, ref З v2) ФункцСравнения;
        private ФункцСравнения cf;
        private ИнфОТипе производныйОт;
		
        this(ИнфОТипе производныйОт, ФункцСравнения comp);
        override hash_t дайХэш(ук p);
        override цел equals(ук p1, ук p2);
        override цел сравни(ук p1, ук p2);
        override size_t tsize();
        override проц swap(ук p1, ук p2);
        override ИнфОТипе следщ();
        override проц[] init();
        override бцел flags();
        override OffsetTypeInfo[] offTi();
	}
	МассивСписок сортируй(цел delegate(ref З v1, ref З v2) comp);
	МассивСписок сортируй(цел function(ref З v1, ref З v2) comp);
	МассивСписок сортируй();
	
}
+/
//=================================================================

private struct Array
{
    цел length;
    ук ptr;
}

private extern (C) дол _adSort(Array arr, ИнфОТипе иот);

/***
 * Как обёртка массиву, этот класс обеспечивает необходимую реализацию
 * интерфейса Список (Список)
 *
 * Добавление или удаление любых элементов делает недействительными все курсоры.
 *
 * Класс служит шлюзом между встроенными массивами и классами этого пакета.
 * Можно строить МассивСписок с помощью встроенного массива, в качестве
 * средства сохранения, и получать доступ к этому МассивСписку  с помощью функции какМассив.
 * Копии массива не делается, поэтому можно продолжать использовать
 * массив в обеих формах.
 */
class МассивСписок(З) : СКлючом!(бцел, З), Список!(З) 
{
    private З[] _массив;
    private бцел _изменение;
    //
    // Примечание о родителе и предке.  Родитель - это массив, список
    // является срезом которого.Предок - высший родитель в
    // линейке.  Если добавлен срез, обх создаёт свой собственный массив, и
    // становится его собственным предком.  Он уже больше не в линейке.  Однако мы
    // не устанавливаем родитель в пусто, так как обх  необходим для любых срезов, которые
    //были подсрезами этого среза.  Таковые не должны инвалидироваться,  и они
    //должны иметь цепь с предком.  Когда добавляются данные к срезу,
    // обх становится пустой ссылкой в исходной цепочке линейности.
    //
    private МассивСписок!(З) _родитель;
    private МассивСписок!(З) _предок;

    /**
     *итерирует по элементам в МассивСписок, сообщая обх, которые из них
     * следует удалить
     *
     * Используйте таким образом:
     *
     * -------------
     * // удалить все нечётныеэлементы
     * foreach(ref удалить_ли, з; &arrayList.очистить)
     * {
     *   удалить_ли = (з & 1) != 0;
     * }
     * ------------
     */
    final цел очистить(цел delegate(ref бул удалить_ли, ref З значение) дг)
    {
        return _примени(дг, _начало, _конец);
    }

    /**
     *итерирует по элементам в МассивСписок, сообщая обх, которые из них
     * следует удалить.
     *
     * Используйте таким образом:
     * -------------
     * // удалить все нечётные индексы
     * foreach(ref удалить_ли, к, з; &arrayList.очистить)
     * {
     *   удалить_ли = (к & 1) != 0;
     * }
     * ------------
     */
    final цел чисть_ключ(цел delegate(ref бул удалить_ли, ref бцел ключ, ref З значение) дг)
    {
        return _примени(дг, _начало, _конец);
    }

    /**
     * Курсор массива точно как и указатель на массив.  Они лишь
     * различаются между курсором МассивСписок и указателем тем, что
     * курсор МассивСписок предоставляет свойство значение, которое общее
     * для всего пакета коллекций.
     *
     *Все операции над курсором это O(1)
     */
    struct курсор
    {
        private З *укз;		alias укз ptr;
        
        /**
         * даёт значение, на которое указывает
         */
        З значение()
        {
            return *укз;
        }

        /**
         * устанавливает значение, на которое указывает
         */
        З значение(З з)
        {
            return (*укз = з);
        }

        /**
         * увеличивает этот курсор this, возвращая тот, который был до
         * этого.
         */
        курсор opPostInc()
        {
            курсор врм = *this;
            укз++;
            return врм;
        }

        /**
         * уменьшает this курсор,  возвращая тот, что был до
         * декрементации.
         */
        курсор opPostDec()
        {
            курсор врм = *this;
            укз--;
            return врм;
        }

        /**
         * Увеличивает курсор на указанное количество.
         */
        курсор opAddAssign(цел прир)
        {
            укз += прир;
            return *this;
        }

        /**
         * Уменьшает курсор на заданное значение.
         */
        курсор opSubAssign(цел прир)
        {
            укз -= прир;
            return *this;
        }

        /**
         * возвращает курсор, то есть элементы прир за курсором this.
         */
        курсор opAdd(цел прир)
        {
            курсор рез = *this;
            рез.ptr += прир;
            return рез;
        }

        /**
         * * возвращает курсор, то есть элементы прир перед курсором this.
         */
        курсор opSub(цел прир)
        {
            курсор рез = *this;
            рез.ptr -= прир;
            return рез;
        }

        /**
         * возвращает число элементов между this курсор и заданным
         * курсор.  Если обх указывает на поздний элемент, то рез отрицательный.
         */
        цел opSub(курсор обх)
        {
            return укз - обх.ptr;
        }

        /**
         * сравнить два курсора.
         */
        цел opCmp(курсор обх)
        {
            if(укз < обх.ptr)
                return -1;
            if(укз > обх.ptr)
                return 1;
            return 0;
        }

        /**
         * сравнить два курсора на равенство.
         */
        бул opEquals(курсор обх)
        {
            return укз is обх.ptr;
        }
    }

    /**
     * создать новый пустой МассивСписок
     */
    this()
    {
        _предок = this;
        _родитель = пусто;
    }

    /**
     * Использовать какой-л. массив, как резервное хранилище.  Этим не дублируется сам
     * массив.  Используйте новый МассивСписок(хранилище.dup) , чтобы сделать отдельную копию.
     */
    this(З[] хранилище)
    {
        this();
        _массив = хранилище;
    }

    private this(МассивСписок!(З) родитель, курсор s, курсор e)
    {
        _родитель = родитель;
        _предок = родитель._предок;
        _изменение = родитель._изменение;
        проверьИзменение();
        бцел ib = s - родитель._начало;
        бцел ie = e - родитель._начало;
        _массив = родитель._массив[ib..ie];
    }

    /**
     * очистить этот контейнер от всех значений
     */
    МассивСписок!(З) очисти()
    {
        if(предок_ли)
        {
            _массив = пусто;
            _изменение++;
        }
        else
        {
            удали(_начало, _конец);
        }
        return this;
    }

    /**
     * возвращает число элементов в коллекции
     */
    бцел длина()
    {
        проверьИзменение();
        return _массив.length;
    }

	alias длина length;
    /**
     * возвращает курсор, указывающий на первый элемент в этом списке.
     */
    курсор начало()
    {
        проверьИзменение();
        return _начало;
    }

    private курсор _начало()
    {
        курсор обх;
        обх.ptr = _массив.ptr;
        return обх;
    }

    /**
     * вернуть курсор, указывающий сразу после последн элемента в
     * списка.
     */
    курсор конец()
    {
        проверьИзменение();
        return _конец;
    }

    private курсор _конец()
    {
        курсор обх;
        обх.ptr = _массив.ptr + _массив.length;
        return обх;
    }


    private цел _примени(цел delegate(ref бул, ref бцел, ref З) дг, курсор старт, курсор последн)
    {
        return _примени(дг, старт, последн, _начало);
    }

    private цел _примени(цел delegate(ref бул, ref бцел, ref З) дг, курсор старт, курсор последн, курсор ссылка)
    {
        цел возврдг;
        if(предок_ли)
        {
            курсор i = старт;
            курсор следщХор = старт;
            курсор конссыл = _конец;

            бул удалить_ли;

            //
            // цикл перед удалением
            //
            for(; возврдг == 0 && i != последн; i++, следщХор++)
            {
                удалить_ли = нет;
                бцел ключ = i - ссылка;
                if((возврдг = дг(удалить_ли, ключ, *i.ptr)) == 0)
                {
                    if(удалить_ли)
                    {
                        //
                        // первое удаление
                        //
                        _изменение++;
                        i++;
                        break;
                    }
                }
            }

            //
            // цикл после первого удаления
            //
            if(следщХор != i)
            {
                for(; i < конссыл; i++, следщХор++)
                {
                    удалить_ли = нет;
                    бцел ключ = i - ссылка;
                    if(i >= последн || возврдг != 0 || (возврдг = дг(удалить_ли, ключ, *i.ptr)) != 0)
                    {
                        //
                        //  дг больше не вызывается
                        //
                        следщХор.значение = i.значение;
                    }
                    else if(удалить_ли)
                    {
                        //
                        // дг запросил удаление
                        //
                        следщХор--;
                    }
                    else
                    {
                        //
                        // дг не запрашивает удаления
                        //
                        следщХор.значение = i.значение;
                    }
                }
            }

            //
            // укоротить длину
            //
            if(следщХор != конссыл)
            {
                _массив.length = следщХор - _начало;
                return конссыл - следщХор;
            }
        }
        else
        {
            //
            // использовать предок для выполнения применения, затен настроить массив
            // соответственно.
            //
            проверьИзменение();
            auto p = следщРодитель;
            auto оригДлина = p._массив.length;
            возврдг = p._примени(дг, старт, последн, _начало);
            auto чло_Удалённых = оригДлина - p._массив.length;
            if(чло_Удалённых > 0)
            {
                _массив = _массив[0..$-чло_Удалённых];
                _изменение = _предок._изменение;
            }
        }
        return возврдг;
    }

    private цел _примени(цел delegate(ref бул, ref З) дг, курсор старт, курсор последн)
    {
        цел _дг(ref бул b, ref бцел к, ref З з)
        {
            return дг(b, з);
        }
        return _примени(&_дг, старт, последн);
    }

    private проц проверьИзменение()
    {
        if(_изменение != _предок._изменение)
            throw new Искл("underlying МассивСписок changed");
    }

    private бул предок_ли()
    {
        return _предок is this;
    }

    //
    // Получить следщ родитель в линейке.  Пропустить всех родителей, которые не
    // разделяют нашего предка, они больше не часть линейки.
    //
    private МассивСписок!(З) следщРодитель()
    {
        auto возврзнач = _родитель;
        while(возврзнач._предок !is _предок)
            возврзнач = возврзнач._родитель;
        return возврзнач;
    }

    /**
     * удалить все элементы из старт до последн, за исключением элемент,
     * на который указывает последн.  Возвращает  действительный курсор, который указывает на
     * элемент, указанный последн .
     *
     * Выполняется за O(n) раз.
     */
    курсор удали(курсор старт, курсор последн)
    {
        if(предок_ли)
        {
            цел проверь(ref бул b, ref З)
            {
                b = true;
                return 0;
            }
            _примени(&проверь, старт, последн);
        }
        else
        {
            проверьИзменение();
            следщРодитель.удали(старт, последн);
            _массив = _массив[0..($ - (последн - старт))];
            _изменение = _предок._изменение;
        }
        return старт;
    }

    /**
     * удалить элемент, на который указал элт.  Эквивалентно удали(элт, элт
     * + 1).
     *
     * * Выполняется за O(n) раз.
     */
    курсор удали(курсор элт)
    {
        return удали(элт, элт + 1);
    }

    /**
     * удалить элемент со специфичным значением.  Это  O(n)
     * операция.  Если в  коллекции есть экземпляры дубликатов, то первый
     * элемент, который совпадает, удаляется.
     *
     * возвращает this.
     *
     *Устанавливает  был_Удалён в да, если элемент существовал и был удалён.
     */
    МассивСписок!(З) удали(З з, ref бул был_Удалён)
    {
        auto обх = найди(з);
        if(обх == _конец)
            был_Удалён = нет;
        else
        {
            удали(обх);
            был_Удалён = да;
        }
        return this;
    }

    /**
     * удалить элемент со специфичным значением.  Это  O(n)
     * операция.  Если в  коллекции есть экземпляры дубликатов, то первый
     * элемент, который совпадает, удаляется.
     *
     * возвращает this.
     */
    МассивСписок!(З) удали(З з)
    {
        бул пропущен;
        return удали(з, пропущен);
    }

    /**
     * то же что найди(з), но старт с указанной позиции.
     */
    курсор найди(курсор обх, З з)
    {
        return _найди(обх, _конец, з);
    }

    // то же что найди(з), но ищет только в заданном диапазоне с заданной позиции.
    private курсор _найди(курсор обх, курсор последн,  З з)
    {
        проверьИзменение();
        while(обх < последн && обх.значение != з)
            обх++;
        return обх;
    }

    /**
     * найти первый случай элемента в списке.  Выполняется за O(n)
     * раз.
     */
    курсор найди(З з)
    {
        return _найди(_начало, _конец, з);
    }

    /**
     * возвращает да, если коллекция содержит значение.  Выполняется за O(n) раз.
     */
    бул содержит(З з)
    {
        return найди(з) < _конец;
    }

    /**
     * удалить элемент по указанному индексу.  Выполняется за O(n) раз.
     */
    МассивСписок!(З) удалиПо(бцел ключ, ref бул был_Удалён)
    {
        if(ключ > длина)
        {
            был_Удалён = нет;
        }
        else
        {
            удали(_начало + ключ);
            был_Удалён = да;
        }
        return this;
    }

    /**
     * удалить элемент по указанному индексу.  Выполняется за O(n) раз.
     */
    МассивСписок!(З) удалиПо(бцел ключ)
    {
        бул пропущен;
        return удалиПо(ключ, пропущен);
    }

    /**
     * получить  значение по указаному индексу.
     */
    З opIndex(бцел ключ)
    {
        проверьИзменение();
        return _массив[ключ];
    }

    /**
     * установить значение по указанному индексу.
     */
    З opIndexAssign(З значение, бцел ключ)
    {
        проверьИзменение();
        //
        // не меняет мутация так как 
        return _массив[ключ] = значение;
    }

    /**
     * установить значение по указанному индексу
     */
    МассивСписок!(З) установи(бцел ключ, З значение, ref бул был_добавлен)
    {
        this[ключ] = значение;
        был_добавлен = false;
        return this;
    }

    /**
     * установить значение по указанному индексу
     */
    МассивСписок!(З) установи(бцел ключ, З значение)
    {
        this[ключ] = значение;
        return this;
    }

    /**
     * итерировать по коллекции
     */
    цел opApply(цел delegate(ref З значение) дг)
    {
        цел возврзнач;
        курсор конссыл = конец; // call проверьmutation
        for(курсор i = _начало; i != конссыл; i++)
        {
            if((возврзнач = дг(*i.ptr)) != 0)
                break;
        }
        return возврзнач;
    }

    /**
     * итерировать по коллекции с ключ и значение
     */
    цел opApply(цел delegate(ref бцел ключ, ref З значение) дг)
    {
        цел возврзнач = 0;
        auto ссылка = начало; // вызов проверьМутацию
        auto конссыл = _конец;
        for(курсор i = ссылка; i != конссыл; i++)
        {
            бцел ключ = i - ссылка;
            if((возврзнач = дг(ключ, *i.ptr)) != 0)
                break;
        }
        return возврзнач;
    }

    /**
     * возвращает да, если данный индекс действителен
     *
     * * * Выполняется за O(1) раз.
     */
    бул имеетКлюч(бцел ключ)
    {
        return ключ < длина;
    }

    /**
     * добавить данное значение в конец списка.  Всегда возвращает да.
     */
    МассивСписок!(З) добавь(З з, ref бул был_добавлен)
    {
        //
        // поставить в этот массив.  Переустановить предок на this, так как теперь мы
        //имеем дело с новым массивом.
        //
        if(предок_ли)
        {
            _массив ~= з;
            _изменение++;
        }
        else
        {
            _предок = this;
            //
            // гарантировать, что мы не делали недавно поставь.
            //
            _массив = _массив ~ з;

            //
            //нет нужды менять мутация, мы - новый предок.
            //
        }

        // всегда успешно
        был_добавлен = да;
        return this;
    }

    /**
     * добавить данное значение в конец списка.
     */
    МассивСписок!(З) добавь(З з)
    {
        бул пропущен;
        return добавь(з, пропущен);
    }

    /**
     * добавляет все элементы из данного обходчика в конец списка.
     */
    МассивСписок!(З) добавь(Обходчик!(З) колл)
    {
        бцел пропущен;
        return добавь(колл, пропущен);
    }

    /**
     * добавляет все элементы из данного обходчика в конец списка.
     */
    МассивСписок!(З) добавь(Обходчик!(З) колл, ref бцел чло_добавленных)
    {
        auto al = cast(МассивСписок!(З))колл;
        if(al)
        {
            //
            // оптимизированный случай
            //
            return добавь(al._массив, чло_добавленных);
        }

        //
        // генерный случай
        //
        проверьИзменение();
        чло_добавленных = колл.length;
        if(чло_добавленных != cast(бцел)-1)
        {
            if(чло_добавленных > 0)
            {
                цел i = _массив.length;
                if(предок_ли)
                {
                    _массив.length = _массив.length + чло_добавленных;
                }
                else
                {
                    _предок = this;
                    auto нов_массив = new З[_массив.length + чло_добавленных];
                    нов_массив[0.._массив.length] = _массив[];

                }
                foreach(з; колл)
                    _массив [i++] = з;
                _изменение++;
            }
        }
        else
        {
            auto исхдлина = _массив.length;
            бул firstdone = false;
            foreach(з; колл)
            {
                if(!firstdone)
                {
                    //
                    // трюк для получения firstdone установленным в да, так как был_добавлен
                    // всегда установлено в да.
                    //
                    добавь(з, firstdone);
                }
                else
                    _массив ~= з;
            }
            чло_добавленных = _массив.length - исхдлина;
        }
        return this;
    }


    /**
     * аппендирует массив в конец списка
     */
    МассивСписок!(З) добавь(З[] массив)
    {
        бцел пропущен;
        return добавь(массив, пропущен);
    }

    /**
     * аппендирует массив в конец списка
     */
    МассивСписок!(З) добавь(З[] массив, ref бцел чло_добавленных)
    {
        проверьИзменение();
        чло_добавленных = массив.length;
        if(массив.length)
        {
            if(предок_ли)
            {
                _массив ~= массив;
                _изменение++;
            }
            else
            {
                _предок = this;
                _массив = _массив ~ массив;
            }
        }
        return this;
    }

    /**
     * поставить другой список в конец этого списка
     */
    МассивСписок!(З) opCatAssign(Список!(З) rhs)
    {
        return добавь(rhs);
    }

    /**
     * поставить массив в конец этого списка
     */
    МассивСписок!(З) opCatAssign(З[] массив)
    {
        return добавь(массив);
    }

    /**
     * возвращает конкатенацию списка массива с другим списком.
     */
    МассивСписок!(З) opCat(Список!(З) rhs)
    {
        return dup.добавь(rhs);
    }

    /**
     * возвращает конкатенацию списка массива с каким-либо массивом.
     */
    МассивСписок!(З) opCat(З[] массив)
    {
        проверьИзменение();
        return new МассивСписок!(З)(_массив ~ массив);
    }

    /**
     * возвращает конкатенацию списка массива с каким-либо массивом.
     */
    МассивСписок!(З) opCat_r(З[] массив)
    {
        проверьИзменение();
        return new МассивСписок!(З)(массив ~ _массив);
    }

    /**
     * возвращает число экземпляров  значения данного элемента
     *
     * Выполняется за O(n) раз.
     */
    бцел счёт(З з)
    {
        бцел экземпляры = 0;
        foreach(x; this)
            if(з == x)
                экземпляры++;
        return экземпляры;
    }

    /**
     * удаляет все экземпляры значения данного элемента
     *
     * Выполняется за O(n) раз.
     */
    МассивСписок!(З) удалиВсе(З з, ref бцел чло_Удалённых)
    {
        auto оригДлина = длина;
        foreach(ref b, x; &очистить)
        {
            b = cast(бул)(x == з);
        }
        чло_Удалённых = длина - оригДлина;
        return this;
    }

    /**
     * удаляет все экземпляры значения данного элемента
     *
     * Выполняется за O(n) раз.
     */
    МассивСписок!(З) удалиВсе(З з)
    {
        бцел пропущен;
        return удалиВсе(з, пропущен);
    }

    /**
     *Возвращает срез массива списка.  Срез можно использовать для просмотра
     * элементов, удаления элементов, не не для добавления элементов.
     *
     * Возвращаемый срез начинается с индекса b, и заканчивается, но не включает его, на
     * индекс e.
     */
    МассивСписок!(З) opSlice(бцел b, бцел e)
    {
        return opSlice(_начало + b, _начало + e);
    }

    /**
     * Срез массива, заданного курсорами
     */
    МассивСписок!(З) opSlice(курсор b, курсор e)
    {
        if(e > конец || b < _начало) // вызывает один раз проверьИзменение
            throw new Искл("значение среза вне диапазона");

        //
        //сделать список массива, являющийся срезом массива данного списка
        //
        return new МассивСписок!(З)(this, b, e);
    }

    /**
     * Возвращает копию списка массива
     */
    МассивСписок!(З) dup()
    {
        return new МассивСписок!(З)(_массив.dup);
    }

    /**
     * получить массив, который представлен этим массивом.  Это НЕ копия
     * данных, поэтому изменение элементов этого массива изменит элементы
     * исходного МассивСписок.  Аппендирование элементов из этого массива не повлияет
     * на список исходного массива, как и аппендинг к любому массиву не вляет на
     * его оригинал.
     */
    З[] какМассив()
    {
        return _массив;
    }

    /**
     * оператор для сравнения двух объектов.
     *
     * Если o некий Список!(З), то происходит сравнение списков.
     * Если o is пусто или не МассивСписок, то возвратное значение равно 0.
     */
    цел opEquals(Объект o)
    {
        if(o !is пусто)
        {
            auto li = cast(Список!(З))o;
            if(li !is пусто && li.length == длина)
            {
                auto al = cast(МассивСписок!(З))o;
                if(al !is пусто)
                    return _массив == al._массив;
                else
                {
                    цел i = 0;
                    foreach(элт; li)
                    {
                        if(элт != _массив[i++])
                            return 0;
                    }

                    //
                    // равно
                    //
                    return 1;
                }
            }

        }
        //
        // сравнение невозможно.
        //
        return 0;
    }

    /**
     * Сравнить с З массив.
     *
     * эквивалентно какМассив == массив.
     */
    цел opEquals(З[] массив)
    {
        return _массив == массив;
    }

    /**
     *  Посмотреть элемент в фронт этого МассивСписок.
     */
    З фронт()
    {
        return начало.значение;
    }

    /**
     * Посмотреть элемент в конце этого МассивСписок.
     */
    З тыл()
    {
        return (конец - 1).значение;
    }

    /**
     * Удалить элемент в начале этого МассивСписок и вернуть его значение.
     * Это операция O(n) .
     */
    З возьмиФронт()
    {
        auto c = начало;
        auto возврзнач = c.значение;
        удали(c);
        return возврзнач;
    }

    /**
     * * Удалить элемент в конце этого МассивСписок и вернуть его значение.
     * Может быть операцией O(n).
     */
    З возьмиТыл()
    {
        auto c = конец - 1;
        auto возврзнач = c.значение;
        удали(c);
        return возврзнач;
    }

    /**
     * Получить индекс определённого значения.  Эквивалентно найди(з) - начало.
     *
     * Если значения ещё нет в коллекции, то возвращается длина.
     */
    бцел индексУ(З з)
    {
        return найди(з) - начало;
    }

    class ОсобоеИнфОТипе(бул использоватьФункцию) : ИнфОТипе
    {
        static if(использоватьФункцию)
            alias цел function(ref З v1, ref З v2) ФункцСравнения;
        else
            alias цел delegate(ref З v1, ref З v2) ФункцСравнения;
        private ФункцСравнения cf;
        private ИнфОТипе производныйОт;
        this(ИнфОТипе производныйОт, ФункцСравнения comp)
        {
            this.производныйОт = производныйОт;
            this.cf = comp;
        }

        /// Возвращает хэш экземпляра типа.
        override hash_t дайХэш(ук p) { return производныйОт.дайХэш(p); }

        ///  Сравнивает два экземпляра на равенство.
        override цел equals(ук p1, ук p2) { return производныйОт.equals(p1, p2); }

        /// Сравнивает два экземпляра на &lt;, ==, или &gt;.
        override цел сравни(ук p1, ук p2)
        {
            return cf(*cast(З *)p1, *cast(З *)p2);
        }

        /// Возвращает размер типа.
        override size_t tsize() { return производныйОт.tsize(); }

        /// Меняет местами экземпляры типа.
        override проц swap(ук p1, ук p2)
        {
            return производныйОт.swap(p1, p2);
        }

        /// Получить ИнфОТипе типа или 'следщ', как определено родом типа this,
        /// пусто, если нет.
        override ИнфОТипе следщ() { return производныйОт; }

        /// Вернёт инициализатор по умолчанию, и пусто, если дефолт инициализирован в 0
        override проц[] init() { return производныйОт.init(); }

        /// Получить флаги для типа: 1 значит, что СМ должен сканировать на указатели
        override бцел flags() { return производныйОт.flags(); }

        /// Получить типовую инфрмацию на содержимое типа; пусто, если её нет
        override OffsetTypeInfo[] offTi() { return производныйОт.offTi(); }
    }

    /**
     * Сортировать в соответствии с заданной функцией сравнения
     */
    МассивСписок сортируй(цел delegate(ref З v1, ref З v2) comp)
    {
        //
        // реально нельзя выполнить этого без помощи внешней библиотеки.  К счастью,
        //функция сортировки массива всегда определена рантаймом.  Мы
        //просто должны иметь доступ к обх.  Однако, обх требует, чтобы ему передали
        // структуру ИнфОТипе, чтобы выполнить всю грязную работу.  Что нам надо, это
        //производную реальной структуры ИнфОТипе с функцией сравнения
        // переписанную на вызов функции comp.
        //
        //scope ОсобоеИнфОТипе!(typeof(typeid(З))) sti = new ОсобоеИнфОТипе(comp);
        scope sti = new ОсобоеИнфОТипе!(false)(typeid(З), comp);
        цел x;
        Array ar;
        ar.length = _массив.length;
        ar.ptr = _массив.ptr;
        _adSort(ar, sti);
        return this;
    }

    /**
     * Сортировать в соответствии с заданной функцией сравнения
     */
    МассивСписок сортируй(цел function(ref З v1, ref З v2) comp)
    {
        //
        // реально нельзя выполнить этого без помощи внешней библиотеки.  К счастью,
        //функция сортировки массива всегда определена рантаймом.  Мы
        //просто должны иметь доступ к обх.  Однако, обх требует, чтобы ему передали
        // структуру ИнфОТипе, чтобы выполнить всю грязную работу.  Что нам надо, это
        //производную реальной структуры ИнфОТипе с функцией сравнения
        // переписанную на вызов функции comp.
        //
        //scope ОсобоеИнфОТипе!(typeof(typeid(З))) sti = new ОсобоеИнфОТипе(comp);
        scope sti = new ОсобоеИнфОТипе!(true)(typeid(З), comp);
        цел x;
        Array ar;
        ar.length = _массив.length;
        ar.ptr = _массив.ptr;
        _adSort(ar, sti);
        return this;
    }

    /**
     * Сортировать согласно функции сравнения по умолчанию для З<начения>
     */
    МассивСписок сортируй()
    {
        _массив.sort;
        return this;
    }
}

version(UnitTest)
{
    void main()
    {
        auto al = new МассивСписок!(бцел);
        al.добавь([0U, 1, 2, 3, 4, 5]);
        assert(al.length == 6);
        al.добавь(al[0..3]);
        assert(al.length == 9);
        foreach(ref бул dp, бцел инд, бцел знач; &al.чисть_ключ)
            dp = (знач % 2 == 1);
        assert(al.length == 5);
        assert(al == [0U, 2, 4, 0, 2]);
        assert(al == new МассивСписок!(бцел)([0U, 2, 4, 0, 2].dup));
        assert(al.начало.ptr is al.какМассив.ptr);
        assert(al.конец.ptr is al.какМассив.ptr + al.length);
    }
}
