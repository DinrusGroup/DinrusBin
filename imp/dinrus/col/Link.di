/*********************************************************
   Авторское право: (C) 2008 принадлежит Steven Schveighoffer.
              Все права защищены

   Лицензия: $(LICENSE)

**********************************************************/
module col.Link;

private import col.DefaultAllocator;

/+ ИНТЕРФЕЙС:


struct Связка(З)
{
    alias Связка *Узел;
    Узел следщ;
    Узел предш;
    З значение;
    Узел приставь(Узел n);
    Узел поставь(Узел n);
    Узел открепи();
    static проц крепи(Узел первый, Узел второй);
    бцел счёт(Узел концУзел = null);
    Узел dup(Узел delegate(З з) функцияСоздать);
    Узел dup();
}

struct ГоловаСвязки(З, alias Разместитель=ДефолтныйРазместитель)
{

    alias Связка!(З).Узел Узел;
    alias Разместитель!(Связка!(З)) разместитель;
    разместитель разм;
    Узел конец;
    бцел счёт;
    Узел начало();
    проц установка();
    Узел удали(Узел n);
    проц сортируй(Сравниватель)(Сравниватель comp);
    Узел удали(Узел первый, Узел последн);
    Узел вставь(Узел перед, З з);
    проц очисти();
    проц копируйВ(ref ГоловаСвязки цель, бул копироватьУзлы=true);
    private Узел размести();
    private Узел размести(З з);
}

+/

/**
 * Linked-list узел that is используется in various collection classes.
 */
struct Связка(З)
{
    /**
     * алиас для удобства
     */
    alias Связка *Узел;
    Узел следщ;
    Узел предш;

    /**
     * Значение, представляемое данным линкованным Узлом.
     */
    З значение;

    /**
     * Вставит заданный узел между this узел и предш.  Это обновит все
     * указатели на this, n и предш.
     *
     * Возвращает this, чтобы дать возможность создания цепочки.
     */
    Узел приставь(Узел n)
    {
        крепи(предш, n);
        крепи(n, this);
        return this;
    }

    /**
     * Вставит указанный Узел  между this Узел и следщ.  Это обновит все
     * указатели на this, n и следщ.
     *
     * Возвращает this, чтобы дать возможность создания цепочки.
     */
    Узел поставь(Узел n)
    {
        крепи(n, следщ);
        крепи(this, n);
        return this;
    }

    /**
     * Удалить  this Узел из списка.  If предш или следщ  не пустоl, их
     * указатели обновляются.
     *
     * Возвращает this, чтобы дать возможность создания цепочки.
     */
    Узел открепи()
    {
        крепи(предш, следщ);
        следщ = предш = пусто;
        return this;
    }

    /**
     * Сцепить вместе два узла.
     */
    static проц крепи(Узел первый, Узел второй)
    {
        if(первый)
            первый.следщ = второй;
        if(второй)
            второй.предш = первый;
    }

    /**
     * Посчитать, сколько узлов до концУзел.
     */
    бцел счёт(Узел концУзел = пусто)
    {
        Узел x = this;
        бцел c = 0;
        while(x !is концУзел)
        {
            x = x.следщ;
            c++;
        }
        return c;
    }

    Узел dup(Узел delegate(З з) функцияСоздать)
    {
        //
        // создать дубликат this и всех узлов после this.
        //
        auto n = следщ;
        auto возврзнач = функцияСоздать(значение);
        auto тек = возврзнач;
        while(n !is пусто && n !is this)
        {
            auto x = функцияСоздать(n.значение);
            крепи(тек, x);
            тек = x;
            n = n.следщ;
        }
        if(n is this)
        {
            //
            // циркулярный список, завершает цикл
            //
            крепи(тек, возврзнач);
        }
        return возврзнач;
    }

    Узел dup()
    {
        Узел _создай(З з)
        {
            auto n = new Связка!(З);
            n.значение = з;
            return n;
        }
        return dup(&_создай);
    }
}

/**
 * Эта структура использует Связка(З) для отслежки значений линк-списка.
 *
 * В реализации используется dummy link узел, который заменяет голову и хвост
 * списка.  Базово список циркулярен, с dummy узел, помечающим
 * конец/начало.
 */
struct ГоловаСвязки(З, alias Разместитель=ДефолтныйРазместитель)
{
    /**
     * Алиас для удобства
     */
    alias Связка!(З).Узел Узел;

    /**
     * Алиас для удобства
     */
    alias Разместитель!(Связка!(З)) разместитель;

    /**
     * Разместитель для this link головы
     */
    разместитель разм;

    /**
     * Узел, отмечающий конец списка
     */
    Узел конец; // невалидный узел

    /**
     * Число узлов в спискеt
     */
    бцел счёт;

    /**
     * Получить первый валидный узел в списке
     */
    Узел начало()
    {
        return конец.следщ;
    }

    /**
     * Инициализировать список
     */
    проц установка()
    {
        //конец = new Узел;
        конец = размести();
        Узел.крепи(конец, конец);
        счёт = 0;
    }

    /**
     * Удалить узел в списке из него, вернув следщ узел в списке, либо
     * конец, если узел был последн в списке. Операция O(1).
     */
    Узел удали(Узел n)
    {
        счёт--;
        Узел возврзнач = n.следщ;
        n.открепи;
        static if(разместитель.нужноСвоб)
            разм.освободи(n);
        return возврзнач;
    }

    /**
     * Сортировать спсок, в соответствии с заданной функцией сравнения
     */
    проц сортируй(Сравниватель)(Сравниватель comp)
    {
        if(конец.следщ.следщ is конец)
            //
            // нет узлов для сортировки
            //
            return;

        //
        // detach the sentinel
        //
        конец.предш.следщ = пусто;

        //
        // использовать маржную сортировку, не обновлять указатели предш, до того пока сортировка не
        //завершена.
        //
        цел К = 1;
        while(К < счёт)
        {
            //
            // конец.следщ  служит как голова сортированного списка
            //
            Узел голова = конец.следщ;
            конец.следщ = пусто;
            Узел сортированныйхвост = конец;
            цел врмсчёт = счёт;

            while(голова !is пусто)
            {

                if(врмсчёт <= К)
                {
                    //
                    // остальное уже отсортировано
                    //
                    сортированныйхвост.следщ = голова;
                    break;
                }
                Узел лево = голова;
                for(цел к = 1; к < К && голова.следщ !is пусто; к++)
                    голова = голова.следщ;
                Узел право = голова.следщ;

                //
                // голова теперь указывает на последн элемент в 'лево', открепим
                //левую сторону
                //
                голова.следщ = пусто;
                цел члоправ = К;
                while(да)
                {
                    if(лево is пусто)
                    {
                        сортированныйхвост.следщ = право;
                        while(члоправ != 0 && сортированныйхвост.следщ !is пусто)
                        {
                            сортированныйхвост = сортированныйхвост.следщ;
                            члоправ--;
                        }
                        голова = сортированныйхвост.следщ;
                        сортированныйхвост.следщ = пусто;
                        break;
                    }
                    else if(право is пусто || члоправ == 0)
                    {
                        сортированныйхвост.следщ = лево;
                        сортированныйхвост = голова;
                        голова = право;
                        сортированныйхвост.следщ = пусто;
                        break;
                    }
                    else
                    {
                        цел r = comp(лево.значение, право.значение);
                        if(r > 0)
                        {
                            сортированныйхвост.следщ = право;
                            право = право.следщ;
                            члоправ--;
                        }
                        else
                        {
                            сортированныйхвост.следщ = лево;
                            лево = лево.следщ;
                        }
                        сортированныйхвост = сортированныйхвост.следщ;
                    }
                }

                врмсчёт -= 2 * К;
            }

            К *= 2;
        }

        //
        //закрепить все предш узлы
        //
        Узел n;
        for(n = конец; n.следщ !is пусто; n = n.следщ)
            n.следщ.предш = n;
        Узел.крепи(n, конец);
    }

    /**
     * Удалить все узлы от первый до последн.   Это операция O(n) .
     */
    Узел удали(Узел первый, Узел последн)
    {
        Узел.крепи(первый.предш, последн);
        auto n = первый;
        while(n !is последн)
        {
            auto nx = n.следщ;
            static if(разм.нужноСвоб)
                разм.освободи(n);
            счёт--;
            n = nx;
        }
        return последн;
    }

    /**
     * Вставить данное значение  перед заданным Узлом.  Используйте вставь(конец, з), чтобы
     * добавить в конец списка, либо в пустой список. Операция O(1).
     */
    Узел вставь(Узел перед, З з)
    {
        счёт++;
        //return перед.приставь(new Узел(з)).предш;
        return перед.приставь(размести(з)).предш;
    }

    /**
     * Удалить все узлы из списка
     */
    проц очисти()
    {
        Узел.крепи(конец, конец);
        счёт = 0;
    }

    /**
     * Скопировать данный список в цель.
     */
    проц копируйВ(ref ГоловаСвязки цель, бул копироватьУзлы=да)
    {
        цель = *this;
        //
        // Сбросить разместитель
        //
        цель.разм = цель.разм.init;

        if(копироватьУзлы)
        {
            цель.конец = конец.dup(&цель.размести);
        }
        else
        {
            //
            // установить цель
            //
            цель.установка();
        }
    }

    /**
     * Разместить новый Узел
     */
    private Узел размести()
    {
        return разм.размести();
    }

    /**
     * Разместить новый Узел, затем установить значение в з
     */
    private Узел размести(З з)
    {
        auto возврзнач = размести();
        возврзнач.значение = з;
        return возврзнач;
    }
}
