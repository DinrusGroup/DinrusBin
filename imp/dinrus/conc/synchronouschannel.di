module conc.synchronouschannel;

import conc.boundedchannel;
import conc.linkednode;

private import conc.sync; 
private import conc.waitnotify;
private import cidrus;


class СинхронныйКанал(T) : ОграниченныйКанал!(T) {


			  private class ОжидаемыйЛинкованныйУзел(T) : ЛинкованныйУзел!(T)
			  {
				бул отменён;

				mixin ЖдиУведоми;
				this()  { иницЖдиУведоми(); }
				~this() { удалиЖдиУведоми(); }
				this(T x) {
				  иницЖдиУведоми();
				  super(x);
				}
				this(T x, .ЛинкованныйУзел!(T) n) 
				{
				  иницЖдиУведоми();
				  super(x,n);
				}
			  }


			  private class Очередь(T) 
			  {
				ОжидаемыйЛинкованныйУзел!(T) head;
				ОжидаемыйЛинкованныйУзел!(T) last;

				проц enq(ОжидаемыйЛинкованныйУзел!(T) p)
				{ 
				  if (last is пусто) 
					last = head = p;
				  else 
					last.следщ = p;
					last = p;
				}

				ОжидаемыйЛинкованныйУзел!(T) deq() 
				{
				  ОжидаемыйЛинкованныйУзел!(T) p = head;
				  if (!(p is пусто) && (head = cast(ОжидаемыйЛинкованныйУзел!(T))p.следщ) is пусто) 
					last = пусто;
				  return p;
				}
			  }

  this() {
    ждущиеРазмещения = new Очередь!(T);
    ждущиеВымещения = new Очередь!(T);
  }

  private Очередь!(T) ждущиеРазмещения;
  private Очередь!(T) ждущиеВымещения;


  цел ёмкость() { return 0; }

  T подбери() {  return T.init;  }

  проц помести(T x)
  {
    for (;;) { 

      ОжидаемыйЛинкованныйУзел!(T) слот;
      ОжидаемыйЛинкованныйУзел!(T) элт = пусто;

      synchronized(this) {
        слот = ждущиеВымещения.deq();
        if (слот is пусто) 
          ждущиеРазмещения.enq(элт = new ОжидаемыйЛинкованныйУзел!(T)(x));
      }
      if (!(слот is пусто)) {
        synchronized(слот) {
          if (!слот.отменён) {
	    слот.значение = x;
            слот.уведоми();
	    return;
          }
        }
      }

      else { 
        synchronized(элт) {
          try {
            while (!(элт.значение is T.init))
              элт.жди();
	    return;
          }
          catch (ИсклОжидания ie) {
            if (элт.значение is T.init) {
	      return;
            }
            else {
              элт.отменён = да;
              throw ie;
            }
          }
        }
      }
    }
  }

  T возьми() {
    for (;;) {
      ОжидаемыйЛинкованныйУзел!(T) элт;
      ОжидаемыйЛинкованныйУзел!(T) слот = пусто;

      synchronized(this) {
        элт = ждущиеРазмещения.deq();
        if (элт is пусто) 
          ждущиеВымещения.enq(слот = new ОжидаемыйЛинкованныйУзел!(T)());
      }

      if (!(элт is пусто)) {
        synchronized(элт) {
          T x = элт.значение;
          if (!элт.отменён) {
            элт.значение = T.init;
            элт.следщ = пусто;
            элт.уведоми();
            return x;
          }
        }
      }

      else {
        synchronized(слот) {
          try {
            for (;;) {
              T x;
	      x = слот.значение;
              if (!(x is T.init)) {
                слот.следщ = пусто;
                return x;
              }
              else {
                слот.жди();
	      }
            }
          }
          catch(ИсклОжидания ie) {
            T x = слот.значение;
            if (!слот.отменён) {
              слот.значение = T.init;
              слот.следщ = пусто;
              return x;
            }
            else {
              слот.отменён = да;
              throw ie;
            }
          }
        }
      }
    }
  }


  бул предложи(T x, дол мсек) {
    дол времяОжидания = мсек;
    дол времяСтарта = 0; 
    
    for (;;) {

      ОжидаемыйЛинкованныйУзел!(T) слот;
      ОжидаемыйЛинкованныйУзел!(T) элт = пусто;

      synchronized(this) {
        слот = ждущиеВымещения.deq();
        if (слот is пусто) {
          if (времяОжидания <= 0) 
            return нет;
          else 
            ждущиеРазмещения.enq(элт = new ОжидаемыйЛинкованныйУзел!(T)(x));
        }
      }

      if (!(слот is пусто)) {
        synchronized(слот) {
          if (!слот.отменён) {
            слот.значение = x;
            слот.уведоми();
            return да;
          }
        }
      }

      дол now = clock();
      if (времяСтарта == 0) 
        времяСтарта = now;
      else 
        времяОжидания = мсек - (now - времяСтарта);

      if (!(элт is пусто)) {
        synchronized(элт) {
          try {
            for (;;) {
              if (элт.значение is пусто) 
                return да;
              if (времяОжидания <= 0) {
                элт.отменён = да;
                return нет;
              }
              элт.жди(времяОжидания);
              времяОжидания = мсек - (clock() - времяСтарта);
            }
          }
          catch (ИсклОжидания ie) {
            if (элт.значение is T.init) {
              return да;
            }
            else {
              элт.отменён = да;
              throw ie;
            }
          }
        }
      }
    }
  }

  T запроси(дол мсек) {
    дол времяОжидания = мсек;
    дол времяСтарта = 0;

    for (;;) {

      ОжидаемыйЛинкованныйУзел!(T) элт;
      ОжидаемыйЛинкованныйУзел!(T) слот = пусто;

      synchronized(this) {
        элт = ждущиеРазмещения.deq();
        if (элт is пусто) {
          if (времяОжидания <= 0) 
            return пусто;
          else 
            ждущиеВымещения.enq(слот = new ОжидаемыйЛинкованныйУзел!(T)());
        }
      }

      if (!(элт is пусто)) {
        synchronized(элт) {
          T x = элт.значение;
          if (!(элт.отменён)) {
            элт.значение = T.init;
            элт.следщ = пусто;
            элт.уведоми();
            return x;
          }
        }
      }

      дол now = clock();
      if (времяСтарта == 0) 
        времяСтарта = now;
      else 
        времяОжидания = мсек - (now - времяСтарта);

      if (!(слот is пусто)) {
        synchronized(слот) {
          try {
            for (;;) {
              T x = слот.значение;
              if (!(x is T.init)) {
                слот.значение = T.init;
                слот.следщ = пусто;
                return x;
              }
              if (времяОжидания <= 0) {
                слот.отменён = да;
                return пусто;
              }
              слот.жди(времяОжидания);
              времяОжидания = мсек - (clock() - времяСтарта);
            }
          }
          catch(ИсклОжидания ie) {
	    слот.отменён = да;
	    throw ie;
          }
        }
      }
    }
  }
}





