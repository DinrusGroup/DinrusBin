module text.Поиск;
private import Util = text.Util;

/******************************************************************************

        Returns a lightweight образец matcher, good for крат образцы 
        и/or крат в_ medium length контент. Brute-force approach with
        fast multi-байт comparisons

******************************************************************************/

НайдиПлод!(T) найди(T) (T[] что)
{
        return НайдиПлод!(T) (что);
}

/******************************************************************************

        Returns a welterweight образец matcher, good for дол образцы 
        и/or extensive контент. Based on the QS algorithm which is a
        Boyer-Moore variant. Does not размести память for the alphabet.

        Generally becomes faster as the сверь-length grows

******************************************************************************/

ИщиПлод!(T) ищи(T) (T[] что)
{
        return ИщиПлод!(T) (что);
}

/******************************************************************************

        Convenient bundle of lightweight найди utilities, without the
        hassle of IFTI problems. Созд one of these using the найди() 
        function:
        ---
        auto сверь = найди ("foo");
        auto контент = "wumpus foo bar"

        // ищи in the вперёд direction
        auto индекс = сверь.вперёд (контент);
        assert (индекс is 7);

        // ищи again - returns length when no сверь найдено
        assert (сверь.вперёд(контент, индекс+1) is контент.length);
        ---

        Searching operates Всё вперёд и backward, with an optional
        старт смещение (can be ещё convenient than slicing the контент).
        There are methods в_ замени совпадает внутри given контент, и 
        другие which return foreach() iterators for traversing контент.

        ИщиПлод is a ещё sophisticated variant, which operates ещё
        efficiently on longer совпадает и/or ещё extensive контент.

******************************************************************************/

private struct НайдиПлод(T)
{       
        private T[] что;

        /***********************************************************************

                Поиск вперёд in the given контент, starting at the 
                optional индекс.

                Returns the индекс of a сверь, or контент.length where
                no сверь was located.

        ***********************************************************************/

        т_мера вперёд (T[] контент, т_мера ofs = 0)
        {
                return Util.индекс (контент, что, ofs);
        }

        /***********************************************************************

                Поиск backward in the given контент, starting at the 
                optional индекс.

                Returns the индекс of a сверь, or контент.length where
                no сверь was located.

        ***********************************************************************/

        т_мера реверс (T[] контент, т_мера ofs = т_мера.max)
        {       
                return Util.пиндекс (контент, что, ofs);
        }

        /***********************************************************************

                Return the сверь текст

        ***********************************************************************/

        T[] сверь ()
        {
                return что;
        }

        /***********************************************************************

                Reset the текст в_ сверь

        ***********************************************************************/

        проц сверь (T[] что)
        {
                this.что = что;
        }

        /***********************************************************************

                Returns да if there is a сверь внутри the given контент

        ***********************************************************************/

        бул внутри (T[] контент)
        {       
                return вперёд(контент) != контент.length;
        }

        /***********************************************************************
                
                Returns число of совпадает внутри the given контент

        ***********************************************************************/

        т_мера счёт (T[] контент)
        {       
                т_мера метка, счёт;

                while ((метка = Util.индекс (контент, что, метка)) != контент.length)
                        ++счёт, ++метка;
                return счёт;
        }

        /***********************************************************************

                Замени все совпадает with the given character. Use метод
                токены() instead в_ avoопр куча activity.

                Returns a копируй of the контент with replacements made

        ***********************************************************************/

        T[] замени (T[] контент, T симв)
        {     
                return замени (контент, (&симв)[0..1]);  
        }

        /***********************************************************************

                Замени все совпадает with the given substitution. Use 
                метод токены() instead в_ avoопр куча activity.

                Returns a копируй of the контент with replacements made

        ***********************************************************************/

        T[] замени (T[] контент, T[] подст = пусто)
        {  
                T[] вывод;

                foreach (s; токены (контент, подст))
                         вывод ~= s;
                return вывод;
        }

        /***********************************************************************

                Returns a foreach() обходчик which exposes текст segments
                between все совпадает внутри the given контент. Substitution
                текст is also injected in place of each сверь, и пусто can
                be использован в_ indicate removal instead:
                ---
                ткст результат;

                auto сверь = найди ("foo");
                foreach (токен; сверь.токены ("$foo&&foo*", "bar"))
                         результат ~= токен;
                assert (результат == "$bar&&bar*");
                ---
                
                This mechanism avoопрs internal куча activity.                

        ***********************************************************************/

        Util.ПлодОбразец!(T) токены (T[] контент, T[] подст = пусто)
        {
                return Util.образцы (контент, что, подст);
        }
        
        /***********************************************************************

                Returns a foreach() обходчик which exposes the индексы of
                все совпадает внутри the given контент:
                ---
                цел счёт;

                auto f = найди ("foo");
                foreach (индекс; f.индексы("$foo&&foo*"))
                         ++счёт;
                assert (счёт is 2);
                ---

        ***********************************************************************/

        Индексы индексы (T[] контент)
        {
                return Индексы (что, контент);
        }
 
        /***********************************************************************

                Simple foreach() обходчик

        ***********************************************************************/

        private struct Индексы
        {
                T[]     что,
                        контент;

                цел opApply (цел delegate (ref т_мера индекс) дг)
                {
                        цел    возвр;
                        т_мера метка;

                        while ((метка = Util.индекс(контент, что, метка)) != контент.length)                        
                                if ((возвр = дг(метка)) is 0)                                
                                     ++метка;       
                                else
                                   break;                        
                        return возвр;   
                }     
        } 
}


/******************************************************************************

        Convenient bundle of welterweight ищи utilities, without the
        hassle of IFTI problems. Созд one of these using the ищи() 
        function:
        ---
        auto сверь = ищи ("foo");
        auto контент = "wumpus foo bar"

        // ищи in the вперёд direction
        auto индекс = сверь.вперёд (контент);
        assert (индекс is 7);

        // ищи again - returns length when no сверь найдено
        assert (сверь.вперёд(контент, индекс+1) is контент.length);
        ---

        Searching operates Всё вперёд и backward, with an optional
        старт смещение (can be ещё convenient than slicing the контент).
        There are methods в_ замени совпадает внутри given контент, и 
        другие which return foreach() iterators for traversing контент.

        НайдиПлод is a simpler variant, which can operate efficiently on 
        крат совпадает и/or крат контент (employs brute-force strategy)

******************************************************************************/

private struct ИщиПлод(T)
{
        private T[]             что;
        private бул            fore;
        private цел[256]        offsets =void;

        /***********************************************************************

                Construct the fruct

        ***********************************************************************/

        static ИщиПлод opCall (T[] что) 
        {
                ИщиПлод найди =void;
                найди.сверь = что;
                return найди;
        }
        
        /***********************************************************************

                Return the сверь текст

        ***********************************************************************/

        T[] сверь ()
        {
                return что;
        }

        /***********************************************************************

                Reset the текст в_ сверь

        ***********************************************************************/

        проц сверь (T[] что)
        {
                offsets[] = что.length + 1;
                this.fore = да;
                this.что = что;
                сбрось;
        }

        /***********************************************************************

                Поиск вперёд in the given контент, starting at the 
                optional индекс.

                Returns the индекс of a сверь, or контент.length where
                no сверь was located.

        ***********************************************************************/

        т_мера вперёд (T[] контент, т_мера ofs = 0) 
        {
                if (! fore)
                      флип;

                if (ofs > контент.length)
                    ofs = контент.length;

                return найди (cast(сим*) что.ptr, что.length * T.sizeof, 
                             cast(сим*) контент.ptr, контент.length * T.sizeof, 
                             ofs * T.sizeof) / T.sizeof;
        }

        /***********************************************************************

                Поиск backward in the given контент, starting at the 
                optional индекс.

                Returns the индекс of a сверь, or контент.length where
                no сверь was located.

        ***********************************************************************/

        т_мера реверс (T[] контент, т_мера ofs = т_мера.max) 
        {
                if (fore)
                    флип;

                if (ofs > контент.length)
                    ofs = контент.length;

                return найдрек (cast(сим*) что.ptr, что.length * T.sizeof, 
                              cast(сим*) контент.ptr, контент.length * T.sizeof, 
                              ofs * T.sizeof) / T.sizeof;
        }

        /***********************************************************************

                Returns да if there is a сверь внутри the given контент

        ***********************************************************************/

        бул внутри (T[] контент)
        {       
                return вперёд(контент) != контент.length;
        }

        /***********************************************************************
                
                Returns число of совпадает внутри the given контент

        ***********************************************************************/

        т_мера счёт (T[] контент)
        {       
                т_мера метка, счёт;

                while ((метка = вперёд (контент, метка)) != контент.length)
                        ++счёт, ++метка;
                return счёт;
        }

        /***********************************************************************

                Замени все совпадает with the given character. Use метод
                токены() instead в_ avoопр куча activity.

                Returns a копируй of the контент with replacements made

        ***********************************************************************/

        T[] замени (T[] контент, T симв)
        {     
                return замени (контент, (&симв)[0..1]);  
        }

        /***********************************************************************

                Замени все совпадает with the given substitution. Use 
                метод токены() instead в_ avoопр куча activity.

                Returns a копируй of the контент with replacements made

        ***********************************************************************/

        T[] замени (T[] контент, T[] подст = пусто)
        {  
                T[] вывод;

                foreach (s; токены (контент, подст))
                         вывод ~= s;
                return вывод;
        }

        /***********************************************************************

                Returns a foreach() обходчик which exposes текст segments
                between все совпадает внутри the given контент. Substitution
                текст is also injected in place of each сверь, и пусто can
                be использован в_ indicate removal instead:
                ---
                ткст результат;

                auto сверь = ищи ("foo");
                foreach (токен; сверь.токены("$foo&&foo*", "bar"))
                         результат ~= токен;
                assert (результат == "$bar&&bar*");
                ---
                
                This mechanism avoопрs internal куча activity             

        ***********************************************************************/

        Подставка токены (T[] контент, T[] подст = пусто)
        {
                return Подставка (подст, что, контент, &вперёд);
        }
        
        /***********************************************************************

                Returns a foreach() обходчик which exposes the индексы of
                все совпадает внутри the given контент:
                ---
                цел счёт;

                auto сверь = ищи ("foo");
                foreach (индекс; сверь.индексы("$foo&&foo*"))
                         ++счёт;
                assert (счёт is 2);
                ---

        ***********************************************************************/

        Индексы индексы (T[] контент)
        {
                return Индексы (контент, &вперёд);
        }
        
        /***********************************************************************

        ***********************************************************************/

        private т_мера найди (сим* что, т_мера wlen, сим* контент, т_мера длин, т_мера ofs) 
        {
                auto s = контент;
                контент += ofs;
                auto e = s + длин - wlen;
                while (контент <= e)
                       if (*что is *контент && совпадает(что, контент, wlen))
                           return контент - s;
                       else
                          контент += offsets [контент[wlen]];
                return длин;
        }

        /***********************************************************************

        ***********************************************************************/

        private т_мера найдрек (сим* что, т_мера wlen, сим* контент, т_мера длин, т_мера ofs) 
        {
                auto s = контент;
                auto e = s + ofs - wlen;
                while (e >= контент)
                       if (*что is *e && совпадает(что, e, wlen))
                           return e - s;
                       else
                          e -= offsets [*(e-1)];
                return длин;
        }

        /***********************************************************************

        ***********************************************************************/

        private static бул совпадает (сим* a, сим* b, т_мера length)
        {
                while (length > т_мера.sizeof)
                       if (*cast(т_мера*) a is *cast(т_мера*) b)
                            a += т_мера.sizeof, b += т_мера.sizeof, length -= т_мера.sizeof;
                       else
                          return нет;

                while (length--)
                       if (*a++ != *b++) 
                           return нет;
                return да;
        }

        /***********************************************************************

                Construct отыщи таблица. We force the alphabet в_ be ткст
                always, и consопрer wопрer characters в_ be longer образцы
                instead

        ***********************************************************************/

        private проц сбрось ()
        {
                auto что = cast(ткст) this.что;
                if (fore)   
                    for (цел i=0; i < что.length; ++i)
                         offsets[что[i]] = что.length - i;
                else
                   for (цел i=что.length; i--;)
                        offsets[что[i]] = i+1;
        }

        /***********************************************************************

                Реверсни отыщи-таблица direction

        ***********************************************************************/

        private проц флип ()
        {
                fore ^= да;
                сбрось;
        }

        /***********************************************************************

                Simple foreach() обходчик

        ***********************************************************************/

        private struct Индексы
        {
                T[]    контент;
                т_мера delegate(T[], т_мера) вызов;

                цел opApply (цел delegate (ref т_мера индекс) дг)
                {
                        цел     возвр;
                        т_мера  метка;

                        while ((метка = вызов(контент, метка)) != контент.length)
                                if ((возвр = дг(метка)) is 0)
                                     ++метка;
                                else
                                   break;
                        return возвр;   
                }     
        } 

        /***********************************************************************

                Substitution foreach() обходчик

        ***********************************************************************/

        private struct Подставка
        {
                private T[] подст, 
                            что,
                            контент;
                т_мера      delegate(T[], т_мера) вызов;

                цел opApply (цел delegate (ref T[] токен) дг)
                {
                        бцел    возвр,
                                поз,
                                метка;
                        T[]     токен;

                        while ((поз = вызов (контент, метка)) < контент.length)
                              {
                              токен = контент [метка .. поз];
                              if ((возвр = дг(токен)) != 0)
                                   return возвр;
                              if (подст.ptr && (возвр = дг(подст)) != 0)
                                  return возвр;
                              метка = поз + что.length;
                              }

                        токен = контент [метка .. $];
                        if (метка <= контент.length)
                            возвр = дг (токен);
                        return возвр;
                }
        }
}




/******************************************************************************

******************************************************************************/

debug (Поиск)
{
        import io.Stdout;
        import time.StopWatch;

        auto x = import("Поиск.d");
        
        проц main()
        {
                Секундомер elapsed;
        
                auto сверь = ищи("foo");
                auto индекс = сверь.реверс ("foo foo");
                assert (индекс is 4);
                индекс = сверь.реверс ("foo foo", индекс);
                assert (индекс is 0);
                индекс = сверь.реверс ("foo foo", 1);
                assert (индекс is 7);

                foreach (индекс; найди("delegate").индексы(x))
                         Стдвыв.форматнс ("< {}", индекс);

                foreach (индекс; ищи("delegate").индексы(x))
                         Стдвыв.форматнс ("> {}", индекс);

                elapsed.старт;
                for (auto i=5000; i--;)
                     Util.не_совпадают (x.ptr, x.ptr, x.length);
                Стдвыв.форматнс ("не_совпадают {}", elapsed.stop);

                elapsed.старт;
                for (auto i=5000; i--;)
                     Util.индексУ (x.ptr, '@', cast(бцел) x.length);
                Стдвыв.форматнс ("индексУ {}", elapsed.stop);

                elapsed.старт;
                for (auto i=5000; i--;)
                     Util.местоположениеОбразца (x, "индексУ {}");
                Стдвыв.форматнс ("образец {}", elapsed.stop);

                elapsed.старт;
                auto f = найди ("индексУ {}");
                for (auto i=5000; i--;)
                     f.вперёд(x);
                Стдвыв.форматнс ("найди {}", elapsed.stop);

                elapsed.старт;
                auto s = ищи ("индексУ {}");
                for (auto i=5000; i--;)
                     s.вперёд(x);
                Стдвыв.форматнс ("ищи {}", elapsed.stop);
        }
}

