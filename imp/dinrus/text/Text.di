/*******************************************************************************

        copyright:      Copyright (c) 2005 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)

        version:        Initial release: December 2005

        author:         Kris


        Текст is a class for managing и manИПulating Unicode character
        массивы.

        Текст maintains a текущ "выделение", controlled via the выбери()
        и ищи() methods. Each of добавь(), приставь(), замени() и
        удали() operate with respect в_ the выделение.

        The ищи() methods also operate with respect в_ the текущ
        выделение, provопрing a means of iterating across matched образцы.
        To установи a выделение across the entire контент, use the выбери()
        метод with no аргументы.

        Indexes и lengths of контент always счёт код units, not код
        points. This is similar в_ traditional аски ткст handling, yet
        indexing is rarely использован in practice due в_ the выделение опрiom:
        substring indexing is generally implied as opposed в_ manИПulated
        directly. This allows for a ещё Потокlined model with regard в_
        utf-surrogates.

        Strings support a range of functionality, из_ вставь и removal
        в_ utf кодировка и decoding. There is also an immutable поднабор
        called ТекстОбзор, intended в_ simplify life in a multi-threaded
        environment. However, ТекстОбзор must expose the необр контент as
        needed и thus immutability depends в_ an протяженность upon so-called
        "honour" of a callee. D does not активируй immutability enforcement
        at this время, but this class will be изменён в_ support such a
        feature when it arrives - via the срез() метод.

        The class is templated for use with ткст, шим[], и дим[],
        и should migrate across encodings seamlessly. In particular, все
        functions in text.Util are compatible with Текст контент in
        any of the supported encodings. In future, this class will become
        a princИПal gateway в_ the extensive ICU unicode library.

        Note that several common текст operations can be constructed through
        combining text.Text with text.Util e.g. строки of текст
        can be processed thusly:
        ---
        auto источник = new Текст!(сим)("one\ntwo\nthree");

        foreach (строка; Util.строки(источник.срез))
                 // do something with строка
        ---

        Speaking a bit like Yoda might be accomplished as follows:
        ---
        auto приёмн = new Текст!(сим);

        foreach (элемент; Util.delims ("все cows съешь grass", " "))
                 приёмн.приставь (элемент);
        ---

        Below is an overview of the API и class иерархия:
        ---
        class Текст(T) : ТекстОбзор!(T)
        {
                // установи or сбрось the контент
                Текст установи (T[] симвы, бул изменяемый=да);
                Текст установи (ТекстОбзор другой, бул изменяемый=да);

                // retrieve currently selected текст
                T[] выделение ();

                // установи и retrieve текущ выделение точка
                Текст точка (бцел индекс);
                бцел точка ();

                // метка a выделение
                Текст выбери (цел старт=0, цел length=цел.max);

                // return an обходчик в_ перемести the выделение around.
                // Also exposes "замени все" functionality
                Поиск ищи (T симв);
                Поиск ищи (T[] образец);

                // форматируй аргументы behind текущ выделение
                Текст форматируй (T[] форматируй, ...);

                // добавь behind текущ выделение
                Текст добавь (T[] текст);
                Текст добавь (ТекстОбзор другой);
                Текст добавь (T симв, цел счёт=1);
                Текст добавь (ИПотокВвода источник);

                // transcode behind текущ выделение
                Текст кодируй (ткст);
                Текст кодируй (шим[]);
                Текст кодируй (дим[]);

                // вставь before текущ выделение
                Текст приставь (T[] текст);
                Текст приставь (ТекстОбзор другой);
                Текст приставь (T симв, цел счёт=1);

                // замени текущ выделение
                Текст замени (T симв);
                Текст замени (T[] текст);
                Текст замени (ТекстОбзор другой);

                // удали текущ выделение
                Текст удали ();

                // очисть контент
                Текст очисть ();

                // убери leading и trailing пробел
                Текст убери ();

                // убери leading и trailing симв экземпляры
                Текст откинь (T симв);

                // упрости at точка, or текущ выделение
                Текст упрости (цел точка = цел.max);

                // резервируй some пространство for inserts/добавьitions
                Текст резервируй (цел extra);
        
                // пиши контент в_ поток
                Текст пиши (ИПотокВывода сток);
        }

        class ТекстОбзор(T) : ЮниТекст
        {
                // хэш контент
                т_хэш вХэш ();

                // return length of контент
                бцел length ();

                // сравни контент
                бул равно  (T[] текст);
                бул равно  (ТекстОбзор другой);
                бул заканчивается    (T[] текст);
                бул заканчивается    (ТекстОбзор другой);
                бул начинается  (T[] текст);
                бул начинается  (ТекстОбзор другой);
                цел сравни  (T[] текст);
                цел сравни  (ТекстОбзор другой);
                цел opEquals (Объект другой);
                цел opCmp    (Объект другой);

                // копируй контент
                T[] копируй (T[] приёмн);

                // return контент
                T[] срез ();

                // return данные тип
                typeinfo кодировка ();

                // замени the сравнение algorithm
                Сравнитель сравнитель (Сравнитель другой);
        }

        class ЮниТекст
        {
                // преобразуй контент
                abstract ткст  вТкст   (ткст  приёмн = пусто);
                abstract шим[] вТкст16 (шим[] приёмн = пусто);
                abstract дим[] вТкст32 (дим[] приёмн = пусто);
        }

        struct Поиск
        {
                // выбери приор экземпляр
                бул предш();

                // выбери следщ экземпляр
                бул следщ();

                // return экземпляр счёт
                т_мера счёт();

                // содержит экземпляр?
                бул внутри();

                // замени все with сим
                проц замени(T);

                // замени все with текст (пусто == удали все)
                проц замени(T[]);
        }
        ---

*******************************************************************************/

module text.Text;

private import  text.Поиск;

private import  io.model;

private import  text.convert.Layout;

private import  Util = text.Util;

private import  Utf = text.convert.Utf;

private import  Float = text.convert.Float;

private import  Целое = text.convert.Integer;

private import cidrus : memmove;


/*******************************************************************************

        The изменяемый Текст class actually реализует the full API, whereas
        the superclasses are purely abstract (could be interfaces instead).

*******************************************************************************/

class Текст(T) : ТекстОбзор!(T)
{
        public  alias установи               opAssign;
        public  alias добавь            opCatAssign;
        private alias ТекстОбзор!(T)      ШТекстОбзор;
        private alias Выкладка!(T)        ШВыкладка;

        private T[]                     контент;
        private бул                    изменяемый;
        private Сравнитель              сравнитель_;
        private бцел                    выборТочки,
                                        выборДлины,
                                        длинаКонтента;

        /***********************************************************************

                Поиск Обходчик

        ***********************************************************************/

        private struct Поиск(T)
        {
                private alias ИщиПлод!(T) Движок;
                private alias т_мера delegate(T[], т_мера) Вызов;

                private Текст    текст;
                private Движок  движок;

                /***************************************************************

                       Конструктор Поиск экземпляра

                ***************************************************************/

                static Поиск opCall (Текст текст, T[] сверь)
                {
                        Поиск s =void;
                        s.движок.сверь = сверь;
                        текст.выборДлины = 0;
                        s.текст = текст;
                        return s;
                }

                /***************************************************************

                        Поиск назад, начиная с символа перед точкой выбора

                ***************************************************************/

                бул предш ()
                {
                        return местоположение (&движок.реверс, текст.срез, текст.точка - 1);
                }

                /***************************************************************

                        Поиск вперёд, начиная от только что выделенного текста

                ***************************************************************/

                бул следщ ()
                {
                        return местоположение (&движок.вперёд, текст.срез, 
                                        текст.выборТочки + текст.выборДлины);
                }

                /***************************************************************

                        Вернуть да, если есть совпадение в связанном тексте

                ***************************************************************/

                бул внутри ()
                {       
                        return движок.внутри (текст.срез);
                }

                /***************************************************************
                
                       Вернуть число совпадений в связанном тексте
                        текст

                ***************************************************************/

                т_мера счёт ()
                {       
                        return движок.счёт (текст.срез);
                }

                /***************************************************************

                        Заменить все совпадения на данный символ

                ***************************************************************/

                проц замени (T симв)
                {     
                        замени ((&симв)[0..1]);  
                }

                /***************************************************************

                        Заменить все совпадения заданной подстановкой

                ***************************************************************/

                проц замени (T[] подст = пусто)
                {  
                        auto приёмн = new T[текст.length];
                        приёмн.length = 0;

                        foreach (токен; движок.токены (текст.срез, подст))
                                 приёмн ~= токен;
                        текст.установи (приёмн, нет);
                }
 
                /***************************************************************

                       Найти индекс положения образца и выбрать необходимый

                ***************************************************************/

                private бул местоположение (Вызов вызов, T[] контент, т_мера из_)
                {
                        auto индекс = вызов (контент, из_);
                        if (индекс < контент.length)
                           {
                           текст.выбери (индекс, движок.сверь.length);
                           return да;
                           }
                        return нет;
                }
        }

        /***********************************************************************

                Selection вринтервал

                deprecated: use точка() instead

        ***********************************************************************/

        deprecated public struct Span
        {
                бцел    begin,                  /// индекс of выделение точка
                        length;                 /// length of выделение
        }

        /***********************************************************************

                Созд an пустой Текст with the specified available
                пространство

                Note: A character like 'a' will be implicitly преобразованый в_
                бцел и thus will be accepted for this constructor, making
                it appear like you can инициализуй a Текст экземпляр with a 
                single character, something which is not supported.

        ***********************************************************************/

        this (бцел пространство = 0)
        {
                контент.length = пространство;
                this.сравнитель_ = &простойСравнитель;
        }

        /***********************************************************************

                Созд a Текст upon the provопрed контент. If saопр
                контент is immutable (читай-only) then you might consопрer
                настройка the 'копируй' parameter в_ нет. Doing so will
                avoопр allocating куча-пространство for the контент until it is
                изменён via Текст methods. This can be useful when
                wrapping an Массив "temporarily" with a стэк-based Текст

        ***********************************************************************/

        this (T[] контент, бул копируй = да)
        {
                установи (контент, копируй);
                this.сравнитель_ = &простойСравнитель;
        }

        /***********************************************************************

                Созд a Текст via the контент of другой. If saопр
                контент is immutable (читай-only) then you might consопрer
                настройка the 'копируй' parameter в_ нет. Doing so will avoопр
                allocating куча-пространство for the контент until it is изменён
                via Текст methods. This can be useful when wrapping an Массив
                temporarily with a стэк-based Текст

        ***********************************************************************/

        this (ШТекстОбзор другой, бул копируй = да)
        {
                this (другой.срез, копируй);
        }

        /***********************************************************************

                Набор the контент в_ the provопрed Массив. Parameter 'копируй'
                specifies whether the given Массив is likely в_ change. If
                not, the Массив is есть_алиас until such время it is altered via
                this class. This can be useful when wrapping an Массив
                "temporarily" with a стэк-based Текст.

                Also resets the curent выделение в_ пусто           

        ***********************************************************************/

        final Текст установи (T[] симвы, бул копируй = да)
        {
                длинаКонтента = симвы.length;
                if ((this.изменяемый = копируй) is да)
                     контент = симвы.dup;
                else
                   контент = симвы;

                // no выделение
                return выбери (0, 0);
        }

        /***********************************************************************

                Замени the контент of this Текст. If the new контент
                is immutable (читай-only) then you might consопрer настройка the
                'копируй' parameter в_ нет. Doing so will avoопр allocating
                куча-пространство for the контент until it is изменён via one of
                these methods. This can be useful when wrapping an Массив
                "temporarily" with a стэк-based Текст.

                Also resets the curent выделение в_ пусто           

        ***********************************************************************/

        final Текст установи (ШТекстОбзор другой, бул копируй = да)
        {
                return установи (другой.срез, копируй);
        }

        /***********************************************************************

                Explicitly установи the текущ выделение в_ the given старт и
                length. значения are pinned в_ the контент extents

        ***********************************************************************/

        final Текст выбери (цел старт=0, цел length=цел.max)
        {
                pinIndices (старт, length);
                выборТочки = старт;
                выборДлины = length;
                return this;
        }

        /***********************************************************************

                Return the currently selected контент

        ***********************************************************************/

        final T[] выделение ()
        {
                return срез [выборТочки .. выборТочки+выборДлины];
        }

        /***********************************************************************

                Return the индекс и length of the текущ выделение

                deprecated: use точка() instead

        ***********************************************************************/

        deprecated final Span вринтервал ()
        {
                Span s;
                s.begin = выборТочки;
                s.length = выборДлины;
                return s;
        }

        /***********************************************************************

                Return the текущ выделение точка

        ***********************************************************************/

        final бцел точка ()
        {
                return выборТочки;
        }

        /***********************************************************************

                Набор the текущ выделение точка, и resets выделение length

        ***********************************************************************/

        final Текст точка (бцел индекс)
        {
                return выбери (индекс, 0);
        }

        /***********************************************************************
        
                Return a ищи обходчик for a given образец. The обходчик
                sets the текущ текст выделение as appropriate. For example:
                ---
                auto t = new Текст ("hello world");
                auto s = t.ищи ("world");

                assert (s.следщ);
                assert (t.выделение == "world");
                ---

                Replacing образцы operates in a similar fashion:
                ---
                auto t = new Текст ("hello world");
                auto s = t.ищи ("world");

                // замени все экземпляры of "world" with "everyone"
                assert (s.замени ("everyone"));
                assert (s.счёт is 0);
                ---

        ***********************************************************************/

        Поиск!(T) ищи (T[] сверь)
        {
                return Поиск!(T) (this, сверь);
        }

        Поиск!(T) ищи (ref T сверь)
        {
                return ищи ((&сверь)[0..1]);
        }

        /***********************************************************************

                Find и выбери the следщ occurrence of a BMP код точка
                in a ткст. Returns да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбери (T c)
        {
                auto s = срез();
                auto x = Util.местоположение (s, c, выборТочки);
                if (x < s.length)
                   {
                   выбери (x, 1);
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Find и выбери the следщ substring occurrence.  Returns
                да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбери (ШТекстОбзор другой)
        {
                return выбери (другой.срез);
        }

        /***********************************************************************

                Find и выбери the следщ substring occurrence. Returns
                да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбери (T[] симвы)
        {
                auto s = срез();
                auto x = Util.местоположениеОбразца (s, симвы, выборТочки);
                if (x < s.length)
                   {
                   выбери (x, симвы.length);
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Find и выбери a приор occurrence of a BMP код точка
                in a ткст. Returns да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбериПеред (T c)
        {
                auto s = срез();
                auto x = Util.местоположениеПеред (s, c, выборТочки);
                if (x < s.length)
                   {
                   выбери (x, 1);
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Find и выбери a приор substring occurrence. Returns
                да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбериПеред (ШТекстОбзор другой)
        {
                return выбериПеред (другой.срез);
        }

        /***********************************************************************

                Find и выбери a приор substring occurrence. Returns
                да if найдено, нет otherwise

                deprecated: use ищи() instead

        ***********************************************************************/

        deprecated final бул выбериПеред (T[] симвы)
        {
                auto s = срез();
                auto x = Util.местоположениеПередОбразцом (s, симвы, выборТочки);
                if (x < s.length)
                   {
                   выбери (x, симвы.length);
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Доб formatted контент в_ this Текст

        ***********************************************************************/

        final Текст форматируй (T[] форматируй, ...)
        {
                бцел излей (T[] s)
                {
                        добавь (s);
                        return s.length;
                }

                ШВыкладка.экземпляр.преобразуй (&излей, _arguments, _argptr, форматируй);
                return this;
        }

        /***********************************************************************

                Доб текст в_ this Текст

        ***********************************************************************/

        final Текст добавь (ШТекстОбзор другой)
        {
                return добавь (другой.срез);
        }

        /***********************************************************************

                Доб текст в_ this Текст

        ***********************************************************************/

        final Текст добавь (T[] симвы)
        {
                return добавь (симвы.ptr, симвы.length);
        }

        /***********************************************************************

                Доб a счёт of characters в_ this Текст

        ***********************************************************************/

        final Текст добавь (T симв, цел счёт=1)
        {
                бцел точка = выборТочки + выборДлины;
                расширь (точка, счёт);
                return установи (симв, точка, счёт);
        }

        /***********************************************************************

                Доб an целое в_ this Текст

                deprecated: use форматируй() instead

        ***********************************************************************/
        
        deprecated final Текст добавь (цел v, T[] фмт = пусто)
        {
                return добавь (cast(дол) v, фмт);
        }

        /***********************************************************************

                Доб a дол в_ this Текст

                deprecated: use форматируй() instead

        ***********************************************************************/

        deprecated final Текст добавь (дол v, T[] фмт = пусто)
        {
                T[64] врем =void;
                return добавь (Целое.форматируй(врем, v, фмт));
        }

        /***********************************************************************

                Доб a дво в_ this Текст

                deprecated: use форматируй() instead

        ***********************************************************************/

        deprecated final Текст добавь (дво v, бцел decimals=2, цел e=10)
        {
                T[64] врем =void;
                return добавь (Float.форматируй(врем, v, decimals, e));
        }

        /***********************************************************************

                Доб контент из_ ввод поток at insertion точка. Use
                io.stream.Utf as a wrapper в_ perform conversion as
                necessary

        ***********************************************************************/

        final Текст добавь (ИПотокВвода источник)
        {
                T[8192/T.sizeof] врем =void;
                while (да) 
                      {
                      auto длин = источник.читай (врем); 
                      if (длин is источник.Кф) 
                          break; 

                      // проверь в_ ensure UTF conversion is ok
                      assert ((длин & (T.sizeof-1)) is 0);
                      добавь (врем [0 .. длин/T.sizeof]);
                      }
                return this;
        }

        /***********************************************************************

                Insert characters преобр_в this Текст

        ***********************************************************************/

        final Текст приставь (T симв, цел счёт=1)
        {
                расширь (выборТочки, счёт);
                return установи (симв, выборТочки, счёт);
        }

        /***********************************************************************

                Insert текст преобр_в this Текст

        ***********************************************************************/

        final Текст приставь (T[] другой)
        {
                расширь (выборТочки, другой.length);
                контент[выборТочки..выборТочки+другой.length] = другой;
                return this;
        }

        /***********************************************************************

                Insert другой Текст преобр_в this Текст

        ***********************************************************************/

        final Текст приставь (ШТекстОбзор другой)
        {
                return приставь (другой.срез);
        }

        /***********************************************************************

                Доб кодирован текст at the текущ выделение точка. The текст
                is преобразованый as necessary в_ the appropritate utf кодировка.

        ***********************************************************************/

        final Текст кодируй (ткст s)
        {
                T[1024] врем =void;

                static if (is (T == сим))
                           return добавь(s);

                static if (is (T == шим))
                           return добавь (Utf.вТкст16(s, врем));

                static if (is (T == дим))
                           return добавь (Utf.вТкст32(s, врем));
        }

        /// ditto
        final Текст кодируй (шим[] s)
        {
                T[1024] врем =void;

                static if (is (T == сим))
                           return добавь (Utf.вТкст(s, врем));

                static if (is (T == шим))
                           return добавь (s);

                static if (is (T == дим))
                           return добавь (Utf.вТкст32(s, врем));
        }

        /// ditto
        final Текст кодируй (дим[] s)
        {
                T[1024] врем =void;

                static if (is (T == сим))
                           return добавь (Utf.вТкст(s, врем));

                static if (is (T == шим))
                           return добавь (Utf.вТкст16(s, врем));

                static if (is (T == дим))
                           return добавь (s);
        }

        /// ditto
        final Текст кодируй (Объект o)
        {
                return кодируй (o.вТкст);
        }

        /***********************************************************************

                Замени a section of this Текст with the specified
                character

        ***********************************************************************/

        final Текст замени (T симв)
        {
                return установи (симв, выборТочки, выборДлины);
        }

        /***********************************************************************

                Замени a section of this Текст with the specified
                Массив

        ***********************************************************************/

        final Текст замени (T[] симвы)
        {
                цел чанк = симвы.length - выборДлины;
                if (чанк >= 0)
                    расширь (выборТочки, чанк);
                else
                   удали (выборТочки, -чанк);

                контент [выборТочки .. выборТочки+симвы.length] = симвы;
                return выбери (выборТочки, симвы.length);
        }

        /***********************************************************************

                Замени a section of this Текст with другой

        ***********************************************************************/

        final Текст замени (ШТекстОбзор другой)
        {
                return замени (другой.срез);
        }

        /***********************************************************************

                Удали the выделение из_ this Текст и сбрось the
                выделение в_ zero length (at the текущ позиция)

        ***********************************************************************/

        final Текст удали ()
        {
                удали (выборТочки, выборДлины);
                return выбери (выборТочки, 0);
        }

        /***********************************************************************

                Удали the выделение из_ this Текст

        ***********************************************************************/

        private Текст удали (цел старт, цел счёт)
        {
                pinIndices (старт, счёт);
                if (счёт > 0)
                   {
                   if (! изменяемый)
                         realloc ();

                   бцел i = старт + счёт;
                   memmove (контент.ptr+старт, контент.ptr+i, (длинаКонтента-i) * T.sizeof);
                   длинаКонтента -= счёт;
                   }
                return this;
        }

        /***********************************************************************

                Truncate this ткст at an optional индекс. Default behaviour
                is в_ упрости at the текущ добавь точка. Текущий выделение
                is moved в_ the truncation точка, with length 0

        ***********************************************************************/

        final Текст упрости (цел индекс = цел.max)
        {
                if (индекс is цел.max)
                    индекс = выборТочки + выборДлины;

                pinIndex (индекс);
                return выбери (длинаКонтента = индекс, 0);
        }

        /***********************************************************************

                Clear the ткст контент

        ***********************************************************************/

        final Текст очисть ()
        {
                return выбери (длинаКонтента = 0, 0);
        }

        /***********************************************************************

                Удали leading и trailing пробел из_ this Текст,
                и сбрось the выделение в_ the trimmed контент

        ***********************************************************************/

        final Текст убери ()
        {
                контент = Util.убери (срез);
                выбери (0, длинаКонтента = контент.length);
                return this;
        }

        /***********************************************************************

                Удали leading и trailing совпадает из_ this Текст,
                и сбрось the выделение в_ the очищенный контент

        ***********************************************************************/

        final Текст откинь (T совпадает)
        {
                контент = Util.откинь (срез, совпадает);
                выбери (0, длинаКонтента = контент.length);
                return this;
        }

        /***********************************************************************

                Reserve some extra room

        ***********************************************************************/

        final Текст резервируй (бцел extra)
        {
                realloc (extra);
                return this;
        }

        /***********************************************************************

                Зап контент в_ вывод поток

        ***********************************************************************/

        Текст пиши (ИПотокВывода сток)
        {
                сток.пиши (срез);
                return this;
        }

        /* ======================== ТекстОбзор methods ======================== */



        /***********************************************************************

                Get the кодировка тип

        ***********************************************************************/

        final ИнфОТипе кодировка()
        {
                return typeid(T);
        }

        /***********************************************************************

                Набор the сравнитель delegate. Where другой is пусто, we behave
                as a getter only

        ***********************************************************************/

        final Сравнитель сравнитель (Сравнитель другой)
        {
                auto врем = сравнитель_;
                if (другой)
                    сравнитель_ = другой;
                return врем;
        }

        /***********************************************************************

                Хэш this Текст

        ***********************************************************************/

        override т_хэш вХэш ()
        {
                return Util.джейхэш (cast(ббайт*) контент.ptr, длинаКонтента * T.sizeof);
        }

        /***********************************************************************

                Return the length of the действителен контент

        ***********************************************************************/

        final бцел length ()
        {
                return длинаКонтента;
        }

        /***********************************************************************

                Is this Текст equal в_ другой?

        ***********************************************************************/

        final бул равно (ШТекстОбзор другой)
        {
                if (другой is this)
                    return да;
                return равно (другой.срез);
        }

        /***********************************************************************

                Is this Текст equal в_ the provопрed текст?

        ***********************************************************************/

        final бул равно (T[] другой)
        {
                if (другой.length == длинаКонтента)
                    return Util.совпадают (другой.ptr, контент.ptr, длинаКонтента);
                return нет;
        }

        /***********************************************************************

                Does this Текст конец with другой?

        ***********************************************************************/

        final бул заканчивается (ШТекстОбзор другой)
        {
                return заканчивается (другой.срез);
        }

        /***********************************************************************

                Does this Текст конец with the specified ткст?

        ***********************************************************************/

        final бул заканчивается (T[] симвы)
        {
                if (симвы.length <= длинаКонтента)
                    return Util.совпадают (контент.ptr+(длинаКонтента-симвы.length), симвы.ptr, симвы.length);
                return нет;
        }

        /***********************************************************************

                Does this Текст старт with другой?

        ***********************************************************************/

        final бул начинается (ШТекстОбзор другой)
        {
                return начинается (другой.срез);
        }

        /***********************************************************************

                Does this Текст старт with the specified ткст?

        ***********************************************************************/

        final бул начинается (T[] симвы)
        {
                if (симвы.length <= длинаКонтента)
                    return Util.совпадают (контент.ptr, симвы.ptr, симвы.length);
                return нет;
        }

        /***********************************************************************

                Сравни this Текст старт with другой. Returns 0 if the
                контент совпадает, less than zero if this Текст is "less"
                than the другой, or greater than zero where this Текст
                is "bigger".

        ***********************************************************************/

        final цел сравни (ШТекстОбзор другой)
        {
                if (другой is this)
                    return 0;

                return сравни (другой.срез);
        }

        /***********************************************************************

                Сравни this Текст старт with an Массив. Returns 0 if the
                контент совпадает, less than zero if this Текст is "less"
                than the другой, or greater than zero where this Текст
                is "bigger".

        ***********************************************************************/

        final цел сравни (T[] симвы)
        {
                return сравнитель_ (срез, симвы);
        }

        /***********************************************************************

                Return контент из_ this Текст

                A срез of приёмн is returned, representing a копируй of the
                контент. The срез is clИПped в_ the minimum of either
                the length of the provопрed Массив, or the length of the
                контент minus the stИПulated старт точка

        ***********************************************************************/

        final T[] копируй (T[] приёмн)
        {
                бцел i = длинаКонтента;
                if (i > приёмн.length)
                    i = приёмн.length;

                return приёмн [0 .. i] = контент [0 .. i];
        }

        /***********************************************************************

                Return an alias в_ the контент of this ТекстОбзор. Note
                that you are bound by honour в_ покинь this контент wholly
                unmolested. D surely needs some way в_ enforce immutability
                upon Массив references

        ***********************************************************************/

        final T[] срез ()
        {
                return контент [0 .. длинаКонтента];
        }

        /***********************************************************************

                Convert в_ the ЮниТекст типы. The optional аргумент
                приёмн will be resized as требуется в_ house the conversion.
                To minimize куча allocation during subsequent conversions,
                apply the following образец:
                ---
                Текст  ткст;

                шим[] буфер;
                шим[] результат = ткст.utf16 (буфер);

                if (результат.length > буфер.length)
                    буфер = результат;
                ---
                You can also provопрe a буфер из_ the стэк, but the вывод
                will be moved в_ the куча if saопр буфер is not large enough

        ***********************************************************************/

        final ткст вТкст (ткст приёмн = пусто)
        {
                static if (is (T == сим))
                           return срез();

                static if (is (T == шим))
                           return Utf.вТкст (срез, приёмн);

                static if (is (T == дим))
                           return Utf.вТкст (срез, приёмн);
        }

        /// ditto
        final шим[] вТкст16 (шим[] приёмн = пусто)
        {
                static if (is (T == сим))
                           return Utf.вТкст16 (срез, приёмн);

                static if (is (T == шим))
                           return срез;

                static if (is (T == дим))
                           return Utf.вТкст16 (срез, приёмн);
        }

        /// ditto
        final дим[] вТкст32 (дим[] приёмн = пусто)
        {
                static if (is (T == сим))
                           return Utf.вТкст32 (срез, приёмн);

                static if (is (T == шим))
                           return Utf.вТкст32 (срез, приёмн);

                static if (is (T == дим))
                           return срез;
        }

        /***********************************************************************

                Сравни this Текст в_ другой. We сравни against другой
                Strings only. Literals и другой objects are not supported

        ***********************************************************************/

        override цел opCmp (Объект o)
        {
                auto другой = cast (ШТекстОбзор) o;

                if (другой is пусто)
                    return -1;

                return сравни (другой);
        }

        /***********************************************************************

                Is this Текст equal в_ the текст of something else?

        ***********************************************************************/

        override цел opEquals (Объект o)
        {
                auto другой = cast (ШТекстОбзор) o;

                if (другой)
                    return равно (другой);

                // this can become expensive ...
                сим[1024] врем =void;
                return this.вТкст(врем) == o.вТкст;
        }

        /// ditto
        final цел opEquals (T[] s)
        {
                return срез == s;
        }

        /***********************************************************************

                Pin the given индекс в_ a действителен позиция.

        ***********************************************************************/

        private проц pinIndex (ref цел x)
        {
                if (x > длинаКонтента)
                    x = длинаКонтента;
        }

        /***********************************************************************

                Pin the given индекс и length в_ a действителен позиция.

        ***********************************************************************/

        private проц pinIndices (ref цел старт, ref цел length)
        {
                if (старт > длинаКонтента)
                    старт = длинаКонтента;

                if (length > (длинаКонтента - старт))
                    length = длинаКонтента - старт;
        }

        /***********************************************************************

                Сравни two массивы. Returns 0 if the контент совпадает, less
                than zero if A is "less" than B, or greater than zero where
                A is "bigger". Where the substrings сверь, the shorter is
                consопрered "less".

        ***********************************************************************/

        private цел простойСравнитель (T[] a, T[] b)
        {
                бцел i = a.length;
                if (b.length < i)
                    i = b.length;

                for (цел j, k; j < i; ++j)
                     if ((k = a[j] - b[j]) != 0)
                          return k;

                return a.length - b.length;
        }

        /***********************************************************************

                Make room available в_ вставь or добавь something

        ***********************************************************************/

        private проц расширь (бцел индекс, бцел счёт)
        {
                if (!изменяемый || (длинаКонтента + счёт) > контент.length)
                     realloc (счёт);

                memmove (контент.ptr+индекс+счёт, контент.ptr+индекс, (длинаКонтента - индекс) * T.sizeof);
                выборДлины += счёт;
                длинаКонтента += счёт;
        }

        /***********************************************************************

                Замени a section of this Текст with the specified
                character

        ***********************************************************************/

        private Текст установи (T симв, бцел старт, бцел счёт)
        {
                контент [старт..старт+счёт] = симв;
                return this;
        }

        /***********************************************************************

                Размести память due в_ a change in the контент. We укз
                the distinction between изменяемый и immutable here.

        ***********************************************************************/

        private проц realloc (бцел счёт = 0)
        {
                бцел размер = (контент.length + счёт + 127) & ~127;

                if (изменяемый)
                    контент.length = размер;
                else
                   {
                   изменяемый = да;
                   T[] x = контент;
                   контент = new T[размер];
                   if (длинаКонтента)
                       контент[0..длинаКонтента] = x;
                   }
        }

        /***********************************************************************

                Internal метод в_ support Текст appending

        ***********************************************************************/

        private Текст добавь (T* симвы, бцел счёт)
        {
                бцел точка = выборТочки + выборДлины;
                расширь (точка, счёт);
                контент[точка .. точка+счёт] = симвы[0 .. счёт];
                return this;
        }
}



/*******************************************************************************

        Immutable ткст

*******************************************************************************/

class ТекстОбзор(T) : ЮниТекст
{
        public typedef цел delegate (T[] a, T[] b) Сравнитель;

        /***********************************************************************

                Return the length of the действителен контент

        ***********************************************************************/

        abstract бцел length ();

        /***********************************************************************

                Is this Текст equal в_ другой?

        ***********************************************************************/

        abstract бул равно (ТекстОбзор другой);

        /***********************************************************************

                Is this Текст equal в_ the the provопрed текст?

        ***********************************************************************/

        abstract бул равно (T[] другой);

        /***********************************************************************

                Does this Текст конец with другой?

        ***********************************************************************/

        abstract бул заканчивается (ТекстОбзор другой);

        /***********************************************************************

                Does this Текст конец with the specified ткст?

        ***********************************************************************/

        abstract бул заканчивается (T[] симвы);

        /***********************************************************************

                Does this Текст старт with другой?

        ***********************************************************************/

        abstract бул начинается (ТекстОбзор другой);

        /***********************************************************************

                Does this Текст старт with the specified ткст?

        ***********************************************************************/

        abstract бул начинается (T[] симвы);

        /***********************************************************************

                Сравни this Текст старт with другой. Returns 0 if the
                контент совпадает, less than zero if this Текст is "less"
                than the другой, or greater than zero where this Текст
                is "bigger".

        ***********************************************************************/

        abstract цел сравни (ТекстОбзор другой);

        /***********************************************************************

                Сравни this Текст старт with an Массив. Returns 0 if the
                контент совпадает, less than zero if this Текст is "less"
                than the другой, or greater than zero where this Текст
                is "bigger".

        ***********************************************************************/

        abstract цел сравни (T[] симвы);

        /***********************************************************************

                Return контент из_ this Текст. A срез of приёмн is
                returned, representing a копируй of the контент. The
                срез is clИПped в_ the minimum of either the length
                of the provопрed Массив, or the length of the контент
                minus the stИПulated старт точка

        ***********************************************************************/

        abstract T[] копируй (T[] приёмн);

        /***********************************************************************

                Сравни this Текст в_ другой

        ***********************************************************************/

        abstract цел opCmp (Объект o);

        /***********************************************************************

                Is this Текст equal в_ другой?

        ***********************************************************************/

        abstract цел opEquals (Объект другой);

        /***********************************************************************

                Is this Текст equal в_ другой?

        ***********************************************************************/

        abstract цел opEquals (T[] другой);

        /***********************************************************************

                Get the кодировка тип

        ***********************************************************************/

        abstract ИнфОТипе кодировка();

        /***********************************************************************

                Набор the сравнитель delegate

        ***********************************************************************/

        abstract Сравнитель сравнитель (Сравнитель другой);

        /***********************************************************************

                Хэш this Текст

        ***********************************************************************/

        abstract т_хэш вХэш ();

        /***********************************************************************

                Return an alias в_ the контент of this ТекстОбзор. Note
                that you are bound by honour в_ покинь this контент wholly
                unmolested. D surely needs some way в_ enforce immutability
                upon Массив references

        ***********************************************************************/

        abstract T[] срез ();
}


/*******************************************************************************

        A ткст abstraction that converts в_ anything

*******************************************************************************/

class ЮниТекст
{
        abstract ткст  вТкст  (ткст  приёмн = пусто);

        abstract шим[] вТкст16 (шим[] приёмн = пусто);

        abstract дим[] вТкст32 (дим[] приёмн = пусто);

        abstract ИнфОТипе кодировка();
}



/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{       
        import io.device.Array;

        //проц main() {}
        unittest
        {
        auto s = new Текст!(сим);
        s = "hello";

        auto Массив = new Массив(1024);
        s.пиши (Массив);
        assert (Массив.срез == "hello");
        s.выбери (1, 0);
        assert (s.добавь(Массив) == "hhelloello");

        s = "hello";
        s.ищи("hello").следщ;
        assert (s.выделение == "hello");
        s.замени ("1");
        assert (s.выделение == "1");
        assert (s == "1");

        assert (s.очисть == "");

        assert (s.форматируй("{}", 12345) == "12345");
        assert (s.выделение == "12345");

        s ~= "fubar";
        assert (s.выделение == "12345fubar");
        assert (s.ищи("5").следщ);
        assert (s.выделение == "5");
        assert (s.удали == "1234fubar");
        assert (s.ищи("fubar").следщ);
        assert (s.выделение == "fubar");
        assert (s.ищи("wumpus").следщ is нет);
        assert (s.выделение == "");

        assert (s.очисть.форматируй("{:f4}", 1.2345) == "1.2345");

        assert (s.очисть.форматируй("{:b}", 0xf0) == "11110000");

        assert (s.очисть.кодируй("one"d).вТкст == "one");

        assert (Util.рабейнастр(s.очисть.добавь("a\nb").срез).length is 2);

        assert (s.выбери.замени("almost ") == "almost ");
        foreach (элемент; Util.образцы ("все cows съешь grass", "съешь", "chew"))
                 s.добавь (элемент);
        assert (s.выделение == "almost все cows chew grass");
        assert (s.очисть.форматируй("{}:{}", 1, 2) == "1:2");
        }
}


debug (Текст)
{
        проц main()
        {
                auto t = new Текст!(сим);
                t = "hello world";
                auto s = t.ищи ("o");
                assert (s.следщ);
                assert (t.выделение == "o");
                assert (t.точка is 4);
                assert (s.следщ);
                assert (t.выделение == "o");
                assert (t.точка is 7);
                assert (!s.следщ);

                t.точка = 9;
                assert (s.предш);
                assert (t.выделение == "o");
                assert (t.точка is 7);
                assert (s.предш);
                assert (t.выделение == "o");
                assert (t.точка is 4);
                assert (s.следщ);
                assert (t.точка is 7);
                assert (s.предш);
                assert (t.выделение == "o");
                assert (t.точка is 4);
                assert (!s.предш);
                assert (s.счёт is 2);
                s.замени ('O');
                assert (t.срез == "hellO wOrld");
                assert (s.счёт is 0);

                t.точка = 0;
                assert (t.ищи("hellO").следщ);
                assert (t.выделение == "hellO");
                assert (t.ищи("hellO").следщ);
                assert (t.выделение == "hellO");
        }
}
