/*******************************************************************************

        Copyright: Copyright (C) 2008 Aaron Craelius & Kris Bell
                   все rights reserved

        License:   BSD стиль: $(LICENSE)

        version:   July 2008: Initial release

        Authors:   Aaron, Kris

*******************************************************************************/

module text.json.Json;

private import tpl.args;

private import io.model;

private import text.json.JsonEscape;

private import text.json.JsonParser;

private import Float = text.convert.Float;

/*******************************************************************************

        Parse json текст преобр_в a установи of inter-related structures. Typical 
        usage is as follows:
        ---
        auto json = new Json!(сим);
        json.разбор (`{"t": да, "n":пусто, "Массив":["world", [4, 5]]}`);    
        ---   

        Converting back в_ текст форматируй employs a delegate. This one излейs 
        document контент в_ the console:
        ---
        json.выведи ((ткст s) {Стдвыв(s);}); 
        ---

        Constructing json внутри your код leverages a handful of factories 
        внутри a document экземпляр. This example creates a document из_ an 
        Массив of значения:
        ---
        auto json = new Json!(сим);

        // [да, нет, пусто, "текст"]
        with (json)
              значение = Массив (да, нет, пусто, "текст");
        ---

        Setting the document в_ contain a simple объект instead:
        ---
        // {"a" : 10}
        with (json)
              значение = объект (пара("a", значение(10)));
        ---

        Objects may be constructed with multИПle attribute pairs like so:
        ---
        // {"a" : 10, "b" : да}
        with (json)
              значение = объект (пара("a", значение(10)), пара("b", значение(да)));
        ---

        Подставка массивы, or другой objects as значения where appropriate:
        ---
        // {"a" : [10, да, {"b" : пусто}]}
        with (json)
              значение = объект (пара("a", Массив(10, да, объект(пара("b")))));
        ---

        TODO: document как в_ выкинь контент

        Биг thanks в_ dhasenan for suggesting the construction notation. We
        can't сделай effective use of operator-overloading, due в_ the use of
        struct pointers, so this syntax turned out в_ be the следщ best thing.

*******************************************************************************/

class Json(T) : private JsonParser!(T)
{
                     /// use these типы for external references
        public alias JsonValue*  Значение;
        public alias NameValue*  Атрибут;
        public alias JsonObject* Композит;

                    /// enumerates the seven acceptable JSON значение типы
        public enum Тип {Пусто, Строка, НеобрСтрока, Число, Объект, Массив, Да, Нет};

        private Значение корень;

        /***********************************************************************
        
                Construct a json экземпляр, with a default значение of пусто

        ***********************************************************************/
        
        this ()
        {
                массивы.length = 16;
                разбор (пусто);
        }

        /***********************************************************************
        
                Parse the given текст и return a resultant Значение тип. Also
                sets the document значение. 

        ***********************************************************************/
        
        final Значение разбор (T[] json)
        {
                nesting = 0;
                attrib.сбрось;
                значения.сбрось;
                objects.сбрось;
                foreach (ref p; массивы)
                         p.индекс = 0;

                корень = создайЗначение;
                if (super.сбрось (json))
                    if (текТип is Токен.НачниОбъект)
                        корень.установи (разбериОбъект);
                    else
                       if (текТип is Токен.НачниМассив)
                           корень.установи (разбериМассив);
                       else
                          исключение ("не_годится json document");

                return корень;
        }

        /***********************************************************************
        
                Return a текст representation of this document

        ***********************************************************************/

        final T[] вТкст (T[] разделитель = пусто)
        {
                return корень.выведи (разделитель);
        }

        /***********************************************************************
        
                Returns the корень значение of this document

        ***********************************************************************/
        
        final Значение значение ()
        {
                return корень;
        }

        /***********************************************************************
        
                Набор the корень значение of this document

        ***********************************************************************/
        
        final Значение значение (Значение v)
        {
                return корень = v;
        }

        /***********************************************************************
        
                Созд a текст значение

        ***********************************************************************/
        
        final Значение значение (T[] v)
        {
                return создайЗначение.установи (v);
        }

        /***********************************************************************
        
                Созд a булево значение

        ***********************************************************************/
        
        final Значение значение (бул v)
        {
                return создайЗначение.установи (v);
        }

        /***********************************************************************
        
                Созд a numeric значение

        ***********************************************************************/
        
        final Значение значение (дво v)
        {
                return создайЗначение.установи (v);
        }

         /***********************************************************************
         
                 Созд a single Значение из_ an Массив of Values

         ***********************************************************************/

         final Значение значение (Значение[] vals)
         {
                 return создайЗначение.установи (vals);
         }

        /***********************************************************************
        
                Созд an Массив of значения

        ***********************************************************************/

        final Значение Массив (...)
        {
                return создайЗначение.установи (this, _arguments, _argptr);
        }

        /***********************************************************************
        
                Созд an attribute/значение пара, where значение дефолты в_ 
                пусто

        ***********************************************************************/
        
        Атрибут пара (T[] имя, Значение значение = пусто)
        {
                if (значение is пусто)
                    значение = создайЗначение;
                return создайАтрибут.установи (имя, значение);
        }

        /***********************************************************************
        
                Созд a composite из_ zero or ещё pairs, и return as 
                a значение

        ***********************************************************************/
        
        final Значение объект (Атрибут установи[]...)
        {
                return создайЗначение.установи (создайОбъект.добавь (установи));
        }

        /***********************************************************************
        
                Internal factory в_ создай значения

        ***********************************************************************/
        
        private Значение создайЗначение ()
        {
                return значения.размести.сбрось;
        }

        /***********************************************************************
        
                Internal factory в_ создай composites

        ***********************************************************************/
        
        private Композит создайОбъект ()
        {
                return objects.размести.сбрось;
        }

        /***********************************************************************
        
                Internal factory в_ создай атрибуты

        ***********************************************************************/
       
        private Атрибут создайАтрибут ()
        {
                return attrib.размести;
        }

        /***********************************************************************
        
                Throw a генерный исключение

        ***********************************************************************/
        
        private проц исключение (ткст сооб)
        {
                throw new Исключение (сооб);
        }

        /***********************************************************************
        
                Parse an экземпляр of a значение

        ***********************************************************************/
        
        private Значение разбериЗначение ()
        {
                auto v = значения.размести;

                switch (super.текТип)
                       {
                       case Токен.Да:
                            v.установи (Тип.Да);
                            break;

                       case Токен.Нет:
                            v.установи (Тип.Нет);
                            break;

                       case Токен.Пусто:
                            v.установи (Тип.Пусто);
                            break;

                       case Токен.НачниОбъект:
                            v.установи (разбериОбъект);
                            break;

                       case Токен.НачниМассив:
                            v.установи (разбериМассив);
                            break;

                       case Токен.Строка:
                            v.установи (super.значение, да);
                            break;

                       case Токен.Число:
                            v.установи (Float.разбор (super.значение));
                            break;

                       default:
                            v.установи (Тип.Пусто);
                            break;
                       }

                return v;
        }

        /***********************************************************************
        
                Parse an объект declaration

        ***********************************************************************/
        
        private Композит разбериОбъект ()
        {
                auto o = objects.размести.сбрось;

                while (super.следщ) 
                      {
                      if (super.текТип is Токен.ЗавершиОбъект)
                          return o;

                      if (super.текТип != Токен.Имя)
                          super.ожидалось ("an attribute-имя", super.стр.ptr);
                        
                      auto имя = super.значение;
                        
                      if (! super.следщ)
                            super.ожидалось ("an attribute-значение", super.стр.ptr);
                        
                      o.добавь (attrib.размести.установи (имя, разбериЗначение));
                      }

                return o;
        }
        
        /***********************************************************************
        
                Parse an Массив declaration

        ***********************************************************************/
        
        private Значение[] разбериМассив ()
        {
                if (nesting >= массивы.length)
                    исключение ("Массив nesting too deep внутри document");

                auto Массив = &массивы[nesting++];
                auto старт = Массив.индекс;

                while (super.следщ && super.текТип != Токен.ЗавершиМассив) 
                      {
                      if (Массив.индекс >= Массив.контент.length)
                          Массив.контент.length = Массив.контент.length + 300;

                      Массив.контент [Массив.индекс++] = разбериЗначение;
                      }

                if (super.текТип != Токен.ЗавершиМассив)
                    исключение ("malformed Массив");

                --nesting;
                return Массив.контент [старт .. Массив.индекс];
        }

        /***********************************************************************
        
                Represents an attribute/значение пара. Aliased as Атрибут

        ***********************************************************************/
        
        struct NameValue
        {
                private Атрибут       следщ;
                public  T[]             имя;
                public  Значение           значение;

                /***************************************************************
        
                        Набор a имя и a значение for this attribute

                        Returns itself, for use with Композит.добавь()

                ***************************************************************/
        
                Атрибут установи (T[] ключ, Значение знач)
                {
                        имя = ключ;
                        значение = знач;
                        return this;
                }
        }

        /***********************************************************************

                Represents a single json Объект (a composite of named 
                attribute/значение pairs).

                This is есть_алиас as Композит

        ***********************************************************************/
        
        struct JsonObject
        {
                private Атрибут голова,
                                  хвост;
                
                /***************************************************************
        
                ***************************************************************/
        
                Композит сбрось ()
                {
                        голова = хвост = пусто;
                        return this;
                }

                /***************************************************************
        
                        Доб an attribute/значение пара

                ***************************************************************/
        
                Композит добавь (Атрибут a)
                {
                        if (хвост)
                            хвост.следщ = a, хвост = a;
                        else
                           голова = хвост = a;
                        return this;
                }

                /***************************************************************
        
                        Добавь a установи of attribute/значение pairs

                ***************************************************************/
        
                Композит добавь (Атрибут[] установи...)
                {
                        foreach (атр; установи)
                                 добавь (атр);
                        return this;
                }

                /***************************************************************
                        
                        Construct и return a hashmap of Объект атрибуты.
                        This will be a fairly costly operation, so consопрer 
                        alternatives where appropriate

                ***************************************************************/
        
                Значение[T[]] hashmap ()
                {
                        Значение[T[]] члены;

                        auto a = голова;
                        while (a)
                              {
                              члены[a.имя] = a.значение;
                              a = a.следщ;
                              }

                        return члены;
                }
        
                /***************************************************************
        
                        Return a corresponding значение for the given attribute 
                        имя. Does a linear отыщи across the attribute установи

                ***************************************************************/
        
                Значение значение (T[] имя)
                {
                        auto a = голова;
                        while (a)
                               if (имя == a.имя)
                                   return a.значение;
                               else
                                  a = a.следщ;

                        return пусто;
                }
        
                /***************************************************************
        
                        Iterate over our attribute names и значения

                ***************************************************************/
        
                Обходчик атрибуты ()
                {
                        Обходчик i = {голова};
                        return i;
                }

                /***************************************************************
        
                        Iterate over our attribute names. Note that we 
                        use a Fruct в_ укз this, since foreach does
                        not operate cleanly with pointers (it doesn't 
                        automatically dereference them), whereas using 
                        x.атрибуты() does. 
                        
                        We may also use this в_ do some имя filtering

                ***************************************************************/
        
                static struct Обходчик
                {
                        private Атрибут голова;
        
                        цел opApply (цел delegate(ref T[] ключ, ref Значение знач) дг)
                        {
                                цел рез;
        
                                auto a = голова;
                                while (a)
                                      {
                                      if ((рез = дг (a.имя, a.значение)) != 0) 
                                           break;
                                      a = a.следщ;
                                      }
                               return рез;
                        }
                }
        }
        
        /***********************************************************************
        
                Represents a json значение that is one of the seven типы 
                specified via the Json.Тип enum 

        ***********************************************************************/
        
        struct JsonValue
        {
                private union
                {
                        Значение[]         Массив;
                        реал            число;
                        T[]             ткст;
                        Композит       объект;
                }
        
                public Тип тип;               /// the тип of this узел
                alias сбрось установи;                /// alternate имя for сбрось

                /***************************************************************
        
                        return да if this узел is of the given тип

                ***************************************************************/
        
                бул opEquals (Тип t) 
                {
                        return тип is t;
                }
                
                /***************************************************************
        
                        Return да if this значение represent Да

                ***************************************************************/
        
                бул вБул ()
                {
                        return (тип is Тип.Да);
                }

                /***************************************************************
                        
                        Return the ткст контент. Returns пусто if this
                        значение is not a ткст.

                        Uses приёмн for escape conversion where possible.

                ***************************************************************/
        
                T[] вТкст (T[] приёмн = пусто)
                {
                        if (тип is Тип.НеобрСтрока)
                            return ткст;

                        if (тип is Тип.Строка)
                            return убериИскейп (ткст, приёмн);

                        return пусто;
                }
                
                /***************************************************************
        
                        Emit the ткст контент в_ the given delegate, with
                        escape conversion as требуется.

                        Returns нет if this is not a Строка значение
                      
                ***************************************************************/
        
                бул вТкст (проц delegate(T[]) дг)
                {
                        if (тип is Тип.НеобрСтрока)
                            дг(ткст);
                        else
                           if (тип is Тип.Строка)
                               убериИскейп (ткст, дг);
                           else
                              return нет;
                        return да;
                }

                /***************************************************************
        
                        Return the контент as a Композит/Объект. Returns пусто
                        if this значение is not a Композит.

                ***************************************************************/
        
                Композит вОбъект ()
                {
                        return тип is Тип.Объект ? объект : пусто;
                }
                
                /***************************************************************
        
                        Return the контент as a дво. Returns nan where
                        the значение is not numeric.

                ***************************************************************/
        
                реал вЧисло ()
                {
                        return тип is Тип.Число ? число : реал.nan;
                }
                
                /***************************************************************
        
                        Return the контент as an Массив. Returns пусто where
                        the значение is not an Массив.

                ***************************************************************/
        
                Значение[] вМассив ()
                {
                        return (тип is Тип.Массив) ? Массив : пусто;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent a ткст. If 'escaped' 
                        is установи, the ткст is assumed в_ have pre-преобразованый
                        escaping of reserved characters (such as \t).

                ***************************************************************/
        
                Значение установи (T[] стр, бул escaped = нет)
                {
                        тип = escaped ? Тип.Строка : Тип.НеобрСтрока;
                        ткст = стр;
                        return this;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent an объект.

                ***************************************************************/
        
                Значение установи (Композит об)
                {
                        тип = Тип.Объект;
                        объект = об;
                        return this;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent a число.

                ***************************************************************/
        
                Значение установи (реал num)
                {
                        тип = Тип.Число;
                        число = num;
                        return this;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent a булево.

                ***************************************************************/
        
                Значение установи (бул b)
                {
                        тип = b ? Тип.Да : Тип.Нет;             
                        return this;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent an Массив of значения.

                ***************************************************************/
        
                Значение установи (Значение[] a)
                {
                        тип = Тип.Массив;
                        Массив = a;
                        return this;
                }
                
                /***************************************************************
        
                        Набор this значение в_ represent пусто

                ***************************************************************/
        
                Значение сбрось ()
                {
                        тип = Тип.Пусто;
                        return this;
                }
                
                /***************************************************************
        
                        Return a текст representation of this значение

                ***************************************************************/

                T[] выведи (T[] разделитель = пусто)
                {
                        T[] врем;
                        проц добавь (T[] s) {врем ~= s;}
                        выведи (&добавь, разделитель);
                        return врем;
                }

                /***************************************************************
        
                        Emit a текст representation of this значение в_ the 
                        given ИПотокВывода

                ***************************************************************/

                Значение выведи (ИПотокВывода s, T[] разделитель = пусто)
                {
                        return выведи ((T[] t){s.пиши(t);}, разделитель);
                }

                /***************************************************************
                        
                        Emit a текст representation of this значение в_ the
                        provопрed delegate

                ***************************************************************/
                
                Значение выведи (проц delegate(T[]) добавь, T[] разделитель = пусто)
                {
                        auto indent = 0;
        
                        проц нс ()
                        {
                                if (разделитель.length)
                                   {
                                   добавь ("\n");
                                   for (auto i=0; i < indent; i++)
                                        добавь (разделитель);
                                   }
                        }
        
                        проц printValue (Значение знач)
                        {
                                проц printObject (Композит об)
                                {
                                        if (об is пусто) 
                                            return;
                                        
                                        бул первый = да;
                                        добавь ("{");
                                        indent++;
        
                                        foreach (k, v; об.атрибуты)
                                                {
                                                if (!первый)  
                                                     добавь (",");
                                                нс;
                                                добавь (`"`), добавь(k), добавь(`":`);
                                                printValue (v);
                                                первый = нет;
                                                }
                                        indent--;
                                        нс;
                                        добавь ("}");
                                }
                                
                                проц printArray (Значение[] масс)
                                {
                                        бул первый = да;
                                        добавь ("[");
                                        indent++;
                                        foreach (v; масс)
                                                {
                                                if (!первый) 
                                                     добавь (", ");
                                                нс;
                                                printValue (v);
                                                первый = нет;
                                                }
                                        indent--;
                                        нс;
                                        добавь ("]");
                                }
        
        
                                if (знач is пусто) 
                                    return;
                                
                                switch (знач.тип)
                                       {
                                       T[64] врем =void;
        
                                       case Тип.Строка:
                                            добавь (`"`), добавь(знач.ткст), добавь(`"`);
                                            break;
        
                                       case Тип.НеобрСтрока:
                                            добавь (`"`), escape(знач.ткст, добавь), добавь(`"`);
                                            break;
        
                                       case Тип.Число:
                                            добавь (Float.форматируй (врем, знач.вЧисло));
                                            break;
        
                                       case Тип.Объект:
                                            auto об = знач.вОбъект;
                                            debug assert(об !is пусто);
                                            printObject (знач.вОбъект);
                                            break;
        
                                       case Тип.Массив:
                                            printArray (знач.вМассив);
                                            break;
        
                                       case Тип.Да:
                                            добавь ("да");
                                            break;
        
                                       case Тип.Нет:
                                            добавь ("нет");
                                            break;
        
                                       default:
                                       case Тип.Пусто:
                                            добавь ("пусто");
                                            break;
                                       }
                        }
                        
                        printValue (this);
                        return this;
                }

                /***************************************************************
        
                        Набор в_ a specified тип

                ***************************************************************/
        
                private Значение установи (Тип тип)
                {
                        this.тип = тип;
                        return this;
                }

                /***************************************************************
        
                        Набор a variety of значения преобр_в an Массив тип

                ***************************************************************/
        
                private Значение установи (Json хост, ИнфОТипе[] инфо, спис_ва арги)
                {
                        Значение[] список;

                        foreach (тип; инфо)
                                {
                                Значение v;
                                if (тип is typeid(Значение))
                                    v = ва_арг!(Значение)(арги);
                                else
                                   {
                                   v = хост.создайЗначение;
                                   if (тип is typeid(дво))
                                       v.установи (ва_арг!(дво)(арги));
                                   else
                                   if (тип is typeid(цел))
                                       v.установи (ва_арг!(цел)(арги));
                                   else
                                   if (тип is typeid(бул))
                                       v.установи (ва_арг!(бул)(арги));
                                   else
                                   if (тип is typeid(дол))
                                       v.установи (ва_арг!(дол)(арги));
                                   else
                                   if (тип is typeid(Композит))
                                       v.установи (ва_арг!(Композит)(арги));
                                   else
                                   if (тип is typeid(T[]))
                                       v.установи (ва_арг!(T[])(арги));
                                   else
                                   if (тип is typeid(ук))
                                       ва_арг!(ук)(арги);
                                   else
                                      хост.исключение ("JsonValue.установи :: неожиданный тип: "~тип.вТкст);
                                   }
                                список ~= v;
                                }
                        return установи (список);
                }
        }

        /***********************************************************************
        
                Internal allocation mechanism

        ***********************************************************************/
        
        private struct Разместитель(T)
        {
                private T[]     список;
                private T[][]   списки;
                private цел     индекс,
                                блок;

                проц сбрось ()
                {
                        // discard since приор списки are not инициализован
                        списки.length = 0;       
                        блок = -1;
                        новый_список;
                }

                T* размести ()
                {
                        if (индекс >= список.length)
                            новый_список;
        
                        auto p = &список [индекс++];
                        return p;
                }
        
                private проц новый_список ()
                {
                        индекс = 0;
                        if (++блок >= списки.length)
                           {
                           списки.length = списки.length + 1;
                           списки[$-1] = new T[256];
                           }
                        список = списки [блок];
                }
        }

        /***********************************************************************
            
                Internal use for parsing Массив значения
                    
        ***********************************************************************/
        
        private struct Массив
        {
                бцел            индекс;
                Значение[]         контент;
        }

        /***********************************************************************
        
                Internal document representation

        ***********************************************************************/
        
        private alias Разместитель!(NameValue)     Attrib;
        private alias Разместитель!(JsonValue)     Values;
        private alias Разместитель!(JsonObject)    Objects;

        private Attrib                          attrib;
        private Values                          значения;
        private Массив[]                         массивы;
        private Objects                         objects;
        private бцел                            nesting;
}



/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        unittest
        {
        with (new Json!(сим))
             {
             корень = объект
                  (
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(Массив(1, 2)))
                  );

             ткст значение = вТкст();
             assert (значение == `{"edgar":"friendly","счёт":11.5,"Массив":[1, 2]}`, значение);
             }
        }
        
        unittest
        {
        // проверь with a разделитель of the tab character
        with (new Json!(сим))
             {
             корень = объект
                  (
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(Массив(1, 2)))
                  );

             ткст значение = вТкст ("\t");
             assert (значение == "{\n\t\"edgar\":\"friendly\",\n\t\"счёт\":11.5,\n\t\"Массив\":[\n\t\t1, \n\t\t2\n\t]\n}", значение);
             }
        }
        
        unittest
        {
        // проверь with a разделитель of five пробелы
        with (new Json!(дим))
             {
             корень = объект
                  ( 
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(Массив(1, 2)))
                  );

             дим[] значение = вТкст ("     ");
             assert (значение == "{\n     \"edgar\":\"friendly\",\n     \"счёт\":11.5,\n     \"Массив\":[\n          1, \n          2\n     ]\n}");
             }
        }
}
        
/*******************************************************************************

*******************************************************************************/

debug (Json)
{
        import io.Stdout;
        import io.device.File;
        import time.StopWatch;
                
        проц main()
        {
                проц loop (JsonParser!(сим) парсер, ткст json, цел n)
                {
                        for (бцел i = 0; i < n; ++i)
                            {
                            парсер.сбрось (json);
                            while (парсер.следщ) {}
                            }
                }
        
                проц тест (ткст имяф, ткст txt)
                {
                        бцел n = (300 * 1024 * 1024) / txt.length;
                        auto парсер = new JsonParser!(сим);
                        
                        Секундомер watch;
                        watch.старт;
                        loop (парсер, txt, n);
                        auto t = watch.stop;
                        auto mb = (txt.length * n) / (1024 * 1024);
                        Стдвыв.форматнс("{} {} iterations, {} сек: {} MB/s", имяф, n, t, mb/t);
                }
        
                проц test1 (ткст имяф, ткст txt)
                {
                        бцел n = (200 * 1024 * 1024) / txt.length;
                        auto парсер = new Json!(сим);
                        
                        Секундомер watch;
                        watch.старт;
                        for (бцел i = 0; i < n; ++i)
                             парсер.разбор (txt);
        
                        auto t = watch.stop;
                        auto mb = (txt.length * n) / (1024 * 1024);
                        Стдвыв.форматнс("{} {} iterations, {} сек: {} MB/s", имяф, n, t, mb/t);
                }
        
                ткст загрузи (ткст файл)
                {
                        return cast(ткст) Файл.получи(файл);
                }
        
                //тест("test1.json", загрузи("test1.json"));
                //тест("test2.json", загрузи("test2.json"));
                //тест("test3.json", загрузи("test3.json"));
                        
                //test1("test1.json", загрузи("test1.json"));
                //test1("test2.json", загрузи("test2.json"));
                //test1("test3.json", загрузи("test3.json"));
                
                auto p = new Json!(сим);
                auto v = p.разбор (`{"t": да, "f":нет, "n":пусто, "hi":["world", "big", 123, [4, 5, ["foo"]]]}`);       
                Стдвыв.форматнс ("{}", p.вТкст);
        
                with (p)
                      значение = объект(пара("a", Массив(пусто, да, нет, 30, объект(пара("foo")))), пара("b", значение(10)));
        
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор ("[-1]");
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор(`["foo"]`);
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор(`{"foo": {"ff" : "ffff"}`);
                Стдвыв.форматнс ("{}", p.вТкст);

                with (new Json!(сим))
                     {
                     корень = объект(пара("Массив", Массив(пусто)));
                     Стдвыв.форматнс ("{}", вТкст());
                     }
        }
}



