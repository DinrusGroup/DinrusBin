module io.vfs.ZipFolder;

import Путь = io.Path;
import io.device.File : Файл;
import io.FilePath : ФПуть;
import io.device.TempFile : ВремФайл;
import util.compress.Zip : ЧитательЗип, ЧитательБлокаЗип,
       ПисательЗип, ПисательБлокаЗип, ЗаписьЗип, ИнфоОЗаписиЗип, Метод;
import io.model : ИПровод, ИПотокВвода, ИПотокВывода;
import io.vfs.model : ПапкаВфс, ЗаписьПапкиВфс, ФайлВфс,
       ПапкиВфс, ФайлыВфс, ФильтрВфс, СтатсВфс, ИнфОФильтреВфс,
       ИнфОВфс, СинхВфс;
import time.Time : Время;


private
{
    enum ТипЗаписи { Пап, Файл }
   
    struct Запись
    {
        ТипЗаписи тип;

        union
        {
            ПапЗапись пап;
            ФайлЗапись файл;
        }

        ткст полное_имя;
        ткст имя;

        ИнфОФильтреВфс инфОФильтреВфс;

        ИнфОВфс инфОВфс();
        проц сделайИнфОВфс();
        бул папка_ли();
        бул файл_ли();
        бдол размерФайла();
        ИПотокВвода откройВвод();
        ИПотокВывода откройВывод();
        проц вымести();
        проц вымести_отпрыски();
    }

    struct ПапЗапись
    {
        Запись*[ткст] ветви;
    }

    struct ФайлЗапись
    {
        ЗаписьЗип зипЗапись;
        ВремФайл времФайл;
    }
}

class ПапкаЗип : ПодпапкаЗип
{

    this(ткст путь, бул толькочтен_ли=нет);
    final override ПапкаВфс закрой(бул подай = да);
    final override ПапкаВфс синх();
    final бул толькочтен_ли();
    final ткст путь() ;
    final ткст путь(ткст v) ;

private:
    ЧитательЗип zr;
    Запись* корень;
    ткст _path;
    бул _readonly;
    бул изменён = нет;

    final бул толькочтен_ли(бул v);
    final бул закрыт();
    final бул действителен();
    final ИПотокВывода измениПоток(ИПотокВывода источник);
    проц измени_зап(бцел байты, проц[] ист);
    проц сбросьАрхив(ткст путь, бул толькочтен_ли=нет);
}

class ПодпапкаЗип : ПапкаВфс, СинхВфс
{

    final ткст имя();
    final override ткст вТкст();
    final ФайлВфс файл(ткст путь);
    final ЗаписьПапкиВфс папка(ткст путь);
    final ПапкиВфс сам();
    final ПапкиВфс дерево();
    final цел opApply(цел delegate(ref ПапкаВфс) дг);
    final ПапкаВфс очисть();
    final бул записываемый();
    ПапкаВфс закрой(бул подай = да);
    ПапкаВфс синх();
    final проц проверь(ПапкаВфс папка, бул mounting);
    final ПапкаЗип архив();

private:
    ПапкаЗип _archive;
    Запись* Запись;
    СтатсВфс статс;

    final ПапкаЗип архив(ПапкаЗип v);
    this(ПапкаЗип архив, Запись* Запись);
    final проц сбрось(ПапкаЗип архив, Запись* Запись);
    final бул действителен();
    final проц форсируй_изм();
    final проц измени();
    final ПодпапкаЗип[] папки(бул собери);
    final Запись*[] файлы(ref СтатсВфс статс, ФильтрВфс фильтр = пусто);
}

class ФайлЗип : ФайлВфс
{

    final ткст имя();
    final override ткст вТкст();
    final бул есть_ли();
    final бдол размер();
    final ФайлВфс копируй(ФайлВфс источник);
    final ФайлВфс перемести(ФайлВфс источник);
    final ФайлВфс создай();
    final ФайлВфс создай(ИПотокВвода поток);
    final ФайлВфс удали();
    final ИПотокВвода ввод();
    final ИПотокВывода вывод();
    final ФайлВфс dup();
    final Время изменён();
    
    private:
    ПапкаЗип архив;
    Запись* Запись;

    Запись* предок;
    ткст name_;

    this();
    this(ПапкаЗип архив, Запись* предок, Запись* Запись);
    this(ПапкаЗип архив, Запись* предок, ткст имя);
    final бул действителен();
    final проц форсируй_изм();
    final проц измени();
    final проц сбрось(ПапкаЗип архив, Запись* предок, Запись* Запись);
    final проц сбрось(ПапкаЗип архив, Запись* предок, ткст имя);
    final проц закрой();
}

// ************************************************************************ //
// ************************************************************************ //

class ЗаписьПодпапкиЗип : ЗаписьПапкиВфс
{
    final ПапкаВфс открой();
    final ПапкаВфс создай();
    final бул есть_ли();

private:
    ПапкаЗип архив;
    Запись* предок;
    ткст имя;

    this(ПапкаЗип архив, Запись* предок, ткст имя);	
    final бул действителен();    
    final проц форсируй_изм();
    final проц измени();
}


class ГруппаПодпапокЗип : ПапкиВфс
{
    final цел opApply(цел delegate(ref ПапкаВфс) дг);
    final бцел файлы();
    final бцел папки();
    final бцел записи();
    final бдол байты();
    final ПапкиВфс поднабор(ткст образец);
    final ФайлыВфс каталог(ткст образец);
    final ФайлыВфс каталог(ФильтрВфс фильтр = пусто);

private:
    ПапкаЗип архив;
    ПодпапкаЗип[] члены;

    this(ПапкаЗип архив, ПодпапкаЗип корень, бул рекурсия);
    this(ПапкаЗип архив, ПодпапкаЗип[] члены);
    final бул действителен();
    final ПодпапкаЗип[] скан(ПодпапкаЗип корень, бул рекурсия);
}

class ГруппаФайловЗип : ФайлыВфс
{
    final цел opApply(цел delegate(ref ФайлВфс) дг);
    final бцел файлы();
    final бдол байты();

private:
    ПапкаЗип архив;
    ФайлЗапись[] группа;
    СтатсВфс статс;

    struct ФайлЗапись
    {
        Запись* предок;
        Запись* Запись;
    }

    this(ПапкаЗип архив, ГруппаПодпапокЗип хост, ФильтрВфс фильтр);
    final бул действителен();
}

private:

проц ошибка(ткст сооб);
проц mutate_error(ткст метод);
бул nz(ткст s);
бул zero(ткст s);
бул single_path_part(ткст s);
ткст dir_app(ткст Пап, ткст имя);
проц headTail(ткст путь, out ткст голова, out ткст хвост);

/+

// ************************************************************************** //
// ************************************************************************** //
// ************************************************************************** //

// Dependencies
private:
import io.device.Conduit : Провод;

/*******************************************************************************

    copyright:  Copyright © 2007 Daniel Keep.  все rights reserved.

    license:    BSD стиль: $(LICENSE)

    version:    Prerelease

    author:     Daniel Keep

*******************************************************************************/

//module tangox.io.поток.DummyПоток;

//import io.device.Conduit : Провод;
//import io.model : ИПровод, ИПотокВвода, ИПотокВывода;

/**
 * The dummy поток classes are использован в_ provопрe simple, пустой поток objects
 * where one is требуется, but Неук is available.
 *
 * Note that, currently, these classes return 'пусто' for the underlying
 * провод, which will likely break код which expects Потокs в_ have an
 * underlying провод.
 */
private deprecated class DummyInputПоток : ИПотокВвода // ИПровод.ИШаг
{
    //alias ИПровод.ИШаг.Якорь Якорь;

    override ИПотокВвода ввод();
    override ИПровод провод() ;
    override проц закрой();
    override т_мера читай(проц[] приёмн) ;
    override ИПотокВвода слей() ;
    override проц[] загрузи(т_мера max=-1);
    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0);
}

/// ditto
private deprecated class DummyOutputПоток : ИПотокВывода //, ИПровод.ИШаг
{
    //alias ИПровод.ИШаг.Якорь Якорь;

    override ИПотокВывода вывод() ;
    override ИПровод провод() ;
    override проц закрой();
    override т_мера пиши(проц[] ист) ;
    override ИПотокВывода копируй(ИПотокВвода ист, т_мера max=-1);
    override ИПотокВывода слей() ;
    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0) ;
}

/*******************************************************************************

    copyright:  Copyright © 2007 Daniel Keep.  все rights reserved.

    license:    BSD стиль: $(LICENSE)

    version:    Prerelease

    author:     Daniel Keep

*******************************************************************************/

//module tangox.io.поток.EventПоток;

//import io.device.Conduit : Провод;
//import io.model : ИПровод, ИПотокВвода, ИПотокВывода;

/**
 * The событие поток classes are designed в_ allow you в_ принять feedback on
 * как a поток chain is being использован.  This is готово through the use of
 * delegate обрвызовы which are invoked just before the associated метод is
 * complete.
 */
class EventSeekInputПоток : ИПотокВвода //, ИПровод.ИШаг
{
    ///
    struct Обрвызовы
    {
        проц delegate()                     закрой; ///
        проц delegate()                     очисть; ///
        проц delegate(бцел, проц[])         читай; ///
        проц delegate(дол, дол, Якорь)   сместись; ///
    }

    //alias ИПровод.ИШаг.Якорь Якорь;

    ///
    this(ИПотокВвода источник, Обрвызовы обрвызовы);

    override ИПровод провод();

    ИПотокВвода ввод();

    override проц закрой();

    override т_мера читай(проц[] приёмн);

    override ИПотокВвода слей();

    override проц[] загрузи(т_мера max=-1);

    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0);

private:
    ИПотокВвода источник;
    ИПотокВвода шагун; //ИПровод.ИШаг шагун;
    Обрвызовы обрвызовы;

    invariant
    {
        assert( cast(Объект) источник is cast(Объект) шагун );
    }
}

/// ditto
class EventSeekOutputПоток : ИПотокВывода //, ИПровод.ИШаг
{
    ///
    struct Обрвызовы
    {
        проц delegate()                     закрой; ///
        проц delegate()                     слей; ///
        проц delegate(бцел, проц[])         пиши; ///
        проц delegate(дол, дол, Якорь)   сместись; ///
    }

    //alias ИПровод.ИШаг.Якорь Якорь;

    ///
    this(ИПотокВывода источник, Обрвызовы обрвызовы);

    override ИПровод провод();

    override ИПотокВывода вывод();

    override проц закрой();

    override т_мера пиши(проц[] приёмн);

    override ИПотокВывода слей();

    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0);

    override ИПотокВывода копируй(ИПотокВвода ист, т_мера max=-1);

private:
    ИПотокВывода источник;
    ИПотокВывода шагун; //ИПровод.ИШаг шагун;
    Обрвызовы обрвызовы;

    invariant
    {
        assert( cast(Объект) источник is cast(Объект) шагун );
    }
}

/*******************************************************************************

    copyright:  Copyright © 2007 Daniel Keep.  все rights reserved.

    license:    BSD стиль: $(LICENSE)

    version:    Prerelease

    author:     Daniel Keep

*******************************************************************************/

//module tangox.io.поток.WrapПоток;

//import io.device.Conduit : Провод;
//import io.model : ИПровод, ИПотокВвода, ИПотокВывода;

/**
 * This поток can be использован в_ provопрe доступ в_ другой поток.
 * Its distinguishing feature is that users cannot закрой the underlying
 * поток.
 *
 * This поток fully supports seeking, и as such требует that the
 * underlying поток also support seeking.
 */
class WrapSeekInputПоток : ИПотокВвода //, ИПровод.ИШаг
{
    //alias ИПровод.ИШаг.Якорь Якорь;

    /**
     * Созд a new wrap поток из_ the given источник.
     */
    this(ИПотокВвода источник);

    /// ditto
    this(ИПотокВвода источник, дол позиция);

    override ИПровод провод();

    ИПотокВвода ввод();

    override проц закрой();

    override т_мера читай(проц[] приёмн);

    override ИПотокВвода слей();

    override проц[] загрузи(т_мера max=-1);

    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0);

private:
    ИПотокВвода источник;
    ИПотокВвода шагун; //ИПровод.ИШаг шагун;
    дол _position;

    invariant
    {
        assert( cast(Объект) источник is cast(Объект) шагун );
        assert( _position >= 0 );
    }
}

/**
 * This поток can be использован в_ provопрe доступ в_ другой поток.
 * Its distinguishing feature is that the users cannot закрой the underlying
 * поток.
 *
 * This поток fully supports seeking, и as such требует that the
 * underlying поток also support seeking.
 */
class WrapSeekOutputПоток : ИПотокВывода//, ИПровод.ИШаг
{
    //alias ИПровод.ИШаг.Якорь Якорь;

    /**
     * Созд a new wrap поток из_ the given источник.
     */
    this(ИПотокВывода источник);

    /// ditto
    this(ИПотокВывода источник, дол позиция);

    override ИПровод провод();

    override ИПотокВывода вывод();

    override проц закрой();

    т_мера пиши(проц[] ист);

    override ИПотокВывода копируй(ИПотокВвода ист, т_мера max=-1);

    override ИПотокВывода слей();

    override дол сместись(дол смещение, Якорь якорь = cast(Якорь)0);

private:
    ИПотокВывода источник;
    ИПотокВывода шагун; //ИПровод.ИШаг шагун;
    дол _position;

    invariant
    {
        assert( cast(Объект) источник is cast(Объект) шагун );
        assert( _position >= 0 );
    }
}


+/