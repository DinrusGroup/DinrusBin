module io.stream.Buffered;

private import io.device.Conduit, io.model;

extern(D):

class БуфВвод : ФильтрВвода, БуферВвода
{
        alias слей             очисть;          /// очисть/слей are the same
        alias ФильтрВвода.ввод ввод;          /// доступ the источник 

        private проц[]        данные;             // the необр данные буфер
        private т_мера        индекс;            // текущ читай позиция
        private т_мера        протяженность;           // предел of действителен контент
        private т_мера        дименсия;        // maximum протяженность of контент

        this (ИПотокВвода поток);
        this (ИПотокВвода поток, т_мера ёмкость);
        static БуферВвода создай (ИПотокВвода поток);
        final т_мера наполни ();
        final проц[] opSlice (т_мера старт, т_мера конец);
        final проц[] срез ();
        final проц[] срез (т_мера размер, бул съешь = да);
        final т_мера читатель (т_мера delegate (проц[]) дг);
        public т_мера писатель (т_мера delegate (проц[]) дг);
        final override т_мера читай (проц[] приёмн);
        final т_мера заполни (проц[] приёмн, бул exact = нет);
        final бул пропусти (цел размер);
        final override дол сместись (дол смещение, Якорь старт = Якорь.Нач);
        final бул следщ (т_мера delegate (проц[]) скан);
        final т_мера резервируй (т_мера пространство);
        final БуферВвода сожми ();
        final т_мера дренируй (ИПотокВывода приёмн);
        final т_мера предел ();
        final т_мера ёмкость ();
        final т_мера позиция ();
        final т_мера читаемый ();
        final override БуфВвод слей ();
        final проц ввод (ИПотокВвода источник);
        final override проц[] загрузи (т_мера max = т_мера.max);                
        private т_мера загрузи (ИПотокВвода ист, т_мера инкремент, т_мера max);
        private final БуфВвод установи (проц[] данные, т_мера читаемый);
        private final т_мера записываемый ();
}

class БуфВывод : ФильтрВывода, БуферВывода
{
        alias ФильтрВывода.вывод вывод;       /// доступ the сток

        private проц[]        данные;             // the необр данные буфер
        private т_мера        индекс;            // текущ читай позиция
        private т_мера        протяженность;           // предел of действителен контент
        private т_мера        дименсия;        // maximum протяженность of контент


        this (ИПотокВывода поток);
        this (ИПотокВывода поток, т_мера ёмкость);
        static БуфВывод создай (ИПотокВывода поток);
        final проц[] срез ();
        final override т_мера пиши (проц[] ист);
        final БуфВывод добавь (проц[] ист);
        final БуфВывод добавь (ук ист, т_мера длина);
        final т_мера записываемый ();
        final т_мера предел ();
        final т_мера ёмкость ();
        final бул упрости (т_мера длина);
        static T[] преобразуй(T)(проц[] x);
        final override БуфВывод слей ();
        final override БуфВывод копируй (ИПотокВвода ист, т_мера max = -1);
        final т_мера дренируй (ИПотокВывода приёмн);
        final БуфВывод очисть ();
        final проц вывод (ИПотокВывода сток);
        final override дол сместись (дол смещение, Якорь старт = Якорь.Нач);
        final т_мера писатель (т_мера delegate (проц[]) дг);
        private final т_мера читатель (т_мера delegate (проц[]) дг);
        private final т_мера читаемый ();
        private final БуфВывод установи (проц[] данные, т_мера читаемый);
        private final БуфВывод сожми ();
}


public alias БуфВвод  Бввод;        /// shorthand alias
public alias БуфВывод Бвыв;       /// ditto
