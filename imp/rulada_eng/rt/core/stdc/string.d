/**
 * D header file for C99.
 *
 * Copyright: Public Domain
 * License:   Public Domain
 * Authors:   Sean Kelly
 * Standards: ISO/IEC 9899:1999 (E)
 */
module rt.core.stdc.string;

private import rt.core.stdc.stddef; // for size_t

extern  (C):

void* memchr(in void* s, int c, size_t n);
int   memcmp(in void* s1, in void* s2, size_t n);
void* memcpy(void* s1, in void* s2, size_t n);
void* memmove(void* s1, in void* s2, size_t n);
void* memset(void* s, int c, size_t n);

char*  strcpy(char* s1, in char* s2);
char*  strncpy(char* s1, in char* s2, size_t n);
char*  strcat(char* s1, in char* s2);
char*  strncat(char* s1, in char* s2, size_t n);
int    strcmp(in char* s1, in char* s2);
int    strcoll(in char* s1, in char* s2);
int    strncmp(in char* s1, in char* s2, size_t n);
size_t strxfrm(char* s1, in char* s2, size_t n);
char*  strchr(in char* s, int c);
size_t strcspn(in char* s1, in char* s2);
char*  strpbrk(in char* s1, in char* s2);
char*  strrchr(in char* s, int c);
size_t strspn(in char* s1, in char* s2);
char*  strstr(in char* s1, in char* s2);
char*  strtok(char* s1, in char* s2);
char*  strerror(int errnum);
size_t strlen(in char* s);

version (Windows)
{
    int memicmp(char* s1, char* s2, size_t n);	///

	///////////////////////////
	/*
	* memicmp /сравнибуфлюб/: Сравнивает символы из двух буферов (без учета региста).
	*/
	цел сравни_буферы_люб(усим буф1, усим буф2, т_мера члоб)
	{
	return cast(цел) memicmp(буф1, буф2, члоб);
	}
	
	alias сравни_буферы_люб сравнибуфлюб;
}

/////////////////////////////////////////////////////
/*
* memchr /ищисим/ ищет первый случай сим в 
* строке, состоящей из члабайт буфера. Она
* останавливается, когда найдёт сим, либо
* проверив первое члобайт.
*/
ук ищи_символ(in ук строка, цел сим, т_мера члобайт)
	{
	return memchr(строка, сим, члобайт);
	}
	
alias ищи_символ ищисим;

///////////////////////////////////////////////////////////
/*
* memcmp /сравнибуф/: Сравнение символов двух буферов.
* Если возврат < 0, то буф1 меньше буф2; возврат = 0, буферы идентичны;
* возврат > 0, буф1 больше буф2.
*/
цел сравни_буферы(in ук буф1, in ук буф2, т_мера члобайт)
	{
	return cast(цел)   memcmp(буф1, буф2, члобайт);
	}
	
alias сравни_буферы сравнибуф;

///////////////////////////////////////////////////////////
/*
* memcpy /копирбуф/ копирует члобайт из истока в приёмник;
* если исток и приёмник накладываются, то поведение
* memcpy неопределено. Для обработки накладывающихся
* регионов лучше использовать memmove /перембайт/.
*/
ук копируй_буфер(ук приёмник, in ук исток, т_мера члобайт)
	{
	return cast(ук) memcpy(приёмник, исток, члобайт);
	}
	
alias копируй_буфер копирбуф;

/////////////////////////////////////////////////////////////
/*
* memmove /перембуф/ копирует байты из откуда в куда.
* Если некоторые области исходной зоны и приёмной нахлёстываются,
* то гарантируется копирование исходных байтов из области
* накладки до того, как будет произведена перезапись.
*/
ук перемести_буфер(ук куда, in ук откуда, т_мера сколько)
	{
	return cast(ук) memmove(куда, откуда, сколько);
	}
	
alias перемести_буфер перембуф;

///////////////////////////////////////////////////
/*
* memset /устанбуф/ устанавливает первое чло символов приёмника
* где на символ сим.
*/
ук установи_буфер(ук где, цел сим, т_мера члосим)
	{
	return cast(ук) memset(где, сим, члосим);
	}
	
alias установи_буфер устанбуф;

/////////////////////////////////////////////
/*
* Функция strcpy /копиртекс/ копирует символы откуда,
* включая оканчивающий нуль, в место,
* указанное параметром куда. Поведение strcpy
* неопределено при накладке между источником и приёмником.
*/
усим копируй_символы(усим куда, in усим откуда)
	{
	return cast(усим)  strcpy(куда, откуда);
	}
	
alias копируй_символы копиртекс;

/////////////////////////////////////////////////
/*
* Функция strncpy /копирчтекс/ копирует начальное число символов
* из  откуда в куда, и возвращает куда. Если члосим меньше или
* равно длине откуда, то к копированной строке нулевой символ
* автоматически не добавляется. Если же члосим больше длины
* откуда, то принимающая строка заполняется на всю остаточную
* длину нулями. При накладке источника и приёмника поведение
* strncpy неопределено.
*/
усим копируй_чло_сим(усим куда, in усим откуда, т_мера члосим)
	{
	return cast(усим)  strncpy(куда, откуда, члосим);
	}
	
alias  копируй_чло_сим копирчтекс;

/////////////////////////////////////////////
/*
* Функция strcat /сотекс/ добавляет текст_плюс к ткст1,
* и завершает полученную строку нулевым символом.
* Начальный сивол текст_плюс переписывает конечный
* нулевой символ текст1. При накладке источника и
* приёмника поведение неопределено.
*/
усим соедини_тексты(усим текст1, in усим текст_плюс)
	{
	return cast(усим)  strcat(текст1, текст_плюс);
	}
	
alias соедини_тексты сотекс;

////////////////////////////////////////////////////
/*
* Функция strncat /сочтекс/ добавляет не более первого
* чласим ткст2 к ткст1. Начальный символ ткст2 переписывает
* конечный нулевой ткст1. Если до окончания добавления
* в стр2 попадается нулевой символ, то strncat добавляет
* все символы из ткст2, вплоть до нулевого. Если члосим
* больше длины ткст2, то эта длина ткст2 используется
* вместо члосим. Во всех случаях  получаемая строка
* оканчивается на нулевой символ. Если происходит копирование
* между налагающимися строками, то поведение её остаётся не выясненным.
*/
усим соедини_чло_сим(усим ткст1, in усим ткст2, т_мера члосим)
	{
	return cast(усим)  strncat(ткст1, ткст2, члосим);
	}
	
alias соедини_чло_сим сочтекс;

////////////////////////////////////////////
/*
* Сравнение символов двух строк. Функция strncmp /сравнитекс/ сравнивает
* лексикографически текст1 и текст2 и возвращает значение, показывающее их
* взаимоотношение.
* Если возврат < 0, то текст1 меньше текст2; возврат = 0, тексты идентичны;
* возврат > 0, текст1 больше текст2.
*/
цел сравни_тексты(in усим текст1, in усим текст2)
	{
	return cast(цел)    strcmp(текст1, текст2);
	}
	
alias сравни_тексты сравнитекс;

/////////////////////////////////////////////
/*
.........................
*/
цел кодстрсравнитекс( in усим текст1, in усим текст2)
	{
	return cast(цел)    strcoll(текст1, текст2);
	}
	
alias кодстрсравнитекс кссравнитекс;
///////////////////////////////////////////////
/*
* Сравнение символов двух строк с использованием текущей локали
* или заданной локали. Функция strncmp /сравничтекс/ сравнивает 
* лексикографически не более чем первые члосим в текст1 и текст2,
* и возвращает значение, показывающее взаимоотнощение между подстроками.
* strncmp - это регистрочувствительная версия _strnicmp.
*/
цел сравни_чло_сим(in усим текст1, in усим текст2, т_мера члосим)
	{
	return cast(цел) strncmp(текст1, текст2, члосим);
	}

alias сравни_чло_сим сравничтекс;

/////////////////////////////////////////////////
/*
* Функция strxfrm /форматчтекс/ преобразует строку, указанную как
* из, в новую форму, сохраняемую в в. Преобразуется не более
* чла символов, включая и нулевой, который помещаются в
* результат. Трансформация происходит с применением
* установки категории LC_COLLATE локали.
*/
т_мера преобразуй_чло_сим_лок(усим в, in усим из, т_мера чло)
	{
	return cast(т_мера) strxfrm(в, из, чло);
	}

alias преобразуй_чло_сим_лок форматчтекс;

//////////////////////////////////////////
/*
* Функция strchr /найдиперв/ находит первый случай с в строке т,
* либо возвращает NULL, если с не найден. В поиск включается и
* завершающий символ нуля.
*/
усим  найди_перв_сим(in усим т, цел с)
	{
	return cast(усим) strchr(т, с);
	}
	
alias найди_перв_сим найдиперв;

/////////////////////////////////////////
/*
* strcspn /персиндекс/: Возвращает индекс первого случая символа
* что в строке где, который принадлежит к указанному в что
* набору символов.
*/
т_мера дай_индекс_перв_сим(in усим где, in усим что)
	{
	return cast(т_мера) strcspn(где, что);
	}

alias дай_индекс_перв_сим персиндекс;

///////////////////////////////////////
/*
* Функция strpbrk /найдитексвнаб/ возвращает указатель на первый
* символ в строке вчём, принадлежащий набору символов
* из ряда изчего. Поиск не включает оканчивающего
* нулевого символа.
*/
усим  найди_сим_из_набора(in усим вчём, in усим изчего)
	{
	return cast(усим) strpbrk(вчём, изчего);
	}
	
alias найди_сим_из_набора найдитексвнаб;

/////////////////////////////////////
/*
* Функция strrchr /найдипос/ находит последний случай символа сим 
* (преобразованного в char) в строке ткс. В поиск входит 
* оканчивающий нулевой символ.
*/
усим  найди_посл_сим(in усим ткс, цел сим)
	{
	return cast(усим) strrchr(ткс, сим);
	}
	
alias найди_посл_сим найдипос;

/////////////////////////////////////
/*
* Функция strspn /найдитекснеизнаб/ возвращает индекс
* первого символа в строке вчём,не принадлежащего набору
* символов изчего. В поиск не входят
* оканчивающие нулевые символы.
*/

т_мера найди_сим_не_из_набора(in усим вчём, in усим изчего)
	{
	return cast(т_мера) strspn(вчём, изчего);
	}
	
alias найди_сим_не_из_набора найдитекснеизнаб;

/////////////////////////////////////////
/*
* Функция strstr /найдподстр/ возвращает указатель на первый случай
* искомой строки в строке стр. В поиске не участвуют
* завершающие нулевые символы.
*/
усим  найди_подстроку(in усим стр, in усим иском)
	{
	return cast(усим) strstr(стр, иском);
	}
	
alias найди_подстроку найдиподстр;

/////////////////////////////////////////
/*
* Функция strtok /стрзнак/ находит следующий знак в стрзнак.
* Набор символов в строгран определяет возможные
* разграничители искомого в стрзнак знака.
*/
усим  стрзнак(усим стрзнак, in усим строгран)
	{
	return cast(усим) strtok(стрзнак, строгран);
	}
////////////////////////////////////////
/*
* Функция strerror /строшиб/ преобразует номош в
* строку сообщения об ошибке, возвращая указатель на
* эту строку. Ни strerror, ни _strerror на самом деле
* не выводят сообщения: для этого требуется вызвать
* функцию вывода типа fprintf:

	if (( _access( "datafile",2 )) == -1 )
   fprintf( stderr, _strerror(NULL) );
   
* Если  strErrMsg передано как NULL, _strerror возвратит указатель
* на строку, содержащую системное сообщение об ошибке для последней
* вызваной библиотеки, создавшей ошибку. Строка сообщения об ошибке
* завершается символом перехода на новую строку ('\n'). Если strErrMsg
* не равно NULL, то _strerror возвращает уккзатель на строку,
* содержащую ваше сообщение об ошибке, точку с запятой, пробел, системное
* сообщение об ошибке последней вызванной библиотеки и символ новой строки.
* Строковое сообщение может быть длиной не более 94 символов.

* Действительный номер ошибки для _strerror хранится в переменной errno.
* Системные сообщения об ошибке доступны через переменную _sys_errlist,
* являющую собой масссив упорядоченных по номеру ошибки сообщений.
* _strerror получает доступ к соответствующему сообщению по значению errno,
* представляющему индекс в переменной _sys_errlist. Значение переменной _sys_nerr
* определено как максимальное число элементов в массиве _sys_errlist. 
* Для правильной работы _strerror вызывается сразу после того, как процедура
* библиотеки вернула ошибку. Иначе последующие вызовы strerror или _strerror
* могут переписать значение errno.
*/
усим  строшиб(цел номош)
	{
	return cast(усим) strerror(cast(int) номош);
	}

////////////////////////////////////////
/*
* strlen /длинтекс/ воспринимает строку как однобайтный символьный ряд, поэтому значение
* возврата всегда равно числу байтов, даже если в строке есть многобайтные
* символы. wcslen -это широкосимвольная версия strlen.
*/
т_мера длинтекс(in усим текст)
	{
	return cast(т_мера) strlen (текст);
	}
